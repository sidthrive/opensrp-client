require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"xpath-evaluator-binding":[function(require,module,exports){
     var XPathJS = require( 'enketo-xpathjs' );

     module.exports = function() {
         var evaluator = new XPathJS.XPathEvaluator();

         XPathJS.bindDomLevel3XPath( this.xml, {
             'window': {
                 JsXPathException: true,
                 JsXPathExpression: true,
                 JsXPathNSResolver: true,
                 JsXPathResult: true,
                 JsXPathNamespace: true
             },
             'document': {
                 jsCreateExpression: function() {
                     return evaluator.createExpression.apply( evaluator, arguments );
                 },
                 jsCreateNSResolver: function() {
                     return evaluator.createNSResolver.apply( evaluator, arguments );
                 },
                 jsEvaluate: function() {
                     return evaluator.evaluate.apply( evaluator, arguments );
                 }
             }
         } );
     };

     },{"enketo-xpathjs":"enketo-xpathjs"}],
     "apps":[function(require,module,exports){
  /**
   * This file is just meant to facilitate enketo-core development as a standalone library.
   *
   * When using enketo-core as a library inside your app, it is recommended to just **ignore** this file.
   * Place a replacement for this controller elsewhere in your app.
   */

  var $ = require( 'jquery' );
  window.jQuery = $; // required for bootstrap-timepicker
  var support = require( './src/js/support' );
  var Form = require( './src/js/Form' );
  var fileManager = require( './src/js/file-manager' );
  var loadErrors;
  var form;
  var formStr;
  var modelStr;
  var instanceStr;
  var xform = getURLParameter( 'xform' );

  window.refreshDateFields = function(){
  $('input[type="date"]')
         .each(function() {
              //this.selected = (this.text == myVal);
              this.setAttribute('type', 'text');
              this.setAttribute('type', 'date');
         });
  };

  // if querystring touch=true is added, override detected touchscreen presence
  if ( getURLParameter( 'touch' ) === 'true' ) {
      support.touch = true;
      $( 'html' ).addClass( 'touch' );
  }

  // Check if HTML form is hardcoded or needs to be retrieved
  // note: when running this file in enketo-core-performance-monitor xform = 'null'
  if ( xform && xform !== 'null' ) {
      $( '.guidance' ).remove();
      xform = /^https?:\/\//.test( xform ) ? xform : location.origin + '/' + xform;
      $.getJSON( 'http://' + location.hostname + ':8085/transform?xform=' + xform, function( survey ) {
          formStr = survey.form;
          modelStr = survey.model;
          $( '.form-header' ).after( formStr );
          initializeForm();
      } );
  } else if ( $( 'form.or' ).length > 0 ) {
      $( '.guidance' ).remove();
      modelStr = globalModelStr;
      initializeForm();
  }
window.loadDraft = function(xmlDataString){
	$( '.guidance' ).remove();
    instanceStr = xmlDataString;
    Android.log(xmlDataString);
    form.resetView();
    //form.init();
    initializeForm();
}

window.savePartialData = function(){
	Android.savePartialFormData(form.getDataStr());
}
  // validate handler for validate button
  $( '#validate-form' ).on( 'click', function() {
      // validate form
      form.validate()
          .then( function( valid ) {
              if ( !valid ) {
                  //alert( 'Form contains errors. Please see fields marked in red.' );
                  Android.showFormErrorToast();
              } else {
                  //alert( 'Form is valid! (see XML record and media files in the console)' );
                  //$( 'form.or' ).trigger( 'beforesave' );
                  //console.log( 'record:', form.getDataStr() );
                  //console.log( 'media files:', fileManager.getCurrentFiles() );
                  Android.processFormSubmission(form.getDataStr());
              }
          } );
  } );

  window.resetForm = function() {
  	$( '.guidance' ).remove();
      modelStr = globalModelStr;
      form.resetView();
      initializeForm();
  }

  // initialize the form
  function initializeForm() {
      form = new Form( 'form.or:eq(0)', {
          modelStr: modelStr
      }, {
          arcGis: {
              basemaps: [ "streets", "topo", "satellite", "osm" ],
              webMapId: 'f2e9b762544945f390ca4ac3671cfa72',
              hasZ: true
          },
          'clearIrrelevantImmediately': false,
          'goTo': true
      } );
      // for debugging
      window.form = form;
      //initialize form and check for load errors
      loadErrors = form.init();
      if ( loadErrors.length > 0 ) {
          alert( 'loadErrors: ' + loadErrors.join( ', ' ) );
      }
      Android.javascriptLoaded();
  }

  // get query string parameter
  function getURLParameter( name ) {
      return decodeURI(
          ( new RegExp( name + '=' + '(.+?)(&|$)' ).exec( location.search ) || [ null, null ] )[ 1 ]
      );
  }
  },{"jquery":"jquery","./src/js/support":"support","./src/js/Form":"Form","./src/js/file-manager":"file-manager"}],
   "jquery":[function(require,module,exports){
   /*! jQuery v3.2.1 | (c) JS Foundation and other contributors | jquery.org/license */
   !function(a,b){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){"use strict";var c=[],d=a.document,e=Object.getPrototypeOf,f=c.slice,g=c.concat,h=c.push,i=c.indexOf,j={},k=j.toString,l=j.hasOwnProperty,m=l.toString,n=m.call(Object),o={};function p(a,b){b=b||d;var c=b.createElement("script");c.text=a,b.head.appendChild(c).parentNode.removeChild(c)}var q="3.2.1",r=function(a,b){return new r.fn.init(a,b)},s=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,t=/^-ms-/,u=/-([a-z])/g,v=function(a,b){return b.toUpperCase()};r.fn=r.prototype={jquery:q,constructor:r,length:0,toArray:function(){return f.call(this)},get:function(a){return null==a?f.call(this):a<0?this[a+this.length]:this[a]},pushStack:function(a){var b=r.merge(this.constructor(),a);return b.prevObject=this,b},each:function(a){return r.each(this,a)},map:function(a){return this.pushStack(r.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(f.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(a<0?b:0);return this.pushStack(c>=0&&c<b?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:h,sort:c.sort,splice:c.splice},r.extend=r.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||r.isFunction(g)||(g={}),h===i&&(g=this,h--);h<i;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(r.isPlainObject(d)||(e=Array.isArray(d)))?(e?(e=!1,f=c&&Array.isArray(c)?c:[]):f=c&&r.isPlainObject(c)?c:{},g[b]=r.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},r.extend({expando:"jQuery"+(q+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===r.type(a)},isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){var b=r.type(a);return("number"===b||"string"===b)&&!isNaN(a-parseFloat(a))},isPlainObject:function(a){var b,c;return!(!a||"[object Object]"!==k.call(a))&&(!(b=e(a))||(c=l.call(b,"constructor")&&b.constructor,"function"==typeof c&&m.call(c)===n))},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?j[k.call(a)]||"object":typeof a},globalEval:function(a){p(a)},camelCase:function(a){return a.replace(t,"ms-").replace(u,v)},each:function(a,b){var c,d=0;if(w(a)){for(c=a.length;d<c;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(s,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(w(Object(a))?r.merge(c,"string"==typeof a?[a]:a):h.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:i.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;d<c;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;f<g;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,f=0,h=[];if(w(a))for(d=a.length;f<d;f++)e=b(a[f],f,c),null!=e&&h.push(e);else for(f in a)e=b(a[f],f,c),null!=e&&h.push(e);return g.apply([],h)},guid:1,proxy:function(a,b){var c,d,e;if("string"==typeof b&&(c=a[b],b=a,a=c),r.isFunction(a))return d=f.call(arguments,2),e=function(){return a.apply(b||this,d.concat(f.call(arguments)))},e.guid=a.guid=a.guid||r.guid++,e},now:Date.now,support:o}),"function"==typeof Symbol&&(r.fn[Symbol.iterator]=c[Symbol.iterator]),r.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){j["[object "+b+"]"]=b.toLowerCase()});function w(a){var b=!!a&&"length"in a&&a.length,c=r.type(a);return"function"!==c&&!r.isWindow(a)&&("array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a)}var x=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},J="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",K="[\\x20\\t\\r\\n\\f]",L="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",M="\\["+K+"*("+L+")(?:"+K+"*([*^$|!~]?=)"+K+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+L+"))|)"+K+"*\\]",N=":("+L+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+M+")*)|.*)\\)|)",O=new RegExp(K+"+","g"),P=new RegExp("^"+K+"+|((?:^|[^\\\\])(?:\\\\.)*)"+K+"+$","g"),Q=new RegExp("^"+K+"*,"+K+"*"),R=new RegExp("^"+K+"*([>+~]|"+K+")"+K+"*"),S=new RegExp("="+K+"*([^\\]'\"]*?)"+K+"*\\]","g"),T=new RegExp(N),U=new RegExp("^"+L+"$"),V={ID:new RegExp("^#("+L+")"),CLASS:new RegExp("^\\.("+L+")"),TAG:new RegExp("^("+L+"|[*])"),ATTR:new RegExp("^"+M),PSEUDO:new RegExp("^"+N),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+K+"*(even|odd|(([+-]|)(\\d*)n|)"+K+"*(?:([+-]|)"+K+"*(\\d+)|))"+K+"*\\)|)","i"),bool:new RegExp("^(?:"+J+")$","i"),needsContext:new RegExp("^"+K+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+K+"*((?:-\\d)?\\d*)"+K+"*\\)|)(?=[^-]|$)","i")},W=/^(?:input|select|textarea|button)$/i,X=/^h\d$/i,Y=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=new RegExp("\\\\([\\da-f]{1,6}"+K+"?|("+K+")|.)","ig"),aa=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:d<0?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ba=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ca=function(a,b){return b?"\0"===a?"\ufffd":a.slice(0,-1)+"\\"+a.charCodeAt(a.length-1).toString(16)+" ":"\\"+a},da=function(){m()},ea=ta(function(a){return a.disabled===!0&&("form"in a||"label"in a)},{dir:"parentNode",next:"legend"});try{G.apply(D=H.call(v.childNodes),v.childNodes),D[v.childNodes.length].nodeType}catch(fa){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s=b&&b.ownerDocument,w=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==w&&9!==w&&11!==w)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==w&&(l=Z.exec(a)))if(f=l[1]){if(9===w){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(s&&(j=s.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(l[2])return G.apply(d,b.getElementsByTagName(a)),d;if((f=l[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==w)s=b,r=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(ba,ca):b.setAttribute("id",k=u),o=g(a),h=o.length;while(h--)o[h]="#"+k+" "+sa(o[h]);r=o.join(","),s=$.test(a)&&qa(b.parentNode)||b}if(r)try{return G.apply(d,s.querySelectorAll(r)),d}catch(x){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(P,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("fieldset");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&a.sourceIndex-b.sourceIndex;if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return function(b){return"form"in b?b.parentNode&&b.disabled===!1?"label"in b?"label"in b.parentNode?b.parentNode.disabled===a:b.disabled===a:b.isDisabled===a||b.isDisabled!==!a&&ea(b)===a:b.disabled===a:"label"in b&&b.disabled===a}}function pa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function qa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return!!b&&"HTML"!==b.nodeName},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),v!==n&&(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Y.test(n.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){return a.getAttribute("id")===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}}):(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c,d,e,f=b.getElementById(a);if(f){if(c=f.getAttributeNode("id"),c&&c.value===a)return[f];e=b.getElementsByName(a),d=0;while(f=e[d++])if(c=f.getAttributeNode("id"),c&&c.value===a)return[f]}return[]}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){if("undefined"!=typeof b.getElementsByClassName&&p)return b.getElementsByClassName(a)},r=[],q=[],(c.qsa=Y.test(n.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+K+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+K+"*(?:value|"+J+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){a.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+K+"*[*^$|!~]?="),2!==a.querySelectorAll(":enabled").length&&q.push(":enabled",":disabled"),o.appendChild(a).disabled=!0,2!==a.querySelectorAll(":disabled").length&&q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Y.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"*"),s.call(a,"[s!='']:x"),r.push("!=",N)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Y.test(o.compareDocumentPosition),t=b||Y.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?I(k,a)-I(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?I(k,a)-I(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?la(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(S,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.escape=function(a){return(a+"").replace(ba,ca)},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(_,aa),a[3]=(a[3]||a[4]||a[5]||"").replace(_,aa),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return V.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&T.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(_,aa).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+K+")"+a+"("+K+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:!b||(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(O," ")+" ").indexOf(c)>-1:"|="===b&&(e===c||e.slice(0,c.length+1)===c+"-"))}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(P,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(_,aa),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return U.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(_,aa).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:oa(!1),disabled:oa(!0),checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:pa(function(){return[0]}),last:pa(function(a,b){return[b-1]}),eq:pa(function(a,b,c){return[c<0?c+b:c]}),even:pa(function(a,b){for(var c=0;c<b;c+=2)a.push(c);return a}),odd:pa(function(a,b){for(var c=1;c<b;c+=2)a.push(c);return a}),lt:pa(function(a,b,c){for(var d=c<0?c+b:c;--d>=0;)a.push(d);return a}),gt:pa(function(a,b,c){for(var d=c<0?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function ra(){}ra.prototype=d.filters=d.pseudos,d.setFilters=new ra,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=Q.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P," ")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function sa(a){for(var b=0,c=a.length,d="";b<c;b++)d+=a[b].value;return d}function ta(a,b,c){var d=b.dir,e=b.next,f=e||d,g=c&&"parentNode"===f,h=x++;return b.first?function(b,c,e){while(b=b[d])if(1===b.nodeType||g)return a(b,c,e);return!1}:function(b,c,i){var j,k,l,m=[w,h];if(i){while(b=b[d])if((1===b.nodeType||g)&&a(b,c,i))return!0}else while(b=b[d])if(1===b.nodeType||g)if(l=b[u]||(b[u]={}),k=l[b.uniqueID]||(l[b.uniqueID]={}),e&&e===b.nodeName.toLowerCase())b=b[d]||b;else{if((j=k[f])&&j[0]===w&&j[1]===h)return m[2]=j[2];if(k[f]=m,m[2]=a(b,c,i))return!0}return!1}}function ua(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function va(a,b,c){for(var d=0,e=b.length;d<e;d++)ga(a,b[d],c);return c}function wa(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;h<i;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function xa(a,b,c,d,e,f){return d&&!d[u]&&(d=xa(d)),e&&!e[u]&&(e=xa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||va(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:wa(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=wa(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=wa(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ya(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ta(function(a){return a===b},h,!0),l=ta(function(a){return I(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];i<f;i++)if(c=d.relative[a[i].type])m=[ta(ua(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;e<f;e++)if(d.relative[a[e].type])break;return xa(i>1&&ua(m),i>1&&sa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(P,"$1"),c,i<e&&ya(a.slice(i,e)),e<f&&ya(a=a.slice(e)),e<f&&sa(a))}m.push(c)}return ua(m)}function za(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=E.call(i));u=wa(u)}G.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&ga.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=ya(b[c]),f[u]?d.push(f):e.push(f);f=A(a,za(e,d)),f.selector=a}return f},i=ga.select=function(a,b,c,e){var f,i,j,k,l,m="function"==typeof a&&a,n=!e&&g(a=m.selector||a);if(c=c||[],1===n.length){if(i=n[0]=n[0].slice(0),i.length>2&&"ID"===(j=i[0]).type&&9===b.nodeType&&p&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(_,aa),b)||[])[0],!b)return c;m&&(b=b.parentNode),a=a.slice(i.shift().value.length)}f=V.needsContext.test(a)?0:i.length;while(f--){if(j=i[f],d.relative[k=j.type])break;if((l=d.find[k])&&(e=l(j.matches[0].replace(_,aa),$.test(i[0].type)&&qa(b.parentNode)||b))){if(i.splice(f,1),a=e.length&&sa(i),!a)return G.apply(c,e),c;break}}}return(m||h(a,n))(e,b,!p,c,!b||$.test(a)&&qa(b.parentNode)||b),c},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("fieldset"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){if(!c)return a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){if(!c&&"input"===a.nodeName.toLowerCase())return a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(J,function(a,b,c){var d;if(!c)return a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);r.find=x,r.expr=x.selectors,r.expr[":"]=r.expr.pseudos,r.uniqueSort=r.unique=x.uniqueSort,r.text=x.getText,r.isXMLDoc=x.isXML,r.contains=x.contains,r.escapeSelector=x.escape;var y=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&r(a).is(c))break;d.push(a)}return d},z=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},A=r.expr.match.needsContext;function B(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()}var C=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,D=/^.[^:#\[\.,]*$/;function E(a,b,c){return r.isFunction(b)?r.grep(a,function(a,d){return!!b.call(a,d,a)!==c}):b.nodeType?r.grep(a,function(a){return a===b!==c}):"string"!=typeof b?r.grep(a,function(a){return i.call(b,a)>-1!==c}):D.test(b)?r.filter(b,a,c):(b=r.filter(b,a),r.grep(a,function(a){return i.call(b,a)>-1!==c&&1===a.nodeType}))}r.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?r.find.matchesSelector(d,a)?[d]:[]:r.find.matches(a,r.grep(b,function(a){return 1===a.nodeType}))},r.fn.extend({find:function(a){var b,c,d=this.length,e=this;if("string"!=typeof a)return this.pushStack(r(a).filter(function(){for(b=0;b<d;b++)if(r.contains(e[b],this))return!0}));for(c=this.pushStack([]),b=0;b<d;b++)r.find(a,e[b],c);return d>1?r.uniqueSort(c):c},filter:function(a){return this.pushStack(E(this,a||[],!1))},not:function(a){return this.pushStack(E(this,a||[],!0))},is:function(a){return!!E(this,"string"==typeof a&&A.test(a)?r(a):a||[],!1).length}});var F,G=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,H=r.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||F,"string"==typeof a){if(e="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:G.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof r?b[0]:b,r.merge(this,r.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),C.test(e[1])&&r.isPlainObject(b))for(e in b)r.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}return f=d.getElementById(e[2]),f&&(this[0]=f,this.length=1),this}return a.nodeType?(this[0]=a,this.length=1,this):r.isFunction(a)?void 0!==c.ready?c.ready(a):a(r):r.makeArray(a,this)};H.prototype=r.fn,F=r(d);var I=/^(?:parents|prev(?:Until|All))/,J={children:!0,contents:!0,next:!0,prev:!0};r.fn.extend({has:function(a){var b=r(a,this),c=b.length;return this.filter(function(){for(var a=0;a<c;a++)if(r.contains(this,b[a]))return!0})},closest:function(a,b){var c,d=0,e=this.length,f=[],g="string"!=typeof a&&r(a);if(!A.test(a))for(;d<e;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&r.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?r.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?i.call(r(a),this[0]):i.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(r.uniqueSort(r.merge(this.get(),r(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function K(a,b){while((a=a[b])&&1!==a.nodeType);return a}r.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return y(a,"parentNode")},parentsUntil:function(a,b,c){return y(a,"parentNode",c)},next:function(a){return K(a,"nextSibling")},prev:function(a){return K(a,"previousSibling")},nextAll:function(a){return y(a,"nextSibling")},prevAll:function(a){return y(a,"previousSibling")},nextUntil:function(a,b,c){return y(a,"nextSibling",c)},prevUntil:function(a,b,c){return y(a,"previousSibling",c)},siblings:function(a){return z((a.parentNode||{}).firstChild,a)},children:function(a){return z(a.firstChild)},contents:function(a){return B(a,"iframe")?a.contentDocument:(B(a,"template")&&(a=a.content||a),r.merge([],a.childNodes))}},function(a,b){r.fn[a]=function(c,d){var e=r.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=r.filter(d,e)),this.length>1&&(J[a]||r.uniqueSort(e),I.test(a)&&e.reverse()),this.pushStack(e)}});var L=/[^\x20\t\r\n\f]+/g;function M(a){var b={};return r.each(a.match(L)||[],function(a,c){b[c]=!0}),b}r.Callbacks=function(a){a="string"==typeof a?M(a):r.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=e||a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){r.each(b,function(b,c){r.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==r.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return r.each(arguments,function(a,b){var c;while((c=r.inArray(b,f,c))>-1)f.splice(c,1),c<=h&&h--}),this},has:function(a){return a?r.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=g=[],c||b||(f=c=""),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j};function N(a){return a}function O(a){throw a}function P(a,b,c,d){var e;try{a&&r.isFunction(e=a.promise)?e.call(a).done(b).fail(c):a&&r.isFunction(e=a.then)?e.call(a,b,c):b.apply(void 0,[a].slice(d))}catch(a){c.apply(void 0,[a])}}r.extend({Deferred:function(b){var c=[["notify","progress",r.Callbacks("memory"),r.Callbacks("memory"),2],["resolve","done",r.Callbacks("once memory"),r.Callbacks("once memory"),0,"resolved"],["reject","fail",r.Callbacks("once memory"),r.Callbacks("once memory"),1,"rejected"]],d="pending",e={state:function(){return d},always:function(){return f.done(arguments).fail(arguments),this},"catch":function(a){return e.then(null,a)},pipe:function(){var a=arguments;return r.Deferred(function(b){r.each(c,function(c,d){var e=r.isFunction(a[d[4]])&&a[d[4]];f[d[1]](function(){var a=e&&e.apply(this,arguments);a&&r.isFunction(a.promise)?a.promise().progress(b.notify).done(b.resolve).fail(b.reject):b[d[0]+"With"](this,e?[a]:arguments)})}),a=null}).promise()},then:function(b,d,e){var f=0;function g(b,c,d,e){return function(){var h=this,i=arguments,j=function(){var a,j;if(!(b<f)){if(a=d.apply(h,i),a===c.promise())throw new TypeError("Thenable self-resolution");j=a&&("object"==typeof a||"function"==typeof a)&&a.then,r.isFunction(j)?e?j.call(a,g(f,c,N,e),g(f,c,O,e)):(f++,j.call(a,g(f,c,N,e),g(f,c,O,e),g(f,c,N,c.notifyWith))):(d!==N&&(h=void 0,i=[a]),(e||c.resolveWith)(h,i))}},k=e?j:function(){try{j()}catch(a){r.Deferred.exceptionHook&&r.Deferred.exceptionHook(a,k.stackTrace),b+1>=f&&(d!==O&&(h=void 0,i=[a]),c.rejectWith(h,i))}};b?k():(r.Deferred.getStackHook&&(k.stackTrace=r.Deferred.getStackHook()),a.setTimeout(k))}}return r.Deferred(function(a){c[0][3].add(g(0,a,r.isFunction(e)?e:N,a.notifyWith)),c[1][3].add(g(0,a,r.isFunction(b)?b:N)),c[2][3].add(g(0,a,r.isFunction(d)?d:O))}).promise()},promise:function(a){return null!=a?r.extend(a,e):e}},f={};return r.each(c,function(a,b){var g=b[2],h=b[5];e[b[1]]=g.add,h&&g.add(function(){d=h},c[3-a][2].disable,c[0][2].lock),g.add(b[3].fire),f[b[0]]=function(){return f[b[0]+"With"](this===f?void 0:this,arguments),this},f[b[0]+"With"]=g.fireWith}),e.promise(f),b&&b.call(f,f),f},when:function(a){var b=arguments.length,c=b,d=Array(c),e=f.call(arguments),g=r.Deferred(),h=function(a){return function(c){d[a]=this,e[a]=arguments.length>1?f.call(arguments):c,--b||g.resolveWith(d,e)}};if(b<=1&&(P(a,g.done(h(c)).resolve,g.reject,!b),"pending"===g.state()||r.isFunction(e[c]&&e[c].then)))return g.then();while(c--)P(e[c],h(c),g.reject);return g.promise()}});var Q=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;r.Deferred.exceptionHook=function(b,c){a.console&&a.console.warn&&b&&Q.test(b.name)&&a.console.warn("jQuery.Deferred exception: "+b.message,b.stack,c)},r.readyException=function(b){a.setTimeout(function(){throw b})};var R=r.Deferred();r.fn.ready=function(a){return R.then(a)["catch"](function(a){r.readyException(a)}),this},r.extend({isReady:!1,readyWait:1,ready:function(a){(a===!0?--r.readyWait:r.isReady)||(r.isReady=!0,a!==!0&&--r.readyWait>0||R.resolveWith(d,[r]))}}),r.ready.then=R.then;function S(){d.removeEventListener("DOMContentLoaded",S),
   a.removeEventListener("load",S),r.ready()}"complete"===d.readyState||"loading"!==d.readyState&&!d.documentElement.doScroll?a.setTimeout(r.ready):(d.addEventListener("DOMContentLoaded",S),a.addEventListener("load",S));var T=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===r.type(c)){e=!0;for(h in c)T(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,r.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(r(a),c)})),b))for(;h<i;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},U=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function V(){this.expando=r.expando+V.uid++}V.uid=1,V.prototype={cache:function(a){var b=a[this.expando];return b||(b={},U(a)&&(a.nodeType?a[this.expando]=b:Object.defineProperty(a,this.expando,{value:b,configurable:!0}))),b},set:function(a,b,c){var d,e=this.cache(a);if("string"==typeof b)e[r.camelCase(b)]=c;else for(d in b)e[r.camelCase(d)]=b[d];return e},get:function(a,b){return void 0===b?this.cache(a):a[this.expando]&&a[this.expando][r.camelCase(b)]},access:function(a,b,c){return void 0===b||b&&"string"==typeof b&&void 0===c?this.get(a,b):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d=a[this.expando];if(void 0!==d){if(void 0!==b){Array.isArray(b)?b=b.map(r.camelCase):(b=r.camelCase(b),b=b in d?[b]:b.match(L)||[]),c=b.length;while(c--)delete d[b[c]]}(void 0===b||r.isEmptyObject(d))&&(a.nodeType?a[this.expando]=void 0:delete a[this.expando])}},hasData:function(a){var b=a[this.expando];return void 0!==b&&!r.isEmptyObject(b)}};var W=new V,X=new V,Y=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Z=/[A-Z]/g;function $(a){return"true"===a||"false"!==a&&("null"===a?null:a===+a+""?+a:Y.test(a)?JSON.parse(a):a)}function _(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(Z,"-$&").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c=$(c)}catch(e){}X.set(a,b,c)}else c=void 0;return c}r.extend({hasData:function(a){return X.hasData(a)||W.hasData(a)},data:function(a,b,c){return X.access(a,b,c)},removeData:function(a,b){X.remove(a,b)},_data:function(a,b,c){return W.access(a,b,c)},_removeData:function(a,b){W.remove(a,b)}}),r.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=X.get(f),1===f.nodeType&&!W.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=r.camelCase(d.slice(5)),_(f,d,e[d])));W.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){X.set(this,a)}):T(this,function(b){var c;if(f&&void 0===b){if(c=X.get(f,a),void 0!==c)return c;if(c=_(f,a),void 0!==c)return c}else this.each(function(){X.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){X.remove(this,a)})}}),r.extend({queue:function(a,b,c){var d;if(a)return b=(b||"fx")+"queue",d=W.get(a,b),c&&(!d||Array.isArray(c)?d=W.access(a,b,r.makeArray(c)):d.push(c)),d||[]},dequeue:function(a,b){b=b||"fx";var c=r.queue(a,b),d=c.length,e=c.shift(),f=r._queueHooks(a,b),g=function(){r.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return W.get(a,c)||W.access(a,c,{empty:r.Callbacks("once memory").add(function(){W.remove(a,[b+"queue",c])})})}}),r.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?r.queue(this[0],a):void 0===b?this:this.each(function(){var c=r.queue(this,a,b);r._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&r.dequeue(this,a)})},dequeue:function(a){return this.each(function(){r.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=r.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=W.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var aa=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ba=new RegExp("^(?:([+-])=|)("+aa+")([a-z%]*)$","i"),ca=["Top","Right","Bottom","Left"],da=function(a,b){return a=b||a,"none"===a.style.display||""===a.style.display&&r.contains(a.ownerDocument,a)&&"none"===r.css(a,"display")},ea=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};function fa(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return r.css(a,b,"")},i=h(),j=c&&c[3]||(r.cssNumber[b]?"":"px"),k=(r.cssNumber[b]||"px"!==j&&+i)&&ba.exec(r.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,r.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var ga={};function ha(a){var b,c=a.ownerDocument,d=a.nodeName,e=ga[d];return e?e:(b=c.body.appendChild(c.createElement(d)),e=r.css(b,"display"),b.parentNode.removeChild(b),"none"===e&&(e="block"),ga[d]=e,e)}function ia(a,b){for(var c,d,e=[],f=0,g=a.length;f<g;f++)d=a[f],d.style&&(c=d.style.display,b?("none"===c&&(e[f]=W.get(d,"display")||null,e[f]||(d.style.display="")),""===d.style.display&&da(d)&&(e[f]=ha(d))):"none"!==c&&(e[f]="none",W.set(d,"display",c)));for(f=0;f<g;f++)null!=e[f]&&(a[f].style.display=e[f]);return a}r.fn.extend({show:function(){return ia(this,!0)},hide:function(){return ia(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){da(this)?r(this).show():r(this).hide()})}});var ja=/^(?:checkbox|radio)$/i,ka=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,la=/^$|\/(?:java|ecma)script/i,ma={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ma.optgroup=ma.option,ma.tbody=ma.tfoot=ma.colgroup=ma.caption=ma.thead,ma.th=ma.td;function na(a,b){var c;return c="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):[],void 0===b||b&&B(a,b)?r.merge([a],c):c}function oa(a,b){for(var c=0,d=a.length;c<d;c++)W.set(a[c],"globalEval",!b||W.get(b[c],"globalEval"))}var pa=/<|&#?\w+;/;function qa(a,b,c,d,e){for(var f,g,h,i,j,k,l=b.createDocumentFragment(),m=[],n=0,o=a.length;n<o;n++)if(f=a[n],f||0===f)if("object"===r.type(f))r.merge(m,f.nodeType?[f]:f);else if(pa.test(f)){g=g||l.appendChild(b.createElement("div")),h=(ka.exec(f)||["",""])[1].toLowerCase(),i=ma[h]||ma._default,g.innerHTML=i[1]+r.htmlPrefilter(f)+i[2],k=i[0];while(k--)g=g.lastChild;r.merge(m,g.childNodes),g=l.firstChild,g.textContent=""}else m.push(b.createTextNode(f));l.textContent="",n=0;while(f=m[n++])if(d&&r.inArray(f,d)>-1)e&&e.push(f);else if(j=r.contains(f.ownerDocument,f),g=na(l.appendChild(f),"script"),j&&oa(g),c){k=0;while(f=g[k++])la.test(f.type||"")&&c.push(f)}return l}!function(){var a=d.createDocumentFragment(),b=a.appendChild(d.createElement("div")),c=d.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),o.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",o.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var ra=d.documentElement,sa=/^key/,ta=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,ua=/^([^.]*)(?:\.(.+)|)/;function va(){return!0}function wa(){return!1}function xa(){try{return d.activeElement}catch(a){}}function ya(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)ya(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=wa;else if(!e)return a;return 1===f&&(g=e,e=function(a){return r().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=r.guid++)),a.each(function(){r.event.add(this,b,e,d,c)})}r.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.get(a);if(q){c.handler&&(f=c,c=f.handler,e=f.selector),e&&r.find.matchesSelector(ra,e),c.guid||(c.guid=r.guid++),(i=q.events)||(i=q.events={}),(g=q.handle)||(g=q.handle=function(b){return"undefined"!=typeof r&&r.event.triggered!==b.type?r.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(L)||[""],j=b.length;while(j--)h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n&&(l=r.event.special[n]||{},n=(e?l.delegateType:l.bindType)||n,l=r.event.special[n]||{},k=r.extend({type:n,origType:p,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&r.expr.match.needsContext.test(e),namespace:o.join(".")},f),(m=i[n])||(m=i[n]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,o,g)!==!1||a.addEventListener&&a.addEventListener(n,g)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),r.event.global[n]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.hasData(a)&&W.get(a);if(q&&(i=q.events)){b=(b||"").match(L)||[""],j=b.length;while(j--)if(h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n){l=r.event.special[n]||{},n=(d?l.delegateType:l.bindType)||n,m=i[n]||[],h=h[2]&&new RegExp("(^|\\.)"+o.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&p!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,o,q.handle)!==!1||r.removeEvent(a,n,q.handle),delete i[n])}else for(n in i)r.event.remove(a,n+b[j],c,d,!0);r.isEmptyObject(i)&&W.remove(a,"handle events")}},dispatch:function(a){var b=r.event.fix(a),c,d,e,f,g,h,i=new Array(arguments.length),j=(W.get(this,"events")||{})[b.type]||[],k=r.event.special[b.type]||{};for(i[0]=b,c=1;c<arguments.length;c++)i[c]=arguments[c];if(b.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,b)!==!1){h=r.event.handlers.call(this,b,j),c=0;while((f=h[c++])&&!b.isPropagationStopped()){b.currentTarget=f.elem,d=0;while((g=f.handlers[d++])&&!b.isImmediatePropagationStopped())b.rnamespace&&!b.rnamespace.test(g.namespace)||(b.handleObj=g,b.data=g.data,e=((r.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(b.result=e)===!1&&(b.preventDefault(),b.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,b),b.result}},handlers:function(a,b){var c,d,e,f,g,h=[],i=b.delegateCount,j=a.target;if(i&&j.nodeType&&!("click"===a.type&&a.button>=1))for(;j!==this;j=j.parentNode||this)if(1===j.nodeType&&("click"!==a.type||j.disabled!==!0)){for(f=[],g={},c=0;c<i;c++)d=b[c],e=d.selector+" ",void 0===g[e]&&(g[e]=d.needsContext?r(e,this).index(j)>-1:r.find(e,this,null,[j]).length),g[e]&&f.push(d);f.length&&h.push({elem:j,handlers:f})}return j=this,i<b.length&&h.push({elem:j,handlers:b.slice(i)}),h},addProp:function(a,b){Object.defineProperty(r.Event.prototype,a,{enumerable:!0,configurable:!0,get:r.isFunction(b)?function(){if(this.originalEvent)return b(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[a]},set:function(b){Object.defineProperty(this,a,{enumerable:!0,configurable:!0,writable:!0,value:b})}})},fix:function(a){return a[r.expando]?a:new r.Event(a)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==xa()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===xa()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&B(this,"input"))return this.click(),!1},_default:function(a){return B(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}}},r.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)},r.Event=function(a,b){return this instanceof r.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?va:wa,this.target=a.target&&3===a.target.nodeType?a.target.parentNode:a.target,this.currentTarget=a.currentTarget,this.relatedTarget=a.relatedTarget):this.type=a,b&&r.extend(this,b),this.timeStamp=a&&a.timeStamp||r.now(),void(this[r.expando]=!0)):new r.Event(a,b)},r.Event.prototype={constructor:r.Event,isDefaultPrevented:wa,isPropagationStopped:wa,isImmediatePropagationStopped:wa,isSimulated:!1,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=va,a&&!this.isSimulated&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=va,a&&!this.isSimulated&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=va,a&&!this.isSimulated&&a.stopImmediatePropagation(),this.stopPropagation()}},r.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(a){var b=a.button;return null==a.which&&sa.test(a.type)?null!=a.charCode?a.charCode:a.keyCode:!a.which&&void 0!==b&&ta.test(a.type)?1&b?1:2&b?3:4&b?2:0:a.which}},r.event.addProp),r.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){r.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||r.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),r.fn.extend({on:function(a,b,c,d){return ya(this,a,b,c,d)},one:function(a,b,c,d){return ya(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,r(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&"function"!=typeof b||(c=b,b=void 0),c===!1&&(c=wa),this.each(function(){r.event.remove(this,a,c,b)})}});var za=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,Aa=/<script|<style|<link/i,Ba=/checked\s*(?:[^=]|=\s*.checked.)/i,Ca=/^true\/(.*)/,Da=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Ea(a,b){return B(a,"table")&&B(11!==b.nodeType?b:b.firstChild,"tr")?r(">tbody",a)[0]||a:a}function Fa(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function Ga(a){var b=Ca.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Ha(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(W.hasData(a)&&(f=W.access(a),g=W.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;c<d;c++)r.event.add(b,e,j[e][c])}X.hasData(a)&&(h=X.access(a),i=r.extend({},h),X.set(b,i))}}function Ia(a,b){var c=b.nodeName.toLowerCase();"input"===c&&ja.test(a.type)?b.checked=a.checked:"input"!==c&&"textarea"!==c||(b.defaultValue=a.defaultValue)}function Ja(a,b,c,d){b=g.apply([],b);var e,f,h,i,j,k,l=0,m=a.length,n=m-1,q=b[0],s=r.isFunction(q);if(s||m>1&&"string"==typeof q&&!o.checkClone&&Ba.test(q))return a.each(function(e){var f=a.eq(e);s&&(b[0]=q.call(this,e,f.html())),Ja(f,b,c,d)});if(m&&(e=qa(b,a[0].ownerDocument,!1,a,d),f=e.firstChild,1===e.childNodes.length&&(e=f),f||d)){for(h=r.map(na(e,"script"),Fa),i=h.length;l<m;l++)j=e,l!==n&&(j=r.clone(j,!0,!0),i&&r.merge(h,na(j,"script"))),c.call(a[l],j,l);if(i)for(k=h[h.length-1].ownerDocument,r.map(h,Ga),l=0;l<i;l++)j=h[l],la.test(j.type||"")&&!W.access(j,"globalEval")&&r.contains(k,j)&&(j.src?r._evalUrl&&r._evalUrl(j.src):p(j.textContent.replace(Da,""),k))}return a}function Ka(a,b,c){for(var d,e=b?r.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||r.cleanData(na(d)),d.parentNode&&(c&&r.contains(d.ownerDocument,d)&&oa(na(d,"script")),d.parentNode.removeChild(d));return a}r.extend({htmlPrefilter:function(a){return a.replace(za,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=r.contains(a.ownerDocument,a);if(!(o.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||r.isXMLDoc(a)))for(g=na(h),f=na(a),d=0,e=f.length;d<e;d++)Ia(f[d],g[d]);if(b)if(c)for(f=f||na(a),g=g||na(h),d=0,e=f.length;d<e;d++)Ha(f[d],g[d]);else Ha(a,h);return g=na(h,"script"),g.length>0&&oa(g,!i&&na(a,"script")),h},cleanData:function(a){for(var b,c,d,e=r.event.special,f=0;void 0!==(c=a[f]);f++)if(U(c)){if(b=c[W.expando]){if(b.events)for(d in b.events)e[d]?r.event.remove(c,d):r.removeEvent(c,d,b.handle);c[W.expando]=void 0}c[X.expando]&&(c[X.expando]=void 0)}}}),r.fn.extend({detach:function(a){return Ka(this,a,!0)},remove:function(a){return Ka(this,a)},text:function(a){return T(this,function(a){return void 0===a?r.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=a)})},null,a,arguments.length)},append:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.appendChild(a)}})},prepend:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(r.cleanData(na(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null!=a&&a,b=null==b?a:b,this.map(function(){return r.clone(this,a,b)})},html:function(a){return T(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!Aa.test(a)&&!ma[(ka.exec(a)||["",""])[1].toLowerCase()]){a=r.htmlPrefilter(a);try{for(;c<d;c++)b=this[c]||{},1===b.nodeType&&(r.cleanData(na(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ja(this,arguments,function(b){var c=this.parentNode;r.inArray(this,a)<0&&(r.cleanData(na(this)),c&&c.replaceChild(b,this))},a)}}),r.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){r.fn[a]=function(a){for(var c,d=[],e=r(a),f=e.length-1,g=0;g<=f;g++)c=g===f?this:this.clone(!0),r(e[g])[b](c),h.apply(d,c.get());return this.pushStack(d)}});var La=/^margin/,Ma=new RegExp("^("+aa+")(?!px)[a-z%]+$","i"),Na=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)};!function(){function b(){if(i){i.style.cssText="box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",i.innerHTML="",ra.appendChild(h);var b=a.getComputedStyle(i);c="1%"!==b.top,g="2px"===b.marginLeft,e="4px"===b.width,i.style.marginRight="50%",f="4px"===b.marginRight,ra.removeChild(h),i=null}}var c,e,f,g,h=d.createElement("div"),i=d.createElement("div");i.style&&(i.style.backgroundClip="content-box",i.cloneNode(!0).style.backgroundClip="",o.clearCloneStyle="content-box"===i.style.backgroundClip,h.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",h.appendChild(i),r.extend(o,{pixelPosition:function(){return b(),c},boxSizingReliable:function(){return b(),e},pixelMarginRight:function(){return b(),f},reliableMarginLeft:function(){return b(),g}}))}();function Oa(a,b,c){var d,e,f,g,h=a.style;return c=c||Na(a),c&&(g=c.getPropertyValue(b)||c[b],""!==g||r.contains(a.ownerDocument,a)||(g=r.style(a,b)),!o.pixelMarginRight()&&Ma.test(g)&&La.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function Pa(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Qa=/^(none|table(?!-c[ea]).+)/,Ra=/^--/,Sa={position:"absolute",visibility:"hidden",display:"block"},Ta={letterSpacing:"0",fontWeight:"400"},Ua=["Webkit","Moz","ms"],Va=d.createElement("div").style;function Wa(a){if(a in Va)return a;var b=a[0].toUpperCase()+a.slice(1),c=Ua.length;while(c--)if(a=Ua[c]+b,a in Va)return a}function Xa(a){var b=r.cssProps[a];return b||(b=r.cssProps[a]=Wa(a)||a),b}function Ya(a,b,c){var d=ba.exec(b);return d?Math.max(0,d[2]-(c||0))+(d[3]||"px"):b}function Za(a,b,c,d,e){var f,g=0;for(f=c===(d?"border":"content")?4:"width"===b?1:0;f<4;f+=2)"margin"===c&&(g+=r.css(a,c+ca[f],!0,e)),d?("content"===c&&(g-=r.css(a,"padding"+ca[f],!0,e)),"margin"!==c&&(g-=r.css(a,"border"+ca[f]+"Width",!0,e))):(g+=r.css(a,"padding"+ca[f],!0,e),"padding"!==c&&(g+=r.css(a,"border"+ca[f]+"Width",!0,e)));return g}function $a(a,b,c){var d,e=Na(a),f=Oa(a,b,e),g="border-box"===r.css(a,"boxSizing",!1,e);return Ma.test(f)?f:(d=g&&(o.boxSizingReliable()||f===a.style[b]),"auto"===f&&(f=a["offset"+b[0].toUpperCase()+b.slice(1)]),f=parseFloat(f)||0,f+Za(a,b,c||(g?"border":"content"),d,e)+"px")}r.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Oa(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=r.camelCase(b),i=Ra.test(b),j=a.style;return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:j[b]:(f=typeof c,"string"===f&&(e=ba.exec(c))&&e[1]&&(c=fa(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(r.cssNumber[h]?"":"px")),o.clearCloneStyle||""!==c||0!==b.indexOf("background")||(j[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i?j.setProperty(b,c):j[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=r.camelCase(b),i=Ra.test(b);return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=Oa(a,b,d)),"normal"===e&&b in Ta&&(e=Ta[b]),""===c||c?(f=parseFloat(e),c===!0||isFinite(f)?f||0:e):e}}),r.each(["height","width"],function(a,b){r.cssHooks[b]={get:function(a,c,d){if(c)return!Qa.test(r.css(a,"display"))||a.getClientRects().length&&a.getBoundingClientRect().width?$a(a,b,d):ea(a,Sa,function(){return $a(a,b,d)})},set:function(a,c,d){var e,f=d&&Na(a),g=d&&Za(a,b,d,"border-box"===r.css(a,"boxSizing",!1,f),f);return g&&(e=ba.exec(c))&&"px"!==(e[3]||"px")&&(a.style[b]=c,c=r.css(a,b)),Ya(a,c,g)}}}),r.cssHooks.marginLeft=Pa(o.reliableMarginLeft,function(a,b){if(b)return(parseFloat(Oa(a,"marginLeft"))||a.getBoundingClientRect().left-ea(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}))+"px"}),r.each({margin:"",padding:"",border:"Width"},function(a,b){r.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];d<4;d++)e[a+ca[d]+b]=f[d]||f[d-2]||f[0];return e}},La.test(a)||(r.cssHooks[a+b].set=Ya)}),r.fn.extend({css:function(a,b){return T(this,function(a,b,c){var d,e,f={},g=0;if(Array.isArray(b)){for(d=Na(a),e=b.length;g<e;g++)f[b[g]]=r.css(a,b[g],!1,d);return f}return void 0!==c?r.style(a,b,c):r.css(a,b)},a,b,arguments.length>1)}});function _a(a,b,c,d,e){return new _a.prototype.init(a,b,c,d,e)}r.Tween=_a,_a.prototype={constructor:_a,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||r.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(r.cssNumber[c]?"":"px")},cur:function(){var a=_a.propHooks[this.prop];return a&&a.get?a.get(this):_a.propHooks._default.get(this)},run:function(a){var b,c=_a.propHooks[this.prop];return this.options.duration?this.pos=b=r.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):_a.propHooks._default.set(this),this}},_a.prototype.init.prototype=_a.prototype,_a.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=r.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){r.fx.step[a.prop]?r.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[r.cssProps[a.prop]]&&!r.cssHooks[a.prop]?a.elem[a.prop]=a.now:r.style(a.elem,a.prop,a.now+a.unit)}}},_a.propHooks.scrollTop=_a.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},r.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},r.fx=_a.prototype.init,r.fx.step={};var ab,bb,cb=/^(?:toggle|show|hide)$/,db=/queueHooks$/;function eb(){bb&&(d.hidden===!1&&a.requestAnimationFrame?a.requestAnimationFrame(eb):a.setTimeout(eb,r.fx.interval),r.fx.tick())}function fb(){return a.setTimeout(function(){ab=void 0}),ab=r.now()}function gb(a,b){var c,d=0,e={height:a};for(b=b?1:0;d<4;d+=2-b)c=ca[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function hb(a,b,c){for(var d,e=(kb.tweeners[b]||[]).concat(kb.tweeners["*"]),f=0,g=e.length;f<g;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,k,l="width"in b||"height"in b,m=this,n={},o=a.style,p=a.nodeType&&da(a),q=W.get(a,"fxshow");c.queue||(g=r._queueHooks(a,"fx"),null==g.unqueued&&(g.unqueued=0,h=g.empty.fire,g.empty.fire=function(){g.unqueued||h()}),g.unqueued++,m.always(function(){m.always(function(){g.unqueued--,r.queue(a,"fx").length||g.empty.fire()})}));for(d in b)if(e=b[d],cb.test(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}n[d]=q&&q[d]||r.style(a,d)}if(i=!r.isEmptyObject(b),i||!r.isEmptyObject(n)){l&&1===a.nodeType&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=q&&q.display,null==j&&(j=W.get(a,"display")),k=r.css(a,"display"),"none"===k&&(j?k=j:(ia([a],!0),j=a.style.display||j,k=r.css(a,"display"),ia([a]))),("inline"===k||"inline-block"===k&&null!=j)&&"none"===r.css(a,"float")&&(i||(m.done(function(){o.display=j}),null==j&&(k=o.display,j="none"===k?"":k)),o.display="inline-block")),c.overflow&&(o.overflow="hidden",m.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]})),i=!1;for(d in n)i||(q?"hidden"in q&&(p=q.hidden):q=W.access(a,"fxshow",{display:j}),f&&(q.hidden=!p),p&&ia([a],!0),m.done(function(){p||ia([a]),W.remove(a,"fxshow");for(d in n)r.style(a,d,n[d])})),i=hb(p?q[d]:0,d,m),d in q||(q[d]=i.start,p&&(i.end=i.start,i.start=0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=r.camelCase(c),e=b[d],f=a[c],Array.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=r.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=kb.prefilters.length,h=r.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=ab||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;g<i;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),f<1&&i?c:(i||h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:r.extend({},b),opts:r.extend(!0,{specialEasing:{},easing:r.easing._default},c),originalProperties:b,originalOptions:c,startTime:ab||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=r.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;c<d;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);f<g;f++)if(d=kb.prefilters[f].call(j,a,k,j.opts))return r.isFunction(d.stop)&&(r._queueHooks(j.elem,j.opts.queue).stop=r.proxy(d.stop,d)),d;return r.map(k,hb,j),r.isFunction(j.opts.start)&&j.opts.start.call(a,j),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always),r.fx.timer(r.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j}r.Animation=r.extend(kb,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return fa(c.elem,a,ba.exec(b),c),c}]},tweener:function(a,b){r.isFunction(a)?(b=a,a=["*"]):a=a.match(L);for(var c,d=0,e=a.length;d<e;d++)c=a[d],kb.tweeners[c]=kb.tweeners[c]||[],kb.tweeners[c].unshift(b)},prefilters:[ib],prefilter:function(a,b){b?kb.prefilters.unshift(a):kb.prefilters.push(a)}}),r.speed=function(a,b,c){var d=a&&"object"==typeof a?r.extend({},a):{complete:c||!c&&b||r.isFunction(a)&&a,duration:a,easing:c&&b||b&&!r.isFunction(b)&&b};return r.fx.off?d.duration=0:"number"!=typeof d.duration&&(d.duration in r.fx.speeds?d.duration=r.fx.speeds[d.duration]:d.duration=r.fx.speeds._default),null!=d.queue&&d.queue!==!0||(d.queue="fx"),d.old=d.complete,d.complete=function(){r.isFunction(d.old)&&d.old.call(this),d.queue&&r.dequeue(this,d.queue)},d},r.fn.extend({fadeTo:function(a,b,c,d){return this.filter(da).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=r.isEmptyObject(a),f=r.speed(b,c,d),g=function(){var b=kb(this,r.extend({},a),f);(e||W.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=r.timers,g=W.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&db.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||r.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=W.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=r.timers,g=d?d.length:0;for(c.finish=!0,r.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;b<g;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),r.each(["toggle","show","hide"],function(a,b){var c=r.fn[b];r.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),r.each({slideDown:gb("show"),slideUp:gb("hide"),slideToggle:gb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){r.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),r.timers=[],r.fx.tick=function(){var a,b=0,c=r.timers;for(ab=r.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||r.fx.stop(),ab=void 0},r.fx.timer=function(a){r.timers.push(a),r.fx.start()},r.fx.interval=13,r.fx.start=function(){bb||(bb=!0,eb())},r.fx.stop=function(){bb=null},r.fx.speeds={slow:600,fast:200,_default:400},r.fn.delay=function(b,c){return b=r.fx?r.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a=d.createElement("input"),b=d.createElement("select"),c=b.appendChild(d.createElement("option"));a.type="checkbox",o.checkOn=""!==a.value,o.optSelected=c.selected,a=d.createElement("input"),a.value="t",a.type="radio",o.radioValue="t"===a.value}();var lb,mb=r.expr.attrHandle;r.fn.extend({attr:function(a,b){return T(this,r.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){r.removeAttr(this,a)})}}),r.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?r.prop(a,b,c):(1===f&&r.isXMLDoc(a)||(e=r.attrHooks[b.toLowerCase()]||(r.expr.match.bool.test(b)?lb:void 0)),void 0!==c?null===c?void r.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=r.find.attr(a,b),
   null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!o.radioValue&&"radio"===b&&B(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d=0,e=b&&b.match(L);if(e&&1===a.nodeType)while(c=e[d++])a.removeAttribute(c)}}),lb={set:function(a,b,c){return b===!1?r.removeAttr(a,c):a.setAttribute(c,c),c}},r.each(r.expr.match.bool.source.match(/\w+/g),function(a,b){var c=mb[b]||r.find.attr;mb[b]=function(a,b,d){var e,f,g=b.toLowerCase();return d||(f=mb[g],mb[g]=e,e=null!=c(a,b,d)?g:null,mb[g]=f),e}});var nb=/^(?:input|select|textarea|button)$/i,ob=/^(?:a|area)$/i;r.fn.extend({prop:function(a,b){return T(this,r.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[r.propFix[a]||a]})}}),r.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&r.isXMLDoc(a)||(b=r.propFix[b]||b,e=r.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=r.find.attr(a,"tabindex");return b?parseInt(b,10):nb.test(a.nodeName)||ob.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),o.optSelected||(r.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),r.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){r.propFix[this.toLowerCase()]=this});function pb(a){var b=a.match(L)||[];return b.join(" ")}function qb(a){return a.getAttribute&&a.getAttribute("class")||""}r.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).addClass(a.call(this,b,qb(this)))});if("string"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&" "+pb(e)+" "){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=pb(d),e!==h&&c.setAttribute("class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).removeClass(a.call(this,b,qb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&" "+pb(e)+" "){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=pb(d),e!==h&&c.setAttribute("class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):r.isFunction(a)?this.each(function(c){r(this).toggleClass(a.call(this,c,qb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=r(this),f=a.match(L)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&"boolean"!==c||(b=qb(this),b&&W.set(this,"__className__",b),this.setAttribute&&this.setAttribute("class",b||a===!1?"":W.get(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+pb(qb(c))+" ").indexOf(b)>-1)return!0;return!1}});var rb=/\r/g;r.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=r.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,r(this).val()):a,null==e?e="":"number"==typeof e?e+="":Array.isArray(e)&&(e=r.map(e,function(a){return null==a?"":a+""})),b=r.valHooks[this.type]||r.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=r.valHooks[e.type]||r.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(rb,""):null==c?"":c)}}}),r.extend({valHooks:{option:{get:function(a){var b=r.find.attr(a,"value");return null!=b?b:pb(r.text(a))}},select:{get:function(a){var b,c,d,e=a.options,f=a.selectedIndex,g="select-one"===a.type,h=g?null:[],i=g?f+1:e.length;for(d=f<0?i:g?f:0;d<i;d++)if(c=e[d],(c.selected||d===f)&&!c.disabled&&(!c.parentNode.disabled||!B(c.parentNode,"optgroup"))){if(b=r(c).val(),g)return b;h.push(b)}return h},set:function(a,b){var c,d,e=a.options,f=r.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=r.inArray(r.valHooks.option.get(d),f)>-1)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),r.each(["radio","checkbox"],function(){r.valHooks[this]={set:function(a,b){if(Array.isArray(b))return a.checked=r.inArray(r(a).val(),b)>-1}},o.checkOn||(r.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var sb=/^(?:focusinfocus|focusoutblur)$/;r.extend(r.event,{trigger:function(b,c,e,f){var g,h,i,j,k,m,n,o=[e||d],p=l.call(b,"type")?b.type:b,q=l.call(b,"namespace")?b.namespace.split("."):[];if(h=i=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!sb.test(p+r.event.triggered)&&(p.indexOf(".")>-1&&(q=p.split("."),p=q.shift(),q.sort()),k=p.indexOf(":")<0&&"on"+p,b=b[r.expando]?b:new r.Event(p,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=q.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:r.makeArray(c,[b]),n=r.event.special[p]||{},f||!n.trigger||n.trigger.apply(e,c)!==!1)){if(!f&&!n.noBubble&&!r.isWindow(e)){for(j=n.delegateType||p,sb.test(j+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),i=h;i===(e.ownerDocument||d)&&o.push(i.defaultView||i.parentWindow||a)}g=0;while((h=o[g++])&&!b.isPropagationStopped())b.type=g>1?j:n.bindType||p,m=(W.get(h,"events")||{})[b.type]&&W.get(h,"handle"),m&&m.apply(h,c),m=k&&h[k],m&&m.apply&&U(h)&&(b.result=m.apply(h,c),b.result===!1&&b.preventDefault());return b.type=p,f||b.isDefaultPrevented()||n._default&&n._default.apply(o.pop(),c)!==!1||!U(e)||k&&r.isFunction(e[p])&&!r.isWindow(e)&&(i=e[k],i&&(e[k]=null),r.event.triggered=p,e[p](),r.event.triggered=void 0,i&&(e[k]=i)),b.result}},simulate:function(a,b,c){var d=r.extend(new r.Event,c,{type:a,isSimulated:!0});r.event.trigger(d,null,b)}}),r.fn.extend({trigger:function(a,b){return this.each(function(){r.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];if(c)return r.event.trigger(a,b,c,!0)}}),r.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(a,b){r.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),r.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),o.focusin="onfocusin"in a,o.focusin||r.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){r.event.simulate(b,a.target,r.event.fix(a))};r.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=W.access(d,b);e||d.addEventListener(a,c,!0),W.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=W.access(d,b)-1;e?W.access(d,b,e):(d.removeEventListener(a,c,!0),W.remove(d,b))}}});var tb=a.location,ub=r.now(),vb=/\?/;r.parseXML=function(b){var c;if(!b||"string"!=typeof b)return null;try{c=(new a.DOMParser).parseFromString(b,"text/xml")}catch(d){c=void 0}return c&&!c.getElementsByTagName("parsererror").length||r.error("Invalid XML: "+b),c};var wb=/\[\]$/,xb=/\r?\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(Array.isArray(b))r.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==r.type(b))d(a,b);else for(e in b)Ab(a+"["+e+"]",b[e],c,d)}r.param=function(a,b){var c,d=[],e=function(a,b){var c=r.isFunction(b)?b():b;d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(null==c?"":c)};if(Array.isArray(a)||a.jquery&&!r.isPlainObject(a))r.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join("&")},r.fn.extend({serialize:function(){return r.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=r.prop(this,"elements");return a?r.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!r(this).is(":disabled")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!ja.test(a))}).map(function(a,b){var c=r(this).val();return null==c?null:Array.isArray(c)?r.map(c,function(a){return{name:b.name,value:a.replace(xb,"\r\n")}}):{name:b.name,value:c.replace(xb,"\r\n")}}).get()}});var Bb=/%20/g,Cb=/#.*$/,Db=/([?&])_=[^&]*/,Eb=/^(.*?):[ \t]*([^\r\n]*)$/gm,Fb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Gb=/^(?:GET|HEAD)$/,Hb=/^\/\//,Ib={},Jb={},Kb="*/".concat("*"),Lb=d.createElement("a");Lb.href=tb.href;function Mb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(L)||[];if(r.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Nb(a,b,c,d){var e={},f=a===Jb;function g(h){var i;return e[h]=!0,r.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Ob(a,b){var c,d,e=r.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&r.extend(!0,a,d),a}function Pb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}if(f)return f!==i[0]&&i.unshift(f),c[f]}function Qb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}r.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:tb.href,type:"GET",isLocal:Fb.test(tb.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Kb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":r.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Ob(Ob(a,r.ajaxSettings),b):Ob(r.ajaxSettings,a)},ajaxPrefilter:Mb(Ib),ajaxTransport:Mb(Jb),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var e,f,g,h,i,j,k,l,m,n,o=r.ajaxSetup({},c),p=o.context||o,q=o.context&&(p.nodeType||p.jquery)?r(p):r.event,s=r.Deferred(),t=r.Callbacks("once memory"),u=o.statusCode||{},v={},w={},x="canceled",y={readyState:0,getResponseHeader:function(a){var b;if(k){if(!h){h={};while(b=Eb.exec(g))h[b[1].toLowerCase()]=b[2]}b=h[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return k?g:null},setRequestHeader:function(a,b){return null==k&&(a=w[a.toLowerCase()]=w[a.toLowerCase()]||a,v[a]=b),this},overrideMimeType:function(a){return null==k&&(o.mimeType=a),this},statusCode:function(a){var b;if(a)if(k)y.always(a[y.status]);else for(b in a)u[b]=[u[b],a[b]];return this},abort:function(a){var b=a||x;return e&&e.abort(b),A(0,b),this}};if(s.promise(y),o.url=((b||o.url||tb.href)+"").replace(Hb,tb.protocol+"//"),o.type=c.method||c.type||o.method||o.type,o.dataTypes=(o.dataType||"*").toLowerCase().match(L)||[""],null==o.crossDomain){j=d.createElement("a");try{j.href=o.url,j.href=j.href,o.crossDomain=Lb.protocol+"//"+Lb.host!=j.protocol+"//"+j.host}catch(z){o.crossDomain=!0}}if(o.data&&o.processData&&"string"!=typeof o.data&&(o.data=r.param(o.data,o.traditional)),Nb(Ib,o,c,y),k)return y;l=r.event&&o.global,l&&0===r.active++&&r.event.trigger("ajaxStart"),o.type=o.type.toUpperCase(),o.hasContent=!Gb.test(o.type),f=o.url.replace(Cb,""),o.hasContent?o.data&&o.processData&&0===(o.contentType||"").indexOf("application/x-www-form-urlencoded")&&(o.data=o.data.replace(Bb,"+")):(n=o.url.slice(f.length),o.data&&(f+=(vb.test(f)?"&":"?")+o.data,delete o.data),o.cache===!1&&(f=f.replace(Db,"$1"),n=(vb.test(f)?"&":"?")+"_="+ub++ +n),o.url=f+n),o.ifModified&&(r.lastModified[f]&&y.setRequestHeader("If-Modified-Since",r.lastModified[f]),r.etag[f]&&y.setRequestHeader("If-None-Match",r.etag[f])),(o.data&&o.hasContent&&o.contentType!==!1||c.contentType)&&y.setRequestHeader("Content-Type",o.contentType),y.setRequestHeader("Accept",o.dataTypes[0]&&o.accepts[o.dataTypes[0]]?o.accepts[o.dataTypes[0]]+("*"!==o.dataTypes[0]?", "+Kb+"; q=0.01":""):o.accepts["*"]);for(m in o.headers)y.setRequestHeader(m,o.headers[m]);if(o.beforeSend&&(o.beforeSend.call(p,y,o)===!1||k))return y.abort();if(x="abort",t.add(o.complete),y.done(o.success),y.fail(o.error),e=Nb(Jb,o,c,y)){if(y.readyState=1,l&&q.trigger("ajaxSend",[y,o]),k)return y;o.async&&o.timeout>0&&(i=a.setTimeout(function(){y.abort("timeout")},o.timeout));try{k=!1,e.send(v,A)}catch(z){if(k)throw z;A(-1,z)}}else A(-1,"No Transport");function A(b,c,d,h){var j,m,n,v,w,x=c;k||(k=!0,i&&a.clearTimeout(i),e=void 0,g=h||"",y.readyState=b>0?4:0,j=b>=200&&b<300||304===b,d&&(v=Pb(o,y,d)),v=Qb(o,v,y,j),j?(o.ifModified&&(w=y.getResponseHeader("Last-Modified"),w&&(r.lastModified[f]=w),w=y.getResponseHeader("etag"),w&&(r.etag[f]=w)),204===b||"HEAD"===o.type?x="nocontent":304===b?x="notmodified":(x=v.state,m=v.data,n=v.error,j=!n)):(n=x,!b&&x||(x="error",b<0&&(b=0))),y.status=b,y.statusText=(c||x)+"",j?s.resolveWith(p,[m,x,y]):s.rejectWith(p,[y,x,n]),y.statusCode(u),u=void 0,l&&q.trigger(j?"ajaxSuccess":"ajaxError",[y,o,j?m:n]),t.fireWith(p,[y,x]),l&&(q.trigger("ajaxComplete",[y,o]),--r.active||r.event.trigger("ajaxStop")))}return y},getJSON:function(a,b,c){return r.get(a,b,c,"json")},getScript:function(a,b){return r.get(a,void 0,b,"script")}}),r.each(["get","post"],function(a,b){r[b]=function(a,c,d,e){return r.isFunction(c)&&(e=e||d,d=c,c=void 0),r.ajax(r.extend({url:a,type:b,dataType:e,data:c,success:d},r.isPlainObject(a)&&a))}}),r._evalUrl=function(a){return r.ajax({url:a,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},r.fn.extend({wrapAll:function(a){var b;return this[0]&&(r.isFunction(a)&&(a=a.call(this[0])),b=r(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this},wrapInner:function(a){return r.isFunction(a)?this.each(function(b){r(this).wrapInner(a.call(this,b))}):this.each(function(){var b=r(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=r.isFunction(a);return this.each(function(c){r(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(a){return this.parent(a).not("body").each(function(){r(this).replaceWith(this.childNodes)}),this}}),r.expr.pseudos.hidden=function(a){return!r.expr.pseudos.visible(a)},r.expr.pseudos.visible=function(a){return!!(a.offsetWidth||a.offsetHeight||a.getClientRects().length)},r.ajaxSettings.xhr=function(){try{return new a.XMLHttpRequest}catch(b){}};var Rb={0:200,1223:204},Sb=r.ajaxSettings.xhr();o.cors=!!Sb&&"withCredentials"in Sb,o.ajax=Sb=!!Sb,r.ajaxTransport(function(b){var c,d;if(o.cors||Sb&&!b.crossDomain)return{send:function(e,f){var g,h=b.xhr();if(h.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(g in b.xhrFields)h[g]=b.xhrFields[g];b.mimeType&&h.overrideMimeType&&h.overrideMimeType(b.mimeType),b.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest");for(g in e)h.setRequestHeader(g,e[g]);c=function(a){return function(){c&&(c=d=h.onload=h.onerror=h.onabort=h.onreadystatechange=null,"abort"===a?h.abort():"error"===a?"number"!=typeof h.status?f(0,"error"):f(h.status,h.statusText):f(Rb[h.status]||h.status,h.statusText,"text"!==(h.responseType||"text")||"string"!=typeof h.responseText?{binary:h.response}:{text:h.responseText},h.getAllResponseHeaders()))}},h.onload=c(),d=h.onerror=c("error"),void 0!==h.onabort?h.onabort=d:h.onreadystatechange=function(){4===h.readyState&&a.setTimeout(function(){c&&d()})},c=c("abort");try{h.send(b.hasContent&&b.data||null)}catch(i){if(c)throw i}},abort:function(){c&&c()}}}),r.ajaxPrefilter(function(a){a.crossDomain&&(a.contents.script=!1)}),r.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(a){return r.globalEval(a),a}}}),r.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),r.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(e,f){b=r("<script>").prop({charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&f("error"===a.type?404:200,a.type)}),d.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Tb=[],Ub=/(=)\?(?=&|$)|\?\?/;r.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Tb.pop()||r.expando+"_"+ub++;return this[a]=!0,a}}),r.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Ub.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Ub.test(b.data)&&"data");if(h||"jsonp"===b.dataTypes[0])return e=b.jsonpCallback=r.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Ub,"$1"+e):b.jsonp!==!1&&(b.url+=(vb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||r.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?r(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Tb.push(e)),g&&r.isFunction(f)&&f(g[0]),g=f=void 0}),"script"}),o.createHTMLDocument=function(){var a=d.implementation.createHTMLDocument("").body;return a.innerHTML="<form></form><form></form>",2===a.childNodes.length}(),r.parseHTML=function(a,b,c){if("string"!=typeof a)return[];"boolean"==typeof b&&(c=b,b=!1);var e,f,g;return b||(o.createHTMLDocument?(b=d.implementation.createHTMLDocument(""),e=b.createElement("base"),e.href=d.location.href,b.head.appendChild(e)):b=d),f=C.exec(a),g=!c&&[],f?[b.createElement(f[1])]:(f=qa([a],b,g),g&&g.length&&r(g).remove(),r.merge([],f.childNodes))},r.fn.load=function(a,b,c){var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=pb(a.slice(h)),a=a.slice(0,h)),r.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&r.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?r("<div>").append(r.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},r.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){r.fn[b]=function(a){return this.on(b,a)}}),r.expr.pseudos.animated=function(a){return r.grep(r.timers,function(b){return a===b.elem}).length},r.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=r.css(a,"position"),l=r(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=r.css(a,"top"),i=r.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),r.isFunction(b)&&(b=b.call(a,c,r.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},r.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){r.offset.setOffset(this,a,b)});var b,c,d,e,f=this[0];if(f)return f.getClientRects().length?(d=f.getBoundingClientRect(),b=f.ownerDocument,c=b.documentElement,e=b.defaultView,{top:d.top+e.pageYOffset-c.clientTop,left:d.left+e.pageXOffset-c.clientLeft}):{top:0,left:0}},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===r.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),B(a[0],"html")||(d=a.offset()),d={top:d.top+r.css(a[0],"borderTopWidth",!0),left:d.left+r.css(a[0],"borderLeftWidth",!0)}),{top:b.top-d.top-r.css(c,"marginTop",!0),left:b.left-d.left-r.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&"static"===r.css(a,"position"))a=a.offsetParent;return a||ra})}}),r.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c="pageYOffset"===b;r.fn[a]=function(d){return T(this,function(a,d,e){var f;return r.isWindow(a)?f=a:9===a.nodeType&&(f=a.defaultView),void 0===e?f?f[b]:a[d]:void(f?f.scrollTo(c?f.pageXOffset:e,c?e:f.pageYOffset):a[d]=e)},a,d,arguments.length)}}),r.each(["top","left"],function(a,b){r.cssHooks[b]=Pa(o.pixelPosition,function(a,c){if(c)return c=Oa(a,b),Ma.test(c)?r(a).position()[b]+"px":c})}),r.each({Height:"height",Width:"width"},function(a,b){r.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){r.fn[d]=function(e,f){var g=arguments.length&&(c||"boolean"!=typeof e),h=c||(e===!0||f===!0?"margin":"border");return T(this,function(b,c,e){var f;return r.isWindow(b)?0===d.indexOf("outer")?b["inner"+a]:b.document.documentElement["client"+a]:9===b.nodeType?(f=b.documentElement,Math.max(b.body["scroll"+a],f["scroll"+a],b.body["offset"+a],f["offset"+a],f["client"+a])):void 0===e?r.css(b,c,h):r.style(b,c,e,h)},b,g?e:void 0,g)}})}),r.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}}),r.holdReady=function(a){a?r.readyWait++:r.ready(!0)},r.isArray=Array.isArray,r.parseJSON=JSON.parse,r.nodeName=B,"function"==typeof define&&define.amd&&define("jquery",[],function(){return r});var Vb=a.jQuery,Wb=a.$;return r.noConflict=function(b){return a.$===r&&(a.$=Wb),b&&a.jQuery===r&&(a.jQuery=Vb),r},b||(a.jQuery=a.$=r),r});

   },{}],"bootstrap-datepicker":[function(require,module,exports){
   /*!
    * Datepicker for Bootstrap v1.7.1 (https://github.com/uxsolutions/bootstrap-datepicker)
    *
    * Licensed under the Apache License v2.0 (http://www.apache.org/licenses/LICENSE-2.0)
    */

   (function(factory){
       if (typeof define === "function" && define.amd) {
           define(["jquery"], factory);
       } else if (typeof exports === 'object') {
           factory(require('jquery'));
       } else {
           factory(jQuery);
       }
   }(function($, undefined){
   	function UTCDate(){
   		return new Date(Date.UTC.apply(Date, arguments));
   	}
   	function UTCToday(){
   		var today = new Date();
   		return UTCDate(today.getFullYear(), today.getMonth(), today.getDate());
   	}
   	function isUTCEquals(date1, date2) {
   		return (
   			date1.getUTCFullYear() === date2.getUTCFullYear() &&
   			date1.getUTCMonth() === date2.getUTCMonth() &&
   			date1.getUTCDate() === date2.getUTCDate()
   		);
   	}
   	function alias(method, deprecationMsg){
   		return function(){
   			if (deprecationMsg !== undefined) {
   				$.fn.datepicker.deprecated(deprecationMsg);
   			}

   			return this[method].apply(this, arguments);
   		};
   	}
   	function isValidDate(d) {
   		return d && !isNaN(d.getTime());
   	}

   	var DateArray = (function(){
   		var extras = {
   			get: function(i){
   				return this.slice(i)[0];
   			},
   			contains: function(d){
   				// Array.indexOf is not cross-browser;
   				// $.inArray doesn't work with Dates
   				var val = d && d.valueOf();
   				for (var i=0, l=this.length; i < l; i++)
             // Use date arithmetic to allow dates with different times to match
             if (0 <= this[i].valueOf() - val && this[i].valueOf() - val < 1000*60*60*24)
   						return i;
   				return -1;
   			},
   			remove: function(i){
   				this.splice(i,1);
   			},
   			replace: function(new_array){
   				if (!new_array)
   					return;
   				if (!$.isArray(new_array))
   					new_array = [new_array];
   				this.clear();
   				this.push.apply(this, new_array);
   			},
   			clear: function(){
   				this.length = 0;
   			},
   			copy: function(){
   				var a = new DateArray();
   				a.replace(this);
   				return a;
   			}
   		};

   		return function(){
   			var a = [];
   			a.push.apply(a, arguments);
   			$.extend(a, extras);
   			return a;
   		};
   	})();


   	// Picker object

   	var Datepicker = function(element, options){
   		$.data(element, 'datepicker', this);
   		this._process_options(options);

   		this.dates = new DateArray();
   		this.viewDate = this.o.defaultViewDate;
   		this.focusDate = null;

   		this.element = $(element);
   		this.isInput = this.element.is('input');
   		this.inputField = this.isInput ? this.element : this.element.find('input');
   		this.component = this.element.hasClass('date') ? this.element.find('.add-on, .input-group-addon, .btn') : false;
   		if (this.component && this.component.length === 0)
   			this.component = false;
   		this.isInline = !this.component && this.element.is('div');

   		this.picker = $(DPGlobal.template);

   		// Checking templates and inserting
   		if (this._check_template(this.o.templates.leftArrow)) {
   			this.picker.find('.prev').html(this.o.templates.leftArrow);
   		}

   		if (this._check_template(this.o.templates.rightArrow)) {
   			this.picker.find('.next').html(this.o.templates.rightArrow);
   		}

   		this._buildEvents();
   		this._attachEvents();

   		if (this.isInline){
   			this.picker.addClass('datepicker-inline').appendTo(this.element);
   		}
   		else {
   			this.picker.addClass('datepicker-dropdown dropdown-menu');
   		}

   		if (this.o.rtl){
   			this.picker.addClass('datepicker-rtl');
   		}

   		if (this.o.calendarWeeks) {
   			this.picker.find('.datepicker-days .datepicker-switch, thead .datepicker-title, tfoot .today, tfoot .clear')
   				.attr('colspan', function(i, val){
   					return Number(val) + 1;
   				});
   		}

   		this._process_options({
   			startDate: this._o.startDate,
   			endDate: this._o.endDate,
   			daysOfWeekDisabled: this.o.daysOfWeekDisabled,
   			daysOfWeekHighlighted: this.o.daysOfWeekHighlighted,
   			datesDisabled: this.o.datesDisabled
   		});

   		this._allow_update = false;
   		this.setViewMode(this.o.startView);
   		this._allow_update = true;

   		this.fillDow();
   		this.fillMonths();

   		this.update();

   		if (this.isInline){
   			this.show();
   		}
   	};

   	Datepicker.prototype = {
   		constructor: Datepicker,

   		_resolveViewName: function(view){
   			$.each(DPGlobal.viewModes, function(i, viewMode){
   				if (view === i || $.inArray(view, viewMode.names) !== -1){
   					view = i;
   					return false;
   				}
   			});

   			return view;
   		},

   		_resolveDaysOfWeek: function(daysOfWeek){
   			if (!$.isArray(daysOfWeek))
   				daysOfWeek = daysOfWeek.split(/[,\s]*/);
   			return $.map(daysOfWeek, Number);
   		},

   		_check_template: function(tmp){
   			try {
   				// If empty
   				if (tmp === undefined || tmp === "") {
   					return false;
   				}
   				// If no html, everything ok
   				if ((tmp.match(/[<>]/g) || []).length <= 0) {
   					return true;
   				}
   				// Checking if html is fine
   				var jDom = $(tmp);
   				return jDom.length > 0;
   			}
   			catch (ex) {
   				return false;
   			}
   		},

   		_process_options: function(opts){
   			// Store raw options for reference
   			this._o = $.extend({}, this._o, opts);
   			// Processed options
   			var o = this.o = $.extend({}, this._o);

   			// Check if "de-DE" style date is available, if not language should
   			// fallback to 2 letter code eg "de"
   			var lang = o.language;
   			if (!dates[lang]){
   				lang = lang.split('-')[0];
   				if (!dates[lang])
   					lang = defaults.language;
   			}
   			o.language = lang;

   			// Retrieve view index from any aliases
   			o.startView = this._resolveViewName(o.startView);
   			o.minViewMode = this._resolveViewName(o.minViewMode);
   			o.maxViewMode = this._resolveViewName(o.maxViewMode);

   			// Check view is between min and max
   			o.startView = Math.max(this.o.minViewMode, Math.min(this.o.maxViewMode, o.startView));

   			// true, false, or Number > 0
   			if (o.multidate !== true){
   				o.multidate = Number(o.multidate) || false;
   				if (o.multidate !== false)
   					o.multidate = Math.max(0, o.multidate);
   			}
   			o.multidateSeparator = String(o.multidateSeparator);

   			o.weekStart %= 7;
   			o.weekEnd = (o.weekStart + 6) % 7;

   			var format = DPGlobal.parseFormat(o.format);
   			if (o.startDate !== -Infinity){
   				if (!!o.startDate){
   					if (o.startDate instanceof Date)
   						o.startDate = this._local_to_utc(this._zero_time(o.startDate));
   					else
   						o.startDate = DPGlobal.parseDate(o.startDate, format, o.language, o.assumeNearbyYear);
   				}
   				else {
   					o.startDate = -Infinity;
   				}
   			}
   			if (o.endDate !== Infinity){
   				if (!!o.endDate){
   					if (o.endDate instanceof Date)
   						o.endDate = this._local_to_utc(this._zero_time(o.endDate));
   					else
   						o.endDate = DPGlobal.parseDate(o.endDate, format, o.language, o.assumeNearbyYear);
   				}
   				else {
   					o.endDate = Infinity;
   				}
   			}

   			o.daysOfWeekDisabled = this._resolveDaysOfWeek(o.daysOfWeekDisabled||[]);
   			o.daysOfWeekHighlighted = this._resolveDaysOfWeek(o.daysOfWeekHighlighted||[]);

   			o.datesDisabled = o.datesDisabled||[];
   			if (!$.isArray(o.datesDisabled)) {
   				o.datesDisabled = o.datesDisabled.split(',');
   			}
   			o.datesDisabled = $.map(o.datesDisabled, function(d){
   				return DPGlobal.parseDate(d, format, o.language, o.assumeNearbyYear);
   			});

   			var plc = String(o.orientation).toLowerCase().split(/\s+/g),
   				_plc = o.orientation.toLowerCase();
   			plc = $.grep(plc, function(word){
   				return /^auto|left|right|top|bottom$/.test(word);
   			});
   			o.orientation = {x: 'auto', y: 'auto'};
   			if (!_plc || _plc === 'auto')
   				; // no action
   			else if (plc.length === 1){
   				switch (plc[0]){
   					case 'top':
   					case 'bottom':
   						o.orientation.y = plc[0];
   						break;
   					case 'left':
   					case 'right':
   						o.orientation.x = plc[0];
   						break;
   				}
   			}
   			else {
   				_plc = $.grep(plc, function(word){
   					return /^left|right$/.test(word);
   				});
   				o.orientation.x = _plc[0] || 'auto';

   				_plc = $.grep(plc, function(word){
   					return /^top|bottom$/.test(word);
   				});
   				o.orientation.y = _plc[0] || 'auto';
   			}
   			if (o.defaultViewDate instanceof Date || typeof o.defaultViewDate === 'string') {
   				o.defaultViewDate = DPGlobal.parseDate(o.defaultViewDate, format, o.language, o.assumeNearbyYear);
   			} else if (o.defaultViewDate) {
   				var year = o.defaultViewDate.year || new Date().getFullYear();
   				var month = o.defaultViewDate.month || 0;
   				var day = o.defaultViewDate.day || 1;
   				o.defaultViewDate = UTCDate(year, month, day);
   			} else {
   				o.defaultViewDate = UTCToday();
   			}
   		},
   		_events: [],
   		_secondaryEvents: [],
   		_applyEvents: function(evs){
   			for (var i=0, el, ch, ev; i < evs.length; i++){
   				el = evs[i][0];
   				if (evs[i].length === 2){
   					ch = undefined;
   					ev = evs[i][1];
   				} else if (evs[i].length === 3){
   					ch = evs[i][1];
   					ev = evs[i][2];
   				}
   				el.on(ev, ch);
   			}
   		},
   		_unapplyEvents: function(evs){
   			for (var i=0, el, ev, ch; i < evs.length; i++){
   				el = evs[i][0];
   				if (evs[i].length === 2){
   					ch = undefined;
   					ev = evs[i][1];
   				} else if (evs[i].length === 3){
   					ch = evs[i][1];
   					ev = evs[i][2];
   				}
   				el.off(ev, ch);
   			}
   		},
   		_buildEvents: function(){
               var events = {
                   keyup: $.proxy(function(e){
                       if ($.inArray(e.keyCode, [27, 37, 39, 38, 40, 32, 13, 9]) === -1)
                           this.update();
                   }, this),
                   keydown: $.proxy(this.keydown, this),
                   paste: $.proxy(this.paste, this)
               };

               if (this.o.showOnFocus === true) {
                   events.focus = $.proxy(this.show, this);
               }

               if (this.isInput) { // single input
                   this._events = [
                       [this.element, events]
                   ];
               }
               // component: input + button
               else if (this.component && this.inputField.length) {
                   this._events = [
                       // For components that are not readonly, allow keyboard nav
                       [this.inputField, events],
                       [this.component, {
                           click: $.proxy(this.show, this)
                       }]
                   ];
               }
   			else {
   				this._events = [
   					[this.element, {
   						click: $.proxy(this.show, this),
   						keydown: $.proxy(this.keydown, this)
   					}]
   				];
   			}
   			this._events.push(
   				// Component: listen for blur on element descendants
   				[this.element, '*', {
   					blur: $.proxy(function(e){
   						this._focused_from = e.target;
   					}, this)
   				}],
   				// Input: listen for blur on element
   				[this.element, {
   					blur: $.proxy(function(e){
   						this._focused_from = e.target;
   					}, this)
   				}]
   			);

   			if (this.o.immediateUpdates) {
   				// Trigger input updates immediately on changed year/month
   				this._events.push([this.element, {
   					'changeYear changeMonth': $.proxy(function(e){
   						this.update(e.date);
   					}, this)
   				}]);
   			}

   			this._secondaryEvents = [
   				[this.picker, {
   					click: $.proxy(this.click, this)
   				}],
   				[this.picker, '.prev, .next', {
   					click: $.proxy(this.navArrowsClick, this)
   				}],
   				[this.picker, '.day:not(.disabled)', {
   					click: $.proxy(this.dayCellClick, this)
   				}],
   				[$(window), {
   					resize: $.proxy(this.place, this)
   				}],
   				[$(document), {
   					'mousedown touchstart': $.proxy(function(e){
   						// Clicked outside the datepicker, hide it
   						if (!(
   							this.element.is(e.target) ||
   							this.element.find(e.target).length ||
   							this.picker.is(e.target) ||
   							this.picker.find(e.target).length ||
   							this.isInline
   						)){
   							this.hide();
   						}
   					}, this)
   				}]
   			];
   		},
   		_attachEvents: function(){
   			this._detachEvents();
   			this._applyEvents(this._events);
   		},
   		_detachEvents: function(){
   			this._unapplyEvents(this._events);
   		},
   		_attachSecondaryEvents: function(){
   			this._detachSecondaryEvents();
   			this._applyEvents(this._secondaryEvents);
   		},
   		_detachSecondaryEvents: function(){
   			this._unapplyEvents(this._secondaryEvents);
   		},
   		_trigger: function(event, altdate){
   			var date = altdate || this.dates.get(-1),
   				local_date = this._utc_to_local(date);

   			this.element.trigger({
   				type: event,
   				date: local_date,
   				viewMode: this.viewMode,
   				dates: $.map(this.dates, this._utc_to_local),
   				format: $.proxy(function(ix, format){
   					if (arguments.length === 0){
   						ix = this.dates.length - 1;
   						format = this.o.format;
   					} else if (typeof ix === 'string'){
   						format = ix;
   						ix = this.dates.length - 1;
   					}
   					format = format || this.o.format;
   					var date = this.dates.get(ix);
   					return DPGlobal.formatDate(date, format, this.o.language);
   				}, this)
   			});
   		},

   		show: function(){
   			if (this.inputField.prop('disabled') || (this.inputField.prop('readonly') && this.o.enableOnReadonly === false))
   				return;
   			if (!this.isInline)
   				this.picker.appendTo(this.o.container);
   			this.place();
   			this.picker.show();
   			this._attachSecondaryEvents();
   			this._trigger('show');
   			if ((window.navigator.msMaxTouchPoints || 'ontouchstart' in document) && this.o.disableTouchKeyboard) {
   				$(this.element).blur();
   			}
   			return this;
   		},

   		hide: function(){
   			if (this.isInline || !this.picker.is(':visible'))
   				return this;
   			this.focusDate = null;
   			this.picker.hide().detach();
   			this._detachSecondaryEvents();
   			this.setViewMode(this.o.startView);

   			if (this.o.forceParse && this.inputField.val())
   				this.setValue();
   			this._trigger('hide');
   			return this;
   		},

   		destroy: function(){
   			this.hide();
   			this._detachEvents();
   			this._detachSecondaryEvents();
   			this.picker.remove();
   			delete this.element.data().datepicker;
   			if (!this.isInput){
   				delete this.element.data().date;
   			}
   			return this;
   		},

   		paste: function(e){
   			var dateString;
   			if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.types
   				&& $.inArray('text/plain', e.originalEvent.clipboardData.types) !== -1) {
   				dateString = e.originalEvent.clipboardData.getData('text/plain');
   			} else if (window.clipboardData) {
   				dateString = window.clipboardData.getData('Text');
   			} else {
   				return;
   			}
   			this.setDate(dateString);
   			this.update();
   			e.preventDefault();
   		},

   		_utc_to_local: function(utc){
   			if (!utc) {
   				return utc;
   			}

   			var local = new Date(utc.getTime() + (utc.getTimezoneOffset() * 60000));

   			if (local.getTimezoneOffset() !== utc.getTimezoneOffset()) {
   				local = new Date(utc.getTime() + (local.getTimezoneOffset() * 60000));
   			}

   			return local;
   		},
   		_local_to_utc: function(local){
   			return local && new Date(local.getTime() - (local.getTimezoneOffset()*60000));
   		},
   		_zero_time: function(local){
   			return local && new Date(local.getFullYear(), local.getMonth(), local.getDate());
   		},
   		_zero_utc_time: function(utc){
   			return utc && UTCDate(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate());
   		},

   		getDates: function(){
   			return $.map(this.dates, this._utc_to_local);
   		},

   		getUTCDates: function(){
   			return $.map(this.dates, function(d){
   				return new Date(d);
   			});
   		},

   		getDate: function(){
   			return this._utc_to_local(this.getUTCDate());
   		},

   		getUTCDate: function(){
   			var selected_date = this.dates.get(-1);
   			if (selected_date !== undefined) {
   				return new Date(selected_date);
   			} else {
   				return null;
   			}
   		},

   		clearDates: function(){
   			this.inputField.val('');
   			this.update();
   			this._trigger('changeDate');

   			if (this.o.autoclose) {
   				this.hide();
   			}
   		},

   		setDates: function(){
   			var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
   			this.update.apply(this, args);
   			this._trigger('changeDate');
   			this.setValue();
   			return this;
   		},

   		setUTCDates: function(){
   			var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
   			this.setDates.apply(this, $.map(args, this._utc_to_local));
   			return this;
   		},

   		setDate: alias('setDates'),
   		setUTCDate: alias('setUTCDates'),
   		remove: alias('destroy', 'Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead'),

   		setValue: function(){
   			var formatted = this.getFormattedDate();
   			this.inputField.val(formatted);
   			return this;
   		},

   		getFormattedDate: function(format){
   			if (format === undefined)
   				format = this.o.format;

   			var lang = this.o.language;
   			return $.map(this.dates, function(d){
   				return DPGlobal.formatDate(d, format, lang);
   			}).join(this.o.multidateSeparator);
   		},

   		getStartDate: function(){
   			return this.o.startDate;
   		},

   		setStartDate: function(startDate){
   			this._process_options({startDate: startDate});
   			this.update();
   			this.updateNavArrows();
   			return this;
   		},

   		getEndDate: function(){
   			return this.o.endDate;
   		},

   		setEndDate: function(endDate){
   			this._process_options({endDate: endDate});
   			this.update();
   			this.updateNavArrows();
   			return this;
   		},

   		setDaysOfWeekDisabled: function(daysOfWeekDisabled){
   			this._process_options({daysOfWeekDisabled: daysOfWeekDisabled});
   			this.update();
   			return this;
   		},

   		setDaysOfWeekHighlighted: function(daysOfWeekHighlighted){
   			this._process_options({daysOfWeekHighlighted: daysOfWeekHighlighted});
   			this.update();
   			return this;
   		},

   		setDatesDisabled: function(datesDisabled){
   			this._process_options({datesDisabled: datesDisabled});
   			this.update();
   			return this;
   		},

   		place: function(){
   			if (this.isInline)
   				return this;
   			var calendarWidth = this.picker.outerWidth(),
   				calendarHeight = this.picker.outerHeight(),
   				visualPadding = 10,
   				container = $(this.o.container),
   				windowWidth = container.width(),
   				scrollTop = this.o.container === 'body' ? $(document).scrollTop() : container.scrollTop(),
   				appendOffset = container.offset();

   			var parentsZindex = [0];
   			this.element.parents().each(function(){
   				var itemZIndex = $(this).css('z-index');
   				if (itemZIndex !== 'auto' && Number(itemZIndex) !== 0) parentsZindex.push(Number(itemZIndex));
   			});
   			var zIndex = Math.max.apply(Math, parentsZindex) + this.o.zIndexOffset;
   			var offset = this.component ? this.component.parent().offset() : this.element.offset();
   			var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(false);
   			var width = this.component ? this.component.outerWidth(true) : this.element.outerWidth(false);
   			var left = offset.left - appendOffset.left;
   			var top = offset.top - appendOffset.top;

   			if (this.o.container !== 'body') {
   				top += scrollTop;
   			}

   			this.picker.removeClass(
   				'datepicker-orient-top datepicker-orient-bottom '+
   				'datepicker-orient-right datepicker-orient-left'
   			);

   			if (this.o.orientation.x !== 'auto'){
   				this.picker.addClass('datepicker-orient-' + this.o.orientation.x);
   				if (this.o.orientation.x === 'right')
   					left -= calendarWidth - width;
   			}
   			// auto x orientation is best-placement: if it crosses a window
   			// edge, fudge it sideways
   			else {
   				if (offset.left < 0) {
   					// component is outside the window on the left side. Move it into visible range
   					this.picker.addClass('datepicker-orient-left');
   					left -= offset.left - visualPadding;
   				} else if (left + calendarWidth > windowWidth) {
   					// the calendar passes the widow right edge. Align it to component right side
   					this.picker.addClass('datepicker-orient-right');
   					left += width - calendarWidth;
   				} else {
   					if (this.o.rtl) {
   						// Default to right
   						this.picker.addClass('datepicker-orient-right');
   					} else {
   						// Default to left
   						this.picker.addClass('datepicker-orient-left');
   					}
   				}
   			}

   			// auto y orientation is best-situation: top or bottom, no fudging,
   			// decision based on which shows more of the calendar
   			var yorient = this.o.orientation.y,
   				top_overflow;
   			if (yorient === 'auto'){
   				top_overflow = -scrollTop + top - calendarHeight;
   				yorient = top_overflow < 0 ? 'bottom' : 'top';
   			}

   			this.picker.addClass('datepicker-orient-' + yorient);
   			if (yorient === 'top')
   				top -= calendarHeight + parseInt(this.picker.css('padding-top'));
   			else
   				top += height;

   			if (this.o.rtl) {
   				var right = windowWidth - (left + width);
   				this.picker.css({
   					top: top,
   					right: right,
   					zIndex: zIndex
   				});
   			} else {
   				this.picker.css({
   					top: top,
   					left: left,
   					zIndex: zIndex
   				});
   			}
   			return this;
   		},

   		_allow_update: true,
   		update: function(){
   			if (!this._allow_update)
   				return this;

   			var oldDates = this.dates.copy(),
   				dates = [],
   				fromArgs = false;
   			if (arguments.length){
   				$.each(arguments, $.proxy(function(i, date){
   					if (date instanceof Date)
   						date = this._local_to_utc(date);
   					dates.push(date);
   				}, this));
   				fromArgs = true;
   			} else {
   				dates = this.isInput
   						? this.element.val()
   						: this.element.data('date') || this.inputField.val();
   				if (dates && this.o.multidate)
   					dates = dates.split(this.o.multidateSeparator);
   				else
   					dates = [dates];
   				delete this.element.data().date;
   			}

   			dates = $.map(dates, $.proxy(function(date){
   				return DPGlobal.parseDate(date, this.o.format, this.o.language, this.o.assumeNearbyYear);
   			}, this));
   			dates = $.grep(dates, $.proxy(function(date){
   				return (
   					!this.dateWithinRange(date) ||
   					!date
   				);
   			}, this), true);
   			this.dates.replace(dates);

   			if (this.o.updateViewDate) {
   				if (this.dates.length)
   					this.viewDate = new Date(this.dates.get(-1));
   				else if (this.viewDate < this.o.startDate)
   					this.viewDate = new Date(this.o.startDate);
   				else if (this.viewDate > this.o.endDate)
   					this.viewDate = new Date(this.o.endDate);
   				else
   					this.viewDate = this.o.defaultViewDate;
   			}

   			if (fromArgs){
   				// setting date by clicking
   				this.setValue();
   				this.element.change();
   			}
   			else if (this.dates.length){
   				// setting date by typing
   				if (String(oldDates) !== String(this.dates) && fromArgs) {
   					this._trigger('changeDate');
   					this.element.change();
   				}
   			}
   			if (!this.dates.length && oldDates.length) {
   				this._trigger('clearDate');
   				this.element.change();
   			}

   			this.fill();
   			return this;
   		},

   		fillDow: function(){
         if (this.o.showWeekDays) {
   			var dowCnt = this.o.weekStart,
   				html = '<tr>';
   			if (this.o.calendarWeeks){
   				html += '<th class="cw">&#160;</th>';
   			}
   			while (dowCnt < this.o.weekStart + 7){
   				html += '<th class="dow';
           if ($.inArray(dowCnt, this.o.daysOfWeekDisabled) !== -1)
             html += ' disabled';
           html += '">'+dates[this.o.language].daysMin[(dowCnt++)%7]+'</th>';
   			}
   			html += '</tr>';
   			this.picker.find('.datepicker-days thead').append(html);
         }
   		},

   		fillMonths: function(){
         var localDate = this._utc_to_local(this.viewDate);
   			var html = '';
   			var focused;
   			for (var i = 0; i < 12; i++){
   				focused = localDate && localDate.getMonth() === i ? ' focused' : '';
   				html += '<span class="month' + focused + '">' + dates[this.o.language].monthsShort[i] + '</span>';
   			}
   			this.picker.find('.datepicker-months td').html(html);
   		},

   		setRange: function(range){
   			if (!range || !range.length)
   				delete this.range;
   			else
   				this.range = $.map(range, function(d){
   					return d.valueOf();
   				});
   			this.fill();
   		},

   		getClassNames: function(date){
   			var cls = [],
   				year = this.viewDate.getUTCFullYear(),
   				month = this.viewDate.getUTCMonth(),
   				today = UTCToday();
   			if (date.getUTCFullYear() < year || (date.getUTCFullYear() === year && date.getUTCMonth() < month)){
   				cls.push('old');
   			} else if (date.getUTCFullYear() > year || (date.getUTCFullYear() === year && date.getUTCMonth() > month)){
   				cls.push('new');
   			}
   			if (this.focusDate && date.valueOf() === this.focusDate.valueOf())
   				cls.push('focused');
   			// Compare internal UTC date with UTC today, not local today
   			if (this.o.todayHighlight && isUTCEquals(date, today)) {
   				cls.push('today');
   			}
   			if (this.dates.contains(date) !== -1)
   				cls.push('active');
   			if (!this.dateWithinRange(date)){
   				cls.push('disabled');
   			}
   			if (this.dateIsDisabled(date)){
   				cls.push('disabled', 'disabled-date');
   			}
   			if ($.inArray(date.getUTCDay(), this.o.daysOfWeekHighlighted) !== -1){
   				cls.push('highlighted');
   			}

   			if (this.range){
   				if (date > this.range[0] && date < this.range[this.range.length-1]){
   					cls.push('range');
   				}
   				if ($.inArray(date.valueOf(), this.range) !== -1){
   					cls.push('selected');
   				}
   				if (date.valueOf() === this.range[0]){
             cls.push('range-start');
           }
           if (date.valueOf() === this.range[this.range.length-1]){
             cls.push('range-end');
           }
   			}
   			return cls;
   		},

   		_fill_yearsView: function(selector, cssClass, factor, year, startYear, endYear, beforeFn){
   			var html = '';
   			var step = factor / 10;
   			var view = this.picker.find(selector);
   			var startVal = Math.floor(year / factor) * factor;
   			var endVal = startVal + step * 9;
   			var focusedVal = Math.floor(this.viewDate.getFullYear() / step) * step;
   			var selected = $.map(this.dates, function(d){
   				return Math.floor(d.getUTCFullYear() / step) * step;
   			});

   			var classes, tooltip, before;
   			for (var currVal = startVal - step; currVal <= endVal + step; currVal += step) {
   				classes = [cssClass];
   				tooltip = null;

   				if (currVal === startVal - step) {
   					classes.push('old');
   				} else if (currVal === endVal + step) {
   					classes.push('new');
   				}
   				if ($.inArray(currVal, selected) !== -1) {
   					classes.push('active');
   				}
   				if (currVal < startYear || currVal > endYear) {
   					classes.push('disabled');
   				}
   				if (currVal === focusedVal) {
   				  classes.push('focused');
           }

   				if (beforeFn !== $.noop) {
   					before = beforeFn(new Date(currVal, 0, 1));
   					if (before === undefined) {
   						before = {};
   					} else if (typeof before === 'boolean') {
   						before = {enabled: before};
   					} else if (typeof before === 'string') {
   						before = {classes: before};
   					}
   					if (before.enabled === false) {
   						classes.push('disabled');
   					}
   					if (before.classes) {
   						classes = classes.concat(before.classes.split(/\s+/));
   					}
   					if (before.tooltip) {
   						tooltip = before.tooltip;
   					}
   				}

   				html += '<span class="' + classes.join(' ') + '"' + (tooltip ? ' title="' + tooltip + '"' : '') + '>' + currVal + '</span>';
   			}

   			view.find('.datepicker-switch').text(startVal + '-' + endVal);
   			view.find('td').html(html);
   		},

   		fill: function(){
   			var d = new Date(this.viewDate),
   				year = d.getUTCFullYear(),
   				month = d.getUTCMonth(),
   				startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
   				startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
   				endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
   				endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
   				todaytxt = dates[this.o.language].today || dates['en'].today || '',
   				cleartxt = dates[this.o.language].clear || dates['en'].clear || '',
   				titleFormat = dates[this.o.language].titleFormat || dates['en'].titleFormat,
   				tooltip,
   				before;
   			if (isNaN(year) || isNaN(month))
   				return;
   			this.picker.find('.datepicker-days .datepicker-switch')
   						.text(DPGlobal.formatDate(d, titleFormat, this.o.language));
   			this.picker.find('tfoot .today')
   						.text(todaytxt)
   						.css('display', this.o.todayBtn === true || this.o.todayBtn === 'linked' ? 'table-cell' : 'none');
   			this.picker.find('tfoot .clear')
   						.text(cleartxt)
   						.css('display', this.o.clearBtn === true ? 'table-cell' : 'none');
   			this.picker.find('thead .datepicker-title')
   						.text(this.o.title)
   						.css('display', typeof this.o.title === 'string' && this.o.title !== '' ? 'table-cell' : 'none');
   			this.updateNavArrows();
   			this.fillMonths();
   			var prevMonth = UTCDate(year, month, 0),
   				day = prevMonth.getUTCDate();
   			prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7)%7);
   			var nextMonth = new Date(prevMonth);
   			if (prevMonth.getUTCFullYear() < 100){
           nextMonth.setUTCFullYear(prevMonth.getUTCFullYear());
         }
   			nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
   			nextMonth = nextMonth.valueOf();
   			var html = [];
   			var weekDay, clsName;
   			while (prevMonth.valueOf() < nextMonth){
   				weekDay = prevMonth.getUTCDay();
   				if (weekDay === this.o.weekStart){
   					html.push('<tr>');
   					if (this.o.calendarWeeks){
   						// ISO 8601: First week contains first thursday.
   						// ISO also states week starts on Monday, but we can be more abstract here.
   						var
   							// Start of current week: based on weekstart/current date
   							ws = new Date(+prevMonth + (this.o.weekStart - weekDay - 7) % 7 * 864e5),
   							// Thursday of this week
   							th = new Date(Number(ws) + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),
   							// First Thursday of year, year from thursday
   							yth = new Date(Number(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay()) % 7 * 864e5),
   							// Calendar week: ms between thursdays, div ms per day, div 7 days
   							calWeek = (th - yth) / 864e5 / 7 + 1;
   						html.push('<td class="cw">'+ calWeek +'</td>');
   					}
   				}
   				clsName = this.getClassNames(prevMonth);
   				clsName.push('day');

   				var content = prevMonth.getUTCDate();

   				if (this.o.beforeShowDay !== $.noop){
   					before = this.o.beforeShowDay(this._utc_to_local(prevMonth));
   					if (before === undefined)
   						before = {};
   					else if (typeof before === 'boolean')
   						before = {enabled: before};
   					else if (typeof before === 'string')
   						before = {classes: before};
   					if (before.enabled === false)
   						clsName.push('disabled');
   					if (before.classes)
   						clsName = clsName.concat(before.classes.split(/\s+/));
   					if (before.tooltip)
   						tooltip = before.tooltip;
   					if (before.content)
   						content = before.content;
   				}

   				//Check if uniqueSort exists (supported by jquery >=1.12 and >=2.2)
   				//Fallback to unique function for older jquery versions
   				if ($.isFunction($.uniqueSort)) {
   					clsName = $.uniqueSort(clsName);
   				} else {
   					clsName = $.unique(clsName);
   				}

   				html.push('<td class="'+clsName.join(' ')+'"' + (tooltip ? ' title="'+tooltip+'"' : '') + ' data-date="' + prevMonth.getTime().toString() + '">' + content + '</td>');
   				tooltip = null;
   				if (weekDay === this.o.weekEnd){
   					html.push('</tr>');
   				}
   				prevMonth.setUTCDate(prevMonth.getUTCDate() + 1);
   			}
   			this.picker.find('.datepicker-days tbody').html(html.join(''));

   			var monthsTitle = dates[this.o.language].monthsTitle || dates['en'].monthsTitle || 'Months';
   			var months = this.picker.find('.datepicker-months')
   						.find('.datepicker-switch')
   							.text(this.o.maxViewMode < 2 ? monthsTitle : year)
   							.end()
   						.find('tbody span').removeClass('active');

   			$.each(this.dates, function(i, d){
   				if (d.getUTCFullYear() === year)
   					months.eq(d.getUTCMonth()).addClass('active');
   			});

   			if (year < startYear || year > endYear){
   				months.addClass('disabled');
   			}
   			if (year === startYear){
   				months.slice(0, startMonth).addClass('disabled');
   			}
   			if (year === endYear){
   				months.slice(endMonth+1).addClass('disabled');
   			}

   			if (this.o.beforeShowMonth !== $.noop){
   				var that = this;
   				$.each(months, function(i, month){
             var moDate = new Date(year, i, 1);
             var before = that.o.beforeShowMonth(moDate);
   					if (before === undefined)
   						before = {};
   					else if (typeof before === 'boolean')
   						before = {enabled: before};
   					else if (typeof before === 'string')
   						before = {classes: before};
   					if (before.enabled === false && !$(month).hasClass('disabled'))
   					    $(month).addClass('disabled');
   					if (before.classes)
   					    $(month).addClass(before.classes);
   					if (before.tooltip)
   					    $(month).prop('title', before.tooltip);
   				});
   			}

   			// Generating decade/years picker
   			this._fill_yearsView(
   				'.datepicker-years',
   				'year',
   				10,
   				year,
   				startYear,
   				endYear,
   				this.o.beforeShowYear
   			);

   			// Generating century/decades picker
   			this._fill_yearsView(
   				'.datepicker-decades',
   				'decade',
   				100,
   				year,
   				startYear,
   				endYear,
   				this.o.beforeShowDecade
   			);

   			// Generating millennium/centuries picker
   			this._fill_yearsView(
   				'.datepicker-centuries',
   				'century',
   				1000,
   				year,
   				startYear,
   				endYear,
   				this.o.beforeShowCentury
   			);
   		},

   		updateNavArrows: function(){
   			if (!this._allow_update)
   				return;

   			var d = new Date(this.viewDate),
   				year = d.getUTCFullYear(),
   				month = d.getUTCMonth(),
   				startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
   				startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
   				endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
   				endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
   				prevIsDisabled,
   				nextIsDisabled,
   				factor = 1;
   			switch (this.viewMode){
   				case 0:
   					prevIsDisabled = year <= startYear && month <= startMonth;
   					nextIsDisabled = year >= endYear && month >= endMonth;
   					break;
   				case 4:
   					factor *= 10;
   					/* falls through */
   				case 3:
   					factor *= 10;
   					/* falls through */
   				case 2:
   					factor *= 10;
   					/* falls through */
   				case 1:
   					prevIsDisabled = Math.floor(year / factor) * factor <= startYear;
   					nextIsDisabled = Math.floor(year / factor) * factor + factor >= endYear;
   					break;
   			}

   			this.picker.find('.prev').toggleClass('disabled', prevIsDisabled);
   			this.picker.find('.next').toggleClass('disabled', nextIsDisabled);
   		},

   		click: function(e){
   			e.preventDefault();
   			e.stopPropagation();

   			var target, dir, day, year, month;
   			target = $(e.target);

   			// Clicked on the switch
   			if (target.hasClass('datepicker-switch') && this.viewMode !== this.o.maxViewMode){
   				this.setViewMode(this.viewMode + 1);
   			}

   			// Clicked on today button
   			if (target.hasClass('today') && !target.hasClass('day')){
   				this.setViewMode(0);
   				this._setDate(UTCToday(), this.o.todayBtn === 'linked' ? null : 'view');
   			}

   			// Clicked on clear button
   			if (target.hasClass('clear')){
   				this.clearDates();
   			}

   			if (!target.hasClass('disabled')){
   				// Clicked on a month, year, decade, century
   				if (target.hasClass('month')
   						|| target.hasClass('year')
   						|| target.hasClass('decade')
   						|| target.hasClass('century')) {
   					this.viewDate.setUTCDate(1);

   					day = 1;
   					if (this.viewMode === 1){
   						month = target.parent().find('span').index(target);
   						year = this.viewDate.getUTCFullYear();
   						this.viewDate.setUTCMonth(month);
   					} else {
   						month = 0;
   						year = Number(target.text());
   						this.viewDate.setUTCFullYear(year);
   					}

   					this._trigger(DPGlobal.viewModes[this.viewMode - 1].e, this.viewDate);

   					if (this.viewMode === this.o.minViewMode){
   						this._setDate(UTCDate(year, month, day));
   					} else {
   						this.setViewMode(this.viewMode - 1);
   						this.fill();
   					}
   				}
   			}

   			if (this.picker.is(':visible') && this._focused_from){
   				this._focused_from.focus();
   			}
   			delete this._focused_from;
   		},

   		dayCellClick: function(e){
   			var $target = $(e.currentTarget);
   			var timestamp = $target.data('date');
   			var date = new Date(timestamp);

   			if (this.o.updateViewDate) {
   				if (date.getUTCFullYear() !== this.viewDate.getUTCFullYear()) {
   					this._trigger('changeYear', this.viewDate);
   				}

   				if (date.getUTCMonth() !== this.viewDate.getUTCMonth()) {
   					this._trigger('changeMonth', this.viewDate);
   				}
   			}
   			this._setDate(date);
   		},

   		// Clicked on prev or next
   		navArrowsClick: function(e){
   			var $target = $(e.currentTarget);
   			var dir = $target.hasClass('prev') ? -1 : 1;
   			if (this.viewMode !== 0){
   				dir *= DPGlobal.viewModes[this.viewMode].navStep * 12;
   			}
   			this.viewDate = this.moveMonth(this.viewDate, dir);
   			this._trigger(DPGlobal.viewModes[this.viewMode].e, this.viewDate);
   			this.fill();
   		},

   		_toggle_multidate: function(date){
   			var ix = this.dates.contains(date);
   			if (!date){
   				this.dates.clear();
   			}

   			if (ix !== -1){
   				if (this.o.multidate === true || this.o.multidate > 1 || this.o.toggleActive){
   					this.dates.remove(ix);
   				}
   			} else if (this.o.multidate === false) {
   				this.dates.clear();
   				this.dates.push(date);
   			}
   			else {
   				this.dates.push(date);
   			}

   			if (typeof this.o.multidate === 'number')
   				while (this.dates.length > this.o.multidate)
   					this.dates.remove(0);
   		},

   		_setDate: function(date, which){
   			if (!which || which === 'date')
   				this._toggle_multidate(date && new Date(date));
   			if ((!which && this.o.updateViewDate) || which === 'view')
   				this.viewDate = date && new Date(date);

   			this.fill();
   			this.setValue();
   			if (!which || which !== 'view') {
   				this._trigger('changeDate');
   			}
   			this.inputField.trigger('change');
   			if (this.o.autoclose && (!which || which === 'date')){
   				this.hide();
   			}
   		},

   		moveDay: function(date, dir){
   			var newDate = new Date(date);
   			newDate.setUTCDate(date.getUTCDate() + dir);

   			return newDate;
   		},

   		moveWeek: function(date, dir){
   			return this.moveDay(date, dir * 7);
   		},

   		moveMonth: function(date, dir){
   			if (!isValidDate(date))
   				return this.o.defaultViewDate;
   			if (!dir)
   				return date;
   			var new_date = new Date(date.valueOf()),
   				day = new_date.getUTCDate(),
   				month = new_date.getUTCMonth(),
   				mag = Math.abs(dir),
   				new_month, test;
   			dir = dir > 0 ? 1 : -1;
   			if (mag === 1){
   				test = dir === -1
   					// If going back one month, make sure month is not current month
   					// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
   					? function(){
   						return new_date.getUTCMonth() === month;
   					}
   					// If going forward one month, make sure month is as expected
   					// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
   					: function(){
   						return new_date.getUTCMonth() !== new_month;
   					};
   				new_month = month + dir;
   				new_date.setUTCMonth(new_month);
   				// Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11
   				new_month = (new_month + 12) % 12;
   			}
   			else {
   				// For magnitudes >1, move one month at a time...
   				for (var i=0; i < mag; i++)
   					// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
   					new_date = this.moveMonth(new_date, dir);
   				// ...then reset the day, keeping it in the new month
   				new_month = new_date.getUTCMonth();
   				new_date.setUTCDate(day);
   				test = function(){
   					return new_month !== new_date.getUTCMonth();
   				};
   			}
   			// Common date-resetting loop -- if date is beyond end of month, make it
   			// end of month
   			while (test()){
   				new_date.setUTCDate(--day);
   				new_date.setUTCMonth(new_month);
   			}
   			return new_date;
   		},

   		moveYear: function(date, dir){
   			return this.moveMonth(date, dir*12);
   		},

   		moveAvailableDate: function(date, dir, fn){
   			do {
   				date = this[fn](date, dir);

   				if (!this.dateWithinRange(date))
   					return false;

   				fn = 'moveDay';
   			}
   			while (this.dateIsDisabled(date));

   			return date;
   		},

   		weekOfDateIsDisabled: function(date){
   			return $.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1;
   		},

   		dateIsDisabled: function(date){
   			return (
   				this.weekOfDateIsDisabled(date) ||
   				$.grep(this.o.datesDisabled, function(d){
   					return isUTCEquals(date, d);
   				}).length > 0
   			);
   		},

   		dateWithinRange: function(date){
   			return date >= this.o.startDate && date <= this.o.endDate;
   		},

   		keydown: function(e){
   			if (!this.picker.is(':visible')){
   				if (e.keyCode === 40 || e.keyCode === 27) { // allow down to re-show picker
   					this.show();
   					e.stopPropagation();
           }
   				return;
   			}
   			var dateChanged = false,
   				dir, newViewDate,
   				focusDate = this.focusDate || this.viewDate;
   			switch (e.keyCode){
   				case 27: // escape
   					if (this.focusDate){
   						this.focusDate = null;
   						this.viewDate = this.dates.get(-1) || this.viewDate;
   						this.fill();
   					}
   					else
   						this.hide();
   					e.preventDefault();
   					e.stopPropagation();
   					break;
   				case 37: // left
   				case 38: // up
   				case 39: // right
   				case 40: // down
   					if (!this.o.keyboardNavigation || this.o.daysOfWeekDisabled.length === 7)
   						break;
   					dir = e.keyCode === 37 || e.keyCode === 38 ? -1 : 1;
             if (this.viewMode === 0) {
     					if (e.ctrlKey){
     						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');

     						if (newViewDate)
     							this._trigger('changeYear', this.viewDate);
     					} else if (e.shiftKey){
     						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');

     						if (newViewDate)
     							this._trigger('changeMonth', this.viewDate);
     					} else if (e.keyCode === 37 || e.keyCode === 39){
     						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveDay');
     					} else if (!this.weekOfDateIsDisabled(focusDate)){
     						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveWeek');
     					}
             } else if (this.viewMode === 1) {
               if (e.keyCode === 38 || e.keyCode === 40) {
                 dir = dir * 4;
               }
               newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');
             } else if (this.viewMode === 2) {
               if (e.keyCode === 38 || e.keyCode === 40) {
                 dir = dir * 4;
               }
               newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');
             }
   					if (newViewDate){
   						this.focusDate = this.viewDate = newViewDate;
   						this.setValue();
   						this.fill();
   						e.preventDefault();
   					}
   					break;
   				case 13: // enter
   					if (!this.o.forceParse)
   						break;
   					focusDate = this.focusDate || this.dates.get(-1) || this.viewDate;
   					if (this.o.keyboardNavigation) {
   						this._toggle_multidate(focusDate);
   						dateChanged = true;
   					}
   					this.focusDate = null;
   					this.viewDate = this.dates.get(-1) || this.viewDate;
   					this.setValue();
   					this.fill();
   					if (this.picker.is(':visible')){
   						e.preventDefault();
   						e.stopPropagation();
   						if (this.o.autoclose)
   							this.hide();
   					}
   					break;
   				case 9: // tab
   					this.focusDate = null;
   					this.viewDate = this.dates.get(-1) || this.viewDate;
   					this.fill();
   					this.hide();
   					break;
   			}
   			if (dateChanged){
   				if (this.dates.length)
   					this._trigger('changeDate');
   				else
   					this._trigger('clearDate');
   				this.inputField.trigger('change');
   			}
   		},

   		setViewMode: function(viewMode){
   			this.viewMode = viewMode;
   			this.picker
   				.children('div')
   				.hide()
   				.filter('.datepicker-' + DPGlobal.viewModes[this.viewMode].clsName)
   					.show();
   			this.updateNavArrows();
         this._trigger('changeViewMode', new Date(this.viewDate));
   		}
   	};

   	var DateRangePicker = function(element, options){
   		$.data(element, 'datepicker', this);
   		this.element = $(element);
   		this.inputs = $.map(options.inputs, function(i){
   			return i.jquery ? i[0] : i;
   		});
   		delete options.inputs;

   		this.keepEmptyValues = options.keepEmptyValues;
   		delete options.keepEmptyValues;

   		datepickerPlugin.call($(this.inputs), options)
   			.on('changeDate', $.proxy(this.dateUpdated, this));

   		this.pickers = $.map(this.inputs, function(i){
   			return $.data(i, 'datepicker');
   		});
   		this.updateDates();
   	};
   	DateRangePicker.prototype = {
   		updateDates: function(){
   			this.dates = $.map(this.pickers, function(i){
   				return i.getUTCDate();
   			});
   			this.updateRanges();
   		},
   		updateRanges: function(){
   			var range = $.map(this.dates, function(d){
   				return d.valueOf();
   			});
   			$.each(this.pickers, function(i, p){
   				p.setRange(range);
   			});
   		},
   		dateUpdated: function(e){
   			// `this.updating` is a workaround for preventing infinite recursion
   			// between `changeDate` triggering and `setUTCDate` calling.  Until
   			// there is a better mechanism.
   			if (this.updating)
   				return;
   			this.updating = true;

   			var dp = $.data(e.target, 'datepicker');

   			if (dp === undefined) {
   				return;
   			}

   			var new_date = dp.getUTCDate(),
   				keep_empty_values = this.keepEmptyValues,
   				i = $.inArray(e.target, this.inputs),
   				j = i - 1,
   				k = i + 1,
   				l = this.inputs.length;
   			if (i === -1)
   				return;

   			$.each(this.pickers, function(i, p){
   				if (!p.getUTCDate() && (p === dp || !keep_empty_values))
   					p.setUTCDate(new_date);
   			});

   			if (new_date < this.dates[j]){
   				// Date being moved earlier/left
   				while (j >= 0 && new_date < this.dates[j]){
   					this.pickers[j--].setUTCDate(new_date);
   				}
   			} else if (new_date > this.dates[k]){
   				// Date being moved later/right
   				while (k < l && new_date > this.dates[k]){
   					this.pickers[k++].setUTCDate(new_date);
   				}
   			}
   			this.updateDates();

   			delete this.updating;
   		},
   		destroy: function(){
   			$.map(this.pickers, function(p){ p.destroy(); });
   			$(this.inputs).off('changeDate', this.dateUpdated);
   			delete this.element.data().datepicker;
   		},
   		remove: alias('destroy', 'Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead')
   	};

   	function opts_from_el(el, prefix){
   		// Derive options from element data-attrs
   		var data = $(el).data(),
   			out = {}, inkey,
   			replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])');
   		prefix = new RegExp('^' + prefix.toLowerCase());
   		function re_lower(_,a){
   			return a.toLowerCase();
   		}
   		for (var key in data)
   			if (prefix.test(key)){
   				inkey = key.replace(replace, re_lower);
   				out[inkey] = data[key];
   			}
   		return out;
   	}

   	function opts_from_locale(lang){
   		// Derive options from locale plugins
   		var out = {};
   		// Check if "de-DE" style date is available, if not language should
   		// fallback to 2 letter code eg "de"
   		if (!dates[lang]){
   			lang = lang.split('-')[0];
   			if (!dates[lang])
   				return;
   		}
   		var d = dates[lang];
   		$.each(locale_opts, function(i,k){
   			if (k in d)
   				out[k] = d[k];
   		});
   		return out;
   	}

   	var old = $.fn.datepicker;
   	var datepickerPlugin = function(option){
   		var args = Array.apply(null, arguments);
   		args.shift();
   		var internal_return;
   		this.each(function(){
   			var $this = $(this),
   				data = $this.data('datepicker'),
   				options = typeof option === 'object' && option;
   			if (!data){
   				var elopts = opts_from_el(this, 'date'),
   					// Preliminary otions
   					xopts = $.extend({}, defaults, elopts, options),
   					locopts = opts_from_locale(xopts.language),
   					// Options priority: js args, data-attrs, locales, defaults
   					opts = $.extend({}, defaults, locopts, elopts, options);
   				if ($this.hasClass('input-daterange') || opts.inputs){
   					$.extend(opts, {
   						inputs: opts.inputs || $this.find('input').toArray()
   					});
   					data = new DateRangePicker(this, opts);
   				}
   				else {
   					data = new Datepicker(this, opts);
   				}
   				$this.data('datepicker', data);
   			}
   			if (typeof option === 'string' && typeof data[option] === 'function'){
   				internal_return = data[option].apply(data, args);
   			}
   		});

   		if (
   			internal_return === undefined ||
   			internal_return instanceof Datepicker ||
   			internal_return instanceof DateRangePicker
   		)
   			return this;

   		if (this.length > 1)
   			throw new Error('Using only allowed for the collection of a single element (' + option + ' function)');
   		else
   			return internal_return;
   	};
   	$.fn.datepicker = datepickerPlugin;

   	var defaults = $.fn.datepicker.defaults = {
   		assumeNearbyYear: false,
   		autoclose: false,
   		beforeShowDay: $.noop,
   		beforeShowMonth: $.noop,
   		beforeShowYear: $.noop,
   		beforeShowDecade: $.noop,
   		beforeShowCentury: $.noop,
   		calendarWeeks: false,
   		clearBtn: false,
   		toggleActive: false,
   		daysOfWeekDisabled: [],
   		daysOfWeekHighlighted: [],
   		datesDisabled: [],
   		endDate: Infinity,
   		forceParse: true,
   		format: 'mm/dd/yyyy',
   		keepEmptyValues: false,
   		keyboardNavigation: true,
   		language: 'en',
   		minViewMode: 0,
   		maxViewMode: 4,
   		multidate: false,
   		multidateSeparator: ',',
   		orientation: "auto",
   		rtl: false,
   		startDate: -Infinity,
   		startView: 0,
   		todayBtn: false,
   		todayHighlight: false,
   		updateViewDate: true,
   		weekStart: 0,
   		disableTouchKeyboard: false,
   		enableOnReadonly: true,
   		showOnFocus: true,
   		zIndexOffset: 10,
   		container: 'body',
   		immediateUpdates: false,
   		title: '',
   		templates: {
   			leftArrow: '&#x00AB;',
   			rightArrow: '&#x00BB;'
   		},
       showWeekDays: true
   	};
   	var locale_opts = $.fn.datepicker.locale_opts = [
   		'format',
   		'rtl',
   		'weekStart'
   	];
   	$.fn.datepicker.Constructor = Datepicker;
   	var dates = $.fn.datepicker.dates = {
   		en: {
   			days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
   			daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
   			daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
   			months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
   			monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
   			today: "Today",
   			clear: "Clear",
   			titleFormat: "MM yyyy"
   		}
   	};

   	var DPGlobal = {
   		viewModes: [
   			{
   				names: ['days', 'month'],
   				clsName: 'days',
   				e: 'changeMonth'
   			},
   			{
   				names: ['months', 'year'],
   				clsName: 'months',
   				e: 'changeYear',
   				navStep: 1
   			},
   			{
   				names: ['years', 'decade'],
   				clsName: 'years',
   				e: 'changeDecade',
   				navStep: 10
   			},
   			{
   				names: ['decades', 'century'],
   				clsName: 'decades',
   				e: 'changeCentury',
   				navStep: 100
   			},
   			{
   				names: ['centuries', 'millennium'],
   				clsName: 'centuries',
   				e: 'changeMillennium',
   				navStep: 1000
   			}
   		],
   		validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
   		nonpunctuation: /[^ -\/:-@\u5e74\u6708\u65e5\[-`{-~\t\n\r]+/g,
   		parseFormat: function(format){
   			if (typeof format.toValue === 'function' && typeof format.toDisplay === 'function')
                   return format;
               // IE treats \0 as a string end in inputs (truncating the value),
   			// so it's a bad format delimiter, anyway
   			var separators = format.replace(this.validParts, '\0').split('\0'),
   				parts = format.match(this.validParts);
   			if (!separators || !separators.length || !parts || parts.length === 0){
   				throw new Error("Invalid date format.");
   			}
   			return {separators: separators, parts: parts};
   		},
   		parseDate: function(date, format, language, assumeNearby){
   			if (!date)
   				return undefined;
   			if (date instanceof Date)
   				return date;
   			if (typeof format === 'string')
   				format = DPGlobal.parseFormat(format);
   			if (format.toValue)
   				return format.toValue(date, format, language);
   			var fn_map = {
   					d: 'moveDay',
   					m: 'moveMonth',
   					w: 'moveWeek',
   					y: 'moveYear'
   				},
   				dateAliases = {
   					yesterday: '-1d',
   					today: '+0d',
   					tomorrow: '+1d'
   				},
   				parts, part, dir, i, fn;
   			if (date in dateAliases){
   				date = dateAliases[date];
   			}
   			if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/i.test(date)){
   				parts = date.match(/([\-+]\d+)([dmwy])/gi);
   				date = new Date();
   				for (i=0; i < parts.length; i++){
   					part = parts[i].match(/([\-+]\d+)([dmwy])/i);
   					dir = Number(part[1]);
   					fn = fn_map[part[2].toLowerCase()];
   					date = Datepicker.prototype[fn](date, dir);
   				}
   				return Datepicker.prototype._zero_utc_time(date);
   			}

   			parts = date && date.match(this.nonpunctuation) || [];

   			function applyNearbyYear(year, threshold){
   				if (threshold === true)
   					threshold = 10;

   				// if year is 2 digits or less, than the user most likely is trying to get a recent century
   				if (year < 100){
   					year += 2000;
   					// if the new year is more than threshold years in advance, use last century
   					if (year > ((new Date()).getFullYear()+threshold)){
   						year -= 100;
   					}
   				}

   				return year;
   			}

   			var parsed = {},
   				setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
   				setters_map = {
   					yyyy: function(d,v){
   						return d.setUTCFullYear(assumeNearby ? applyNearbyYear(v, assumeNearby) : v);
   					},
   					m: function(d,v){
   						if (isNaN(d))
   							return d;
   						v -= 1;
   						while (v < 0) v += 12;
   						v %= 12;
   						d.setUTCMonth(v);
   						while (d.getUTCMonth() !== v)
   							d.setUTCDate(d.getUTCDate()-1);
   						return d;
   					},
   					d: function(d,v){
   						return d.setUTCDate(v);
   					}
   				},
   				val, filtered;
   			setters_map['yy'] = setters_map['yyyy'];
   			setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
   			setters_map['dd'] = setters_map['d'];
   			date = UTCToday();
   			var fparts = format.parts.slice();
   			// Remove noop parts
   			if (parts.length !== fparts.length){
   				fparts = $(fparts).filter(function(i,p){
   					return $.inArray(p, setters_order) !== -1;
   				}).toArray();
   			}
   			// Process remainder
   			function match_part(){
   				var m = this.slice(0, parts[i].length),
   					p = parts[i].slice(0, m.length);
   				return m.toLowerCase() === p.toLowerCase();
   			}
   			if (parts.length === fparts.length){
   				var cnt;
   				for (i=0, cnt = fparts.length; i < cnt; i++){
   					val = parseInt(parts[i], 10);
   					part = fparts[i];
   					if (isNaN(val)){
   						switch (part){
   							case 'MM':
   								filtered = $(dates[language].months).filter(match_part);
   								val = $.inArray(filtered[0], dates[language].months) + 1;
   								break;
   							case 'M':
   								filtered = $(dates[language].monthsShort).filter(match_part);
   								val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
   								break;
   						}
   					}
   					parsed[part] = val;
   				}
   				var _date, s;
   				for (i=0; i < setters_order.length; i++){
   					s = setters_order[i];
   					if (s in parsed && !isNaN(parsed[s])){
   						_date = new Date(date);
   						setters_map[s](_date, parsed[s]);
   						if (!isNaN(_date))
   							date = _date;
   					}
   				}
   			}
   			return date;
   		},
   		formatDate: function(date, format, language){
   			if (!date)
   				return '';
   			if (typeof format === 'string')
   				format = DPGlobal.parseFormat(format);
   			if (format.toDisplay)
                   return format.toDisplay(date, format, language);
               var val = {
   				d: date.getUTCDate(),
   				D: dates[language].daysShort[date.getUTCDay()],
   				DD: dates[language].days[date.getUTCDay()],
   				m: date.getUTCMonth() + 1,
   				M: dates[language].monthsShort[date.getUTCMonth()],
   				MM: dates[language].months[date.getUTCMonth()],
   				yy: date.getUTCFullYear().toString().substring(2),
   				yyyy: date.getUTCFullYear()
   			};
   			val.dd = (val.d < 10 ? '0' : '') + val.d;
   			val.mm = (val.m < 10 ? '0' : '') + val.m;
   			date = [];
   			var seps = $.extend([], format.separators);
   			for (var i=0, cnt = format.parts.length; i <= cnt; i++){
   				if (seps.length)
   					date.push(seps.shift());
   				date.push(val[format.parts[i]]);
   			}
   			return date.join('');
   		},
   		headTemplate: '<thead>'+
   			              '<tr>'+
   			                '<th colspan="7" class="datepicker-title"></th>'+
   			              '</tr>'+
   							'<tr>'+
   								'<th class="prev">'+defaults.templates.leftArrow+'</th>'+
   								'<th colspan="5" class="datepicker-switch"></th>'+
   								'<th class="next">'+defaults.templates.rightArrow+'</th>'+
   							'</tr>'+
   						'</thead>',
   		contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
   		footTemplate: '<tfoot>'+
   							'<tr>'+
   								'<th colspan="7" class="today"></th>'+
   							'</tr>'+
   							'<tr>'+
   								'<th colspan="7" class="clear"></th>'+
   							'</tr>'+
   						'</tfoot>'
   	};
   	DPGlobal.template = '<div class="datepicker">'+
   							'<div class="datepicker-days">'+
   								'<table class="table-condensed">'+
   									DPGlobal.headTemplate+
   									'<tbody></tbody>'+
   									DPGlobal.footTemplate+
   								'</table>'+
   							'</div>'+
   							'<div class="datepicker-months">'+
   								'<table class="table-condensed">'+
   									DPGlobal.headTemplate+
   									DPGlobal.contTemplate+
   									DPGlobal.footTemplate+
   								'</table>'+
   							'</div>'+
   							'<div class="datepicker-years">'+
   								'<table class="table-condensed">'+
   									DPGlobal.headTemplate+
   									DPGlobal.contTemplate+
   									DPGlobal.footTemplate+
   								'</table>'+
   							'</div>'+
   							'<div class="datepicker-decades">'+
   								'<table class="table-condensed">'+
   									DPGlobal.headTemplate+
   									DPGlobal.contTemplate+
   									DPGlobal.footTemplate+
   								'</table>'+
   							'</div>'+
   							'<div class="datepicker-centuries">'+
   								'<table class="table-condensed">'+
   									DPGlobal.headTemplate+
   									DPGlobal.contTemplate+
   									DPGlobal.footTemplate+
   								'</table>'+
   							'</div>'+
   						'</div>';

   	$.fn.datepicker.DPGlobal = DPGlobal;


   	/* DATEPICKER NO CONFLICT
   	* =================== */

   	$.fn.datepicker.noConflict = function(){
   		$.fn.datepicker = old;
   		return this;
   	};

   	/* DATEPICKER VERSION
   	 * =================== */
   	$.fn.datepicker.version = '1.7.1';

   	$.fn.datepicker.deprecated = function(msg){
   		var console = window.console;
   		if (console && console.warn) {
   			console.warn('DEPRECATED: ' + msg);
   		}
   	};


   	/* DATEPICKER DATA-API
   	* ================== */

   	$(document).on(
   		'focus.datepicker.data-api click.datepicker.data-api',
   		'[data-provide="datepicker"]',
   		function(e){
   			var $this = $(this);
   			if ($this.data('datepicker'))
   				return;
   			e.preventDefault();
   			// component click requires us to explicitly show it
   			datepickerPlugin.call($this, 'show');
   		}
   	);
   	$(function(){
   		datepickerPlugin.call($('[data-provide="datepicker-inline"]'));
   	});

   })); },{"jquery":"jquery"}],
   "bootstrap-slider-basic":[function(require,module,exports){
   /** Customized for Enketo:
    *  - wrapped anonymous function inside an AMD/CommonJS wrapper and removed the (window.jQuery) all the way at the bottom
    *  - removed tooltip html
    *  - keep original input element intact instead of moving it inside the slider div
    *  - added wrapper .widget div for easier DOM customization
    */

   /*
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * ========================================================= */

   (function(factory) {
       if (typeof define === "function" && define.amd) {
           define(["jquery"], factory);
       } else if (typeof exports === 'object') {
           factory(require('jquery'));
       } else {
           factory(jQuery);
       }
   }(function($, undefined) {

       var ErrorMsgs = {
           formatInvalidInputErrorMsg: function(input) {
               return "Invalid input value '" + input + "' passed in";
           },
           callingContextNotSliderInstance: "Calling context element does not have instance of Slider bound to it. Check your code to make sure the JQuery object returned from the call to the slider() initializer is calling the method"
       };

       var Slider = function(element, options) {
           var el = this.element = $(element).hide();
           var origWidth = $(element)[0].style.width;

           var updateSlider = false;
           var widget = this.element.next('.widget');

           if (widget.hasClass('slider') === true) {
               updateSlider = true;
               this.widget = widget;
           } else {
               this.widget = $('<div class="widget">' +
                       '<div class="slider">' +
                       '<div class="slider-track">' +
                       '<div class="slider-selection"></div>' +
                       '<div class="slider-handle"></div>' +
                       '<div class="slider-handle"></div>' +
                       '</div>' +
                       //'<div id="tooltip" class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>' +
                       //<div id="tooltip_min" class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>' +
                       //'<div id="tooltip_max" class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>' +
                       '</div>' +
                       '</div>')
                   .insertAfter(this.element);
               //.append( this.element );
           }

           this.picker = this.widget.find('.slider');

           this.id = this.element.data('slider-id') || options.id;
           if (this.id) {
               this.widget[0].id = this.id;
           }

           if (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch) {
               this.touchCapable = true;
           }

           //var tooltip = this.element.data( 'slider-tooltip' ) || options.tooltip;

           //this.tooltip = this.picker.find( '#tooltip' );
           //this.tooltipInner = this.tooltip.find( 'div.tooltip-inner' );

           //this.tooltip_min = this.picker.find( '#tooltip_min' );
           //this.tooltipInner_min = this.tooltip_min.find( 'div.tooltip-inner' );

           //this.tooltip_max = this.picker.find( '#tooltip_max' );
           //this.tooltipInner_max = this.tooltip_max.find( 'div.tooltip-inner' );

           if (updateSlider === true) {
               // Reset classes
               this.widget.removeClass('slider-horizontal');
               this.widget.removeClass('slider-vertical');
               //this.tooltip.removeClass( 'hide' );
               //this.tooltip_min.removeClass( 'hide' );
               //this.tooltip_max.removeClass( 'hide' );

           }

           this.orientation = this.element.data('slider-orientation') || options.orientation;
           switch (this.orientation) {
               case 'vertical':
                   this.widget.addClass('slider-vertical');
                   this.stylePos = 'top';
                   this.mousePos = 'pageY';
                   this.sizePos = 'offsetHeight';
                   //this.tooltip.addClass( 'right' )[ 0 ].style.left = '100%';
                   //this.tooltip_min.addClass( 'right' )[ 0 ].style.left = '100%';
                   //this.tooltip_max.addClass( 'right' )[ 0 ].style.left = '100%';
                   break;
               default:
                   this.widget
                       .addClass('slider-horizontal')
                       .css('width', origWidth);
                   this.orientation = 'horizontal';
                   this.stylePos = 'left';
                   this.mousePos = 'pageX';
                   this.sizePos = 'offsetWidth';
                   //this.tooltip.addClass( 'top' )[ 0 ].style.top = -this.tooltip.outerHeight() - 14 + 'px';
                   //this.tooltip_min.addClass( 'top' )[ 0 ].style.top = -this.tooltip_min.outerHeight() - 14 + 'px';
                   //this.tooltip_max.addClass( 'top' )[ 0 ].style.top = -this.tooltip_max.outerHeight() - 14 + 'px';
                   break;
           }

           var self = this;
           $.each(['min',
               'max',
               'step',
               'precision',
               'value',
               'reversed',
               'handle'
           ], function(i, attr) {
               if (typeof el.data('slider-' + attr) !== 'undefined') {
                   self[attr] = el.data('slider-' + attr);
               } else if (typeof options[attr] !== 'undefined') {
                   self[attr] = options[attr];
               } else if (typeof el.prop(attr) !== 'undefined') {
                   self[attr] = el.prop(attr);
               } else {
                   self[attr] = 0; // to prevent empty string issues in calculations in IE
               }
           });

           if (this.value instanceof Array) {
               if (updateSlider && !this.range) {
                   this.value = this.value[0];
               } else {
                   this.range = true;
               }
           } else if (this.range) {
               // User wants a range, but value is not an array
               this.value = [this.value, this.max];
           }

           this.selection = this.element.data('slider-selection') || options.selection;
           this.selectionEl = this.picker.find('.slider-selection');
           if (this.selection === 'none') {
               this.selectionEl.addClass('hide');
           }

           this.selectionElStyle = this.selectionEl[0].style;

           this.handle1 = this.picker.find('.slider-handle:first');
           this.handle1Stype = this.handle1[0].style;

           this.handle2 = this.picker.find('.slider-handle:last');
           this.handle2Stype = this.handle2[0].style;

           if (updateSlider === true) {
               // Reset classes
               this.handle1.removeClass('round triangle');
               this.handle2.removeClass('round triangle hide');
           }

           switch (this.handle) {
               case 'round':
                   this.handle1.addClass('round');
                   this.handle2.addClass('round');
                   break;
               case 'triangle':
                   this.handle1.addClass('triangle');
                   this.handle2.addClass('triangle');
                   break;
           }

           this.offset = this.picker.offset();
           this.size = this.picker[0][this.sizePos];
           this.formater = options.formater;

           //this.tooltip_separator = options.tooltip_separator;
           //this.tooltip_split = options.tooltip_split;

           this.setValue(this.value);

           this.handle1.on({
               keydown: $.proxy(this.keydown, this, 0)
           });
           this.handle2.on({
               keydown: $.proxy(this.keydown, this, 1)
           });

           if (this.touchCapable) {
               // Touch: Bind touch events:
               this.picker.on({
                   touchstart: $.proxy(this.mousedown, this)
               });
           }
           // Bind mouse events:
           this.picker.on({
               mousedown: $.proxy(this.mousedown, this)
           });

           /*
           if ( tooltip === 'hide' ) {
               this.tooltip.addClass( 'hide' );
               this.tooltip_min.addClass( 'hide' );
               this.tooltip_max.addClass( 'hide' );
           } else if ( tooltip === 'always' ) {
               this.showTooltip();
               this.alwaysShowTooltip = true;
           } else {
               this.picker.on( {
                   mouseenter: $.proxy( this.showTooltip, this ),
                   mouseleave: $.proxy( this.hideTooltip, this )
               } );
               this.handle1.on( {
                   focus: $.proxy( this.showTooltip, this ),
                   blur: $.proxy( this.hideTooltip, this )
               } );
               this.handle2.on( {
                   focus: $.proxy( this.showTooltip, this ),
                   blur: $.proxy( this.hideTooltip, this )
               } );
           }*/

           this.enabled = options.enabled &&
               (this.element.data('slider-enabled') === undefined || this.element.data('slider-enabled') === true);
           if (this.enabled) {
               this.enable();
           } else {
               this.disable();
           }
           this.natural_arrow_keys = this.element.data('slider-natural_arrow_keys') || options.natural_arrow_keys;
       };

       Slider.prototype = {
           constructor: Slider,

           over: false,
           inDrag: false,

           /*showTooltip: function() {
               if ( this.tooltip_split === false ) {
                   this.tooltip.addClass( 'in' );
               } else {
                   this.tooltip_min.addClass( 'in' );
                   this.tooltip_max.addClass( 'in' );
               }

               this.over = true;
           },

           hideTooltip: function() {
               if ( this.inDrag === false && this.alwaysShowTooltip !== true ) {
                   this.tooltip.removeClass( 'in' );
                   this.tooltip_min.removeClass( 'in' );
                   this.tooltip_max.removeClass( 'in' );
               }
               this.over = false;
           },*/

           layout: function() {
               var positionPercentages;

               if (this.reversed) {
                   positionPercentages = [100 - this.percentage[0], this.percentage[1]];
               } else {
                   positionPercentages = [this.percentage[0], this.percentage[1]];
               }

               this.handle1Stype[this.stylePos] = positionPercentages[0] + '%';
               this.handle2Stype[this.stylePos] = positionPercentages[1] + '%';

               if (this.orientation === 'vertical') {
                   this.selectionElStyle.top = Math.min(positionPercentages[0], positionPercentages[1]) + '%';
                   this.selectionElStyle.height = Math.abs(positionPercentages[0] - positionPercentages[1]) + '%';
               } else {
                   this.selectionElStyle.left = Math.min(positionPercentages[0], positionPercentages[1]) + '%';
                   this.selectionElStyle.width = Math.abs(positionPercentages[0] - positionPercentages[1]) + '%';

                   //var offset_min = this.tooltip_min[ 0 ].getBoundingClientRect();
                   //var offset_max = this.tooltip_max[ 0 ].getBoundingClientRect();
                   /*
                   if ( offset_min.right > offset_max.left ) {
                       this.tooltip_max.removeClass( 'top' );
                       this.tooltip_max.addClass( 'bottom' )[ 0 ].style.top = 18 + 'px';
                   } else {
                       this.tooltip_max.removeClass( 'bottom' );
                       this.tooltip_max.addClass( 'top' )[ 0 ].style.top = -30 + 'px';
                   }*/
               }

               /*
               if ( this.range ) {
                   this.tooltipInner.text(
                       this.formater( this.value[ 0 ] ) + this.tooltip_separator + this.formater( this.value[ 1 ] )
                   );
                   this.tooltip[ 0 ].style[ this.stylePos ] = this.size * ( positionPercentages[ 0 ] + ( positionPercentages[ 1 ] - positionPercentages[ 0 ] ) / 2 ) / 100 - ( this.orientation === 'vertical' ? this.tooltip.outerHeight() / 2 : this.tooltip.outerWidth() / 2 ) + 'px';

                   this.tooltipInner_min.text(
                       this.formater( this.value[ 0 ] )
                   );
                   this.tooltipInner_max.text(
                       this.formater( this.value[ 1 ] )
                   );

                   this.tooltip_min[ 0 ].style[ this.stylePos ] = this.size * ( ( positionPercentages[ 0 ] ) / 100 ) - ( this.orientation === 'vertical' ? this.tooltip_min.outerHeight() / 2 : this.tooltip_min.outerWidth() / 2 ) + 'px';
                   this.tooltip_max[ 0 ].style[ this.stylePos ] = this.size * ( ( positionPercentages[ 1 ] ) / 100 ) - ( this.orientation === 'vertical' ? this.tooltip_max.outerHeight() / 2 : this.tooltip_max.outerWidth() / 2 ) + 'px';

               } else {
                   this.tooltipInner.text(
                       this.formater( this.value[ 0 ] )
                   );
                   this.tooltip[ 0 ].style[ this.stylePos ] = this.size * positionPercentages[ 0 ] / 100 - ( this.orientation === 'vertical' ? this.tooltip.outerHeight() / 2 : this.tooltip.outerWidth() / 2 ) + 'px';
               }*/
           },

           mousedown: function(ev) {
               if (!this.isEnabled()) {
                   return false;
               }
               // Touch: Get the original event:
               if (this.touchCapable && ev.type === 'touchstart') {
                   ev = ev.originalEvent;
               }

               this.triggerFocusOnHandle();

               this.offset = this.picker.offset();
               this.size = this.picker[0][this.sizePos];

               var percentage = this.getPercentage(ev);

               if (this.range) {
                   var diff1 = Math.abs(this.percentage[0] - percentage);
                   var diff2 = Math.abs(this.percentage[1] - percentage);
                   this.dragged = (diff1 < diff2) ? 0 : 1;
               } else {
                   this.dragged = 0;
               }

               this.percentage[this.dragged] = this.reversed ? 100 - percentage : percentage;
               this.layout();

               if (this.touchCapable) {
                   // Touch: Bind touch events:
                   $(document).on({
                       touchmove: $.proxy(this.mousemove, this),
                       touchend: $.proxy(this.mouseup, this)
                   });
               }
               // Bind mouse events:
               $(document).on({
                   mousemove: $.proxy(this.mousemove, this),
                   mouseup: $.proxy(this.mouseup, this)
               });

               this.inDrag = true;
               var val = this.calculateValue();
               this.element.trigger({
                       type: 'slideStart',
                       value: val
                   })
                   .data('value', val)
                   .prop('value', val);
               this.setValue(val);
               return true;
           },

           triggerFocusOnHandle: function(handleIdx) {
               if (handleIdx === 0) {
                   this.handle1.focus();
               }
               if (handleIdx === 1) {
                   this.handle2.focus();
               }
           },

           keydown: function(handleIdx, ev) {
               if (!this.isEnabled()) {
                   return false;
               }

               var dir;
               switch (ev.which) {
                   case 37: // left
                   case 40: // down
                       dir = -1;
                       break;
                   case 39: // right
                   case 38: // up
                       dir = 1;
                       break;
               }
               if (!dir) {
                   return;
               }

               // use natural arrow keys instead of from min to max
               if (this.natural_arrow_keys) {
                   if ((this.orientation === 'vertical' && !this.reversed) || (this.orientation === 'horizontal' && this.reversed)) {
                       dir = dir * -1;
                   }
               }

               var oneStepValuePercentageChange = dir * this.percentage[2];
               var percentage = this.percentage[handleIdx] + oneStepValuePercentageChange;

               if (percentage > 100) {
                   percentage = 100;
               } else if (percentage < 0) {
                   percentage = 0;
               }

               this.dragged = handleIdx;
               this.adjustPercentageForRangeSliders(percentage);
               this.percentage[this.dragged] = percentage;
               this.layout();

               var val = this.calculateValue();

               this.element.trigger({
                       type: 'slideStart',
                       value: val
                   })
                   .data('value', val)
                   .prop('value', val);

               this.setValue(val, true);

               this.element
                   .trigger({
                       type: 'slideStop',
                       value: val
                   })
                   .data('value', val)
                   .prop('value', val);
               return false;
           },

           mousemove: function(ev) {
               if (!this.isEnabled()) {
                   return false;
               }
               // Touch: Get the original event:
               if (this.touchCapable && ev.type === 'touchmove') {
                   ev = ev.originalEvent;
               }

               var percentage = this.getPercentage(ev);
               this.adjustPercentageForRangeSliders(percentage);
               this.percentage[this.dragged] = this.reversed ? 100 - percentage : percentage;
               this.layout();

               var val = this.calculateValue();
               this.setValue(val, true);

               return false;
           },
           adjustPercentageForRangeSliders: function(percentage) {
               if (this.range) {
                   if (this.dragged === 0 && this.percentage[1] < percentage) {
                       this.percentage[0] = this.percentage[1];
                       this.dragged = 1;
                   } else if (this.dragged === 1 && this.percentage[0] > percentage) {
                       this.percentage[1] = this.percentage[0];
                       this.dragged = 0;
                   }
               }
           },

           mouseup: function() {
               if (!this.isEnabled()) {
                   return false;
               }
               if (this.touchCapable) {
                   // Touch: Unbind touch event handlers:
                   $(document).off({
                       touchmove: this.mousemove,
                       touchend: this.mouseup
                   });
               }
               // Unbind mouse event handlers:
               $(document).off({
                   mousemove: this.mousemove,
                   mouseup: this.mouseup
               });

               this.inDrag = false;
               /*if ( this.over === false ) {
                   this.hideTooltip();
               }*/
               var val = this.calculateValue();
               this.layout();
               this.element
                   .data('value', val)
                   .prop('value', val)
                   .trigger({
                       type: 'slideStop',
                       value: val
                   });
               return false;
           },

           calculateValue: function() {
               var val;
               if (this.range) {
                   val = [this.min, this.max];
                   if (this.percentage[0] !== 0) {
                       val[0] = (Math.max(this.min, this.min + Math.round((this.diff * this.percentage[0] / 100) / this.step) * this.step));
                       val[0] = this.applyPrecision(val[0]);
                   }
                   if (this.percentage[1] !== 100) {
                       val[1] = (Math.min(this.max, this.min + Math.round((this.diff * this.percentage[1] / 100) / this.step) * this.step));
                       val[1] = this.applyPrecision(val[1]);
                   }
                   this.value = val;
               } else {
                   val = (this.min + Math.round((this.diff * this.percentage[0] / 100) / this.step) * this.step);
                   if (val < this.min) {
                       val = this.min;
                   } else if (val > this.max) {
                       val = this.max;
                   }
                   val = parseFloat(val);
                   val = this.applyPrecision(val);
                   this.value = [val, this.value[1]];
               }
               return val;
           },
           applyPrecision: function(val) {
               var precision = this.precision || this.getNumDigitsAfterDecimalPlace(this.step);
               return this.applyToFixedAndParseFloat(val, precision);
           },
           /*
               Credits to Mike Samuel for the following method!
               Source: http://stackoverflow.com/questions/10454518/javascript-how-to-retrieve-the-number-of-decimals-of-a-string-number
           */
           getNumDigitsAfterDecimalPlace: function(num) {
               var match = ('' + num).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
               if (!match) {
                   return 0;
               }
               return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));
           },

           applyToFixedAndParseFloat: function(num, toFixedInput) {
               var truncatedNum = num.toFixed(toFixedInput);
               return parseFloat(truncatedNum);
           },

           getPercentage: function(ev) {
               if (this.touchCapable && (ev.type === 'touchstart' || ev.type === 'touchmove')) {
                   ev = ev.touches[0];
               }
               var percentage = (ev[this.mousePos] - this.offset[this.stylePos]) * 100 / this.size;
               percentage = Math.round(percentage / this.percentage[2]) * this.percentage[2];
               return Math.max(0, Math.min(100, percentage));
           },

           getValue: function() {
               if (this.range) {
                   return this.value;
               }
               return this.value[0];
           },

           setValue: function(val, triggerSlideEvent) {
               if (!val) {
                   val = 0;
               }
               this.value = this.validateInputValue(val);

               if (this.range) {
                   this.value[0] = this.applyPrecision(this.value[0]);
                   this.value[1] = this.applyPrecision(this.value[1]);

                   this.value[0] = Math.max(this.min, Math.min(this.max, this.value[0]));
                   this.value[1] = Math.max(this.min, Math.min(this.max, this.value[1]));
               } else {
                   this.value = this.applyPrecision(this.value);
                   this.value = [Math.max(this.min, Math.min(this.max, this.value))];
                   this.handle2.addClass('hide');
                   if (this.selection === 'after') {
                       this.value[1] = this.max;
                   } else {
                       this.value[1] = this.min;
                   }
               }

               this.diff = this.max - this.min;
               if (this.diff > 0) {
                   this.percentage = [
                       (this.value[0] - this.min) * 100 / this.diff, (this.value[1] - this.min) * 100 / this.diff,
                       this.step * 100 / this.diff
                   ];
               } else {
                   this.percentage = [0, 0, 100];
               }

               this.layout();


               if (triggerSlideEvent === true) {
                   var slideEventValue = this.range ? this.value : this.value[0];
                   this.element
                       .trigger({
                           'type': 'slide',
                           'value': slideEventValue
                       })
                       .data('value', slideEventValue)
                       .prop('value', slideEventValue);
               }
           },

           validateInputValue: function(val) {
               if (typeof val === 'number') {
                   return val;
               } else if (val instanceof Array) {
                   $.each(val, function(i, input) {
                       if (typeof input !== 'number') {
                           throw new Error(ErrorMsgs.formatInvalidInputErrorMsg(input));
                       }
                   });
                   return val;
               } else {
                   throw new Error(ErrorMsgs.formatInvalidInputErrorMsg(val));
               }
           },

           destroy: function() {
               this.handle1.off();
               this.handle2.off();
               this.element.off().show(); //.insertBefore( this.picker );
               this.picker.off().remove();
               $(this.element).removeData('slider');
           },

           disable: function() {
               this.enabled = false;
               this.handle1.removeAttr("tabindex");
               this.handle2.removeAttr("tabindex");
               this.picker.addClass('slider-disabled');
               this.element.trigger('slideDisabled');
           },

           enable: function() {
               this.enabled = true;
               this.handle1.attr("tabindex", 0);
               this.handle2.attr("tabindex", 0);
               this.picker.removeClass('slider-disabled');
               this.element.trigger('slideEnabled');
           },

           toggle: function() {
               if (this.enabled) {
                   this.disable();
               } else {
                   this.enable();
               }
           },

           isEnabled: function() {
               return this.enabled;
           },

           setAttribute: function(attribute, value) {
               this[attribute] = value;
           },

           getAttribute: function(attribute) {
               return this[attribute];
           }

       };

       var publicMethods = {
           getValue: Slider.prototype.getValue,
           setValue: Slider.prototype.setValue,
           setAttribute: Slider.prototype.setAttribute,
           getAttribute: Slider.prototype.getAttribute,
           destroy: Slider.prototype.destroy,
           disable: Slider.prototype.disable,
           enable: Slider.prototype.enable,
           toggle: Slider.prototype.toggle,
           isEnabled: Slider.prototype.isEnabled
       };

       $.fn.slider = function(option) {
           if (typeof option === 'string' && option !== 'refresh') {
               var args = Array.prototype.slice.call(arguments, 1);
               return invokePublicMethod.call(this, option, args);
           } else {
               return createNewSliderInstance.call(this, option);
           }
       };

       function invokePublicMethod(methodName, args) {
           if (publicMethods[methodName]) {
               var sliderObject = retrieveSliderObjectFromElement(this);
               var result = publicMethods[methodName].apply(sliderObject, args);

               if (typeof result === "undefined") {
                   return $(this);
               } else {
                   return result;
               }
           } else {
               throw new Error("method '" + methodName + "()' does not exist for slider.");
           }
       }

       function retrieveSliderObjectFromElement(element) {
           var sliderObject = $(element).data('slider');
           if (sliderObject && sliderObject instanceof Slider) {
               return sliderObject;
           } else {
               throw new Error(ErrorMsgs.callingContextNotSliderInstance);
           }
       }

       function createNewSliderInstance(opts) {
           var $this = $(this);
           $this.each(function() {
               var $this = $(this),
                   slider = $this.data('slider'),
                   options = typeof opts === 'object' && opts;

               // If slider already exists, use its attributes
               // as options so slider refreshes properly
               if (slider && !options) {
                   options = {};

                   $.each($.fn.slider.defaults, function(key) {
                       options[key] = slider[key];
                   });
               }

               $this.data('slider', (new Slider(this, $.extend({}, $.fn.slider.defaults, options))));
           });
           return $this;
       }

       $.fn.slider.defaults = {
           min: 0,
           max: 10,
           step: 1,
           precision: 0,
           orientation: 'horizontal',
           value: 5,
           range: false,
           selection: 'before',
           //tooltip: 'show',
           //tooltip_separator: ':',
           //tooltip_split: false,
           natural_arrow_keys: false,
           handle: 'round',
           reversed: false,
           enabled: true,
           formater: function(value) {
               return value;
           }
       };

       $.fn.slider.Constructor = Slider;

   }));
   },{"jquery":"jquery"}],
   "enketo-xpathjs":[function(require,module,exports){
   /**
    * Original copyright notice for XPathJS:
    *
    * Copyright (C) 2011 Andrej Pavlovic for XPathJS
    *
    * This file is part of XPathJS.
    *
    * XPathJS is free software: you can redistribute it and/or modify it under
    * the terms of the GNU Affero General Public License as published by the Free
    * Software Foundation, version 3 of the License.
    *
    * XPathJS is distributed in the hope that it will be useful, but WITHOUT ANY
    * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
    * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
    * details.
    *
    * You should have received a copy of the GNU Affero General Public License along
    * with this program. If not, see <http://www.gnu.org/licenses/>.
    */

   /* global window */

   var XPathJS = (function(){
   	var XPathException,
   		XPathEvaluator,
   		XPathExpression,
   		XPathNSResolver,
   		XPathResult,
   		XPathNamespace,
   		module,
   		evaluateExpressionTree,
   		expressions,
   		functions,
   		Context,
   		namespaceCache = [],

   		NAMESPACE_URI_XML = 'http://www.w3.org/XML/1998/namespace',
   		NAMESPACE_URI_XMLNS = 'http://www.w3.org/2000/xmlns/',
   		NAMESPACE_URI_XHTML = 'http://www.w3.org/1999/xhtml',

   		// XPath types
   		BaseType,
   		BooleanType,
   		StringType,
   		NumberType,
   		NodeSetType,

   		// HACK: track expression currently being evaluated
   		currentExpression,

   		/**
   		 * @param {Node} node
   		 * @return {Node}
   		 */
   		nodeOwnerDocument = function(node)
   		{
   			return node.ownerDocument;
   		},

   		/**
   		 * Return all direct children of given node, but only those explicitly
   		 * allowed by XPath specification.
   		 *
   		 * @param {Node} node
   		 * @return {Array} List of nodes in document order.
   		 */
   		nodeChildren = function(node)
   		{
   			var nodes = [],
   				filterSupportedNodeTypes = function(nodes, types)
   				{
   					var item, i, filteredNodes = [];

   					for(i=0; i < nodes.length; i++)
   					{
   						item = nodes.item(i);
   						if (false !== arrayIndexOf(item.nodeType, types))
   						{
   							filteredNodes.push(item);
   						}
   					}

   					return filteredNodes;
   				}
   			;

   			switch(node.nodeType)
   			{
   				/**
   				 * @see http://www.w3.org/TR/xpath/#element-nodes
   				 *
   				 * The children of an element node are the element nodes, comment nodes, processing
   				 * instruction nodes and text nodes for its content.
   				 */
   				case 1: // element,
   					nodes = filterSupportedNodeTypes(node.childNodes, supportedChildNodeTypes = [
   						1, // element
   						3, // text
   						4, // CDATASection
   						7, // processing instruction
   						8  // comment
   					]);
   					break;

   				/**
   				 * @see http://www.w3.org/TR/xpath/#root-node
   				 *
   				 * The element node for the document element is a child of the root node. The root
   				 * node also has as children processing instruction and comment nodes for
   				 * processing instructions and comments that occur in the prolog and
   				 * after the end of the document element.
   				 */
   				case 9: // document
   					nodes = filterSupportedNodeTypes(node.childNodes, supportedChildNodeTypes = [
   						1, // element
   						7, // processing instruction
   						8  // comment
   					]);
   					break;

   				case 2: // attribute
   				case 3: // text
   				case 4: // CDATASection
   				case 7: // processing instruction
   				case 8: // comment
   				case 13: // namespace
   					break;

   				default:
   					throw new Error('Internal Error: nodeChildren - unsupported node type: ' + node.nodeType);
   					break;
   			}

   			return nodes;
   		},

   		/**
   		 * Return all decendants of given node.
   		 *
   		 * @param {Node} node
   		 * @return {Array} List of nodes in document order.
   		 */
   		nodeDescendant = function(node)
   		{
   			var nodes,
   				i,
   				nodes2 = []
   			;

   			nodes = nodeChildren(node);

   			for(i = 0; i < nodes.length; i++)
   			{
   				nodes2.push(nodes[i]);
   				nodes2.push.apply(nodes2, nodeDescendant(nodes[i]));
   			}

   			return nodes2;
   		},

   		/**
   		 * Return parent of given node if there is one.
   		 *
   		 * @param {Node} node
   		 * @return {Node}
   		 */
   		nodeParent = function(node)
   		{
   			/**
   			 * All nodes, except Attr, Document, DocumentFragment, Entity, and Notation may have a parent.
   			 *
   			 * @see http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-1060184317
   			 */
   			var element
   			;

   			switch(node.nodeType)
   			{
   				case 1: // element
   				case 3: // text
   				case 4: // CDATAsection
   				case 7: // processing instruction
   				case 8: // comment
   				case 9: // document
   					return node.parentNode;
   					break;

   				case 2: // Node.ATTRIBUTE_NODE
   					// DOM 2 has ownerElement
   					if (node.ownerElement) {
   						return node.ownerElement;
   					}

   					// Other DOM 1 implementations must search the entire document...
   					element = nodeAttributeSearch(node.ownerDocument, true, function(element, attribute) {
   						if (attribute === node)
   						{
   							return true;
   						}
   					});

   					return element;
   					break;

   				case 13: // Node.NAMESPACE_NODE
   					return node.ownerElement;
   					break;

   				default:
   					throw new Error('Internal Error: nodeParent - node type not supported: ' + node.type);
   					break;
   			}
   		},


   		/**
   		 * Return ancestors of given node.
   		 *
   		 * @param {Node} node
   		 * @return {Array} List of nodes in reverse document order
   		 */
   		nodeAncestor = function(node)
   		{
   			var parent,
   				nodes = []
   			;

   			while(parent = nodeParent(node))
   			{
   				nodes.push(parent);
   				node = parent;
   			}

   			return nodes;
   		},

   		/**
   		 * Return following siblings of given node.
   		 *
   		 * @param {Node} node
   		 * @return {Array} List of nodes in document order
   		 */
   		nodeFollowingSibling = function(node)
   		{
   			return nodeXSibling(node, 'nextSibling');
   		},

   		/**
   		 * Return preceding siblings of given node.
   		 *
   		 * @param {Node} node
   		 * @return {Array} List of nodes in reverse document order
   		 */
   		nodePrecedingSibling = function(node)
   		{
   			return nodeXSibling(node, 'previousSibling');
   		},

   		nodeXSibling = function(node, type)
   		{
   			var sibling,
   				nodes = []
   			;

   			while (sibling = node[type])
   			{
   				switch(sibling.nodeType)
   				{
   					case 1: // element
   					case 3: // text
   					case 4: // CDATAsection
   					case 7: // processing instruction
   					case 8: // comment
   					case 9: // document
   						nodes.push(sibling);
   						break;

   					default:
   						// don't add it
   						break;
   				}

   				node = sibling;
   			}

   			return nodes;
   		},

   		/**
   		 * Return following nodes of given node in document order excluding direct descendants.
   		 *
   		 * @param {Node} node
   		 * @return {Array} List of nodes in document order
   		 */
   		nodeFollowing = function(node)
   		{
   			var nodes = [],
   				parents,
   				i,
   				siblings,
   				j
   			;

   			parents = nodeAncestor(node);
   			parents.unshift(node);

   			for(i=0; i < parents.length; i++)
   			{
   				siblings = nodeFollowingSibling(parents[i]);
   				for(j=0; j < siblings.length; j++)
   				{
   					nodes.push(siblings[j]);
   					nodes.push.apply(nodes, nodeDescendant(siblings[j]));
   				}
   			}

   			return nodes;
   		},

   		/**
   		 * Return preceding nodes of given node excluding direct ancestors.
   		 *
   		 * @param {Node} node
   		 * @return {Array} List of nodes in reverse document order
   		 */
   		nodePreceding = function(node)
   		{
   			var nodes = [],
   				parents,
   				i,
   				siblings,
   				j
   			;

   			parents = nodeAncestor(node);
   			parents.unshift(node);

   			for(i=0; i < parents.length; i++)
   			{
   				siblings = nodePrecedingSibling(parents[i]);
   				for(j=0; j < siblings.length; j++)
   				{
   					nodes.push.apply(nodes, nodeDescendant(siblings[j]).reverse());
   					nodes.push(siblings[j]);
   				}
   			}

   			return nodes;
   		},

   		/**
   		 * Return owner document of node, or node itself if document
   		 *
   		 * @param {Node} node
   		 * @return {Document}
   		 */
   		nodeOwnerDocument = function(node)
   		{
   			switch(node.nodeType)
   			{
   				case 9: // document
   					return node;

   				default:
   					return node.ownerDocument
   			}
   		},

   		/**
   		 * Return attributes of given element in document order regardless of whether they may be namespace nodes or not.
   		 *
   		 * @return {Array} List of attribute nodes in document order
   		 */
   		nodeGetAttributes = function(node)
   		{
   			var nodes = [],
   				i
   			;

   			if (node.nodeType === 1) // element
   			{
   				for(i=0; i<node.attributes.length; i++)
   				{
   					if (!node.attributes[i].specified)
   					{
   						continue;
   					}

   					nodes.push(node.attributes[i]);
   				}
   			}

   			// sort attributes if compareDocumentPosition available
   			if (nodes.length > 1 && nodes[0].compareDocumentPosition) {
   				nodes.sort(function(a, b) {
   					var position = a.compareDocumentPosition(b);

   					if ((position & 2) == 2) return 1;
   					else if ((position & 4) == 4) return -1;
   					else return 0;
   				});
   			}

   			return nodes;
   		},

   		/**
   		 * Return attributes of given element (no namespaces of course). Empty array otherwise
   		 *
   		 * @param {Node} node
   		 * @return {Array} List of attribute nodes in document order
   		 */
   		nodeAttribute = function(node)
   		{
   			var allAttributeNodes = nodeGetAttributes(node),
   				nodes = [],
   				i
   			;

   			for(i = 0; i < allAttributeNodes.length; i++)
   			{
   				if (false === isNamespaceAttributeNode(allAttributeNodes[i]))
   				{
   					nodes.push(allAttributeNodes[i]);
   				}
   			}

   			return nodes;
   		},

   		/**
   		 * Return namespace nodes of given element node. Empty array otherwise
   		 *
   		 * @param {Node} node
   		 * @param {Array} (optional) List of namespace nodes (in document order) to include
   		 * @return {Array} List of namespace nodes in document order
   		 */
   		nodeNamespace = function(node, nsNodes)
   		{
   			var nodes = (nsNodes || []),
   				allAttributeNodes,
   				i,
   				name,
   				item
   			;

   			if (node.nodeType === 1) // element
   			{
   				/**
   				 * IE puts all namespaces inside document.namespaces for HTML node
   				 *
   				 * @see http://msdn.microsoft.com/en-us/library/ms537470(VS.85).aspx
   				 * @see http://msdn.microsoft.com/en-us/library/ms535854(v=VS.85).aspx
   				 */
   				if (node.ownerDocument.documentElement === node && typeof node.ownerDocument.namespaces === 'object')
   				{
   					for(i=node.ownerDocument.namespaces.length-1; i>=0; i--)
   					{
   						item = node.ownerDocument.namespaces.item(i);
   						insertNamespaceIfNotDeclared.call(this, nodes, item.name, item.urn, node);
   					}
   				}

   				allAttributeNodes = nodeGetAttributes(node);

   				for(i = allAttributeNodes.length-1; i>=0; i--)
   				{
   					if (false === (name = isNamespaceAttributeNode(allAttributeNodes[i])))
   					{
   						continue;
   					}

   					/**
   					 * Check the default namespace
   					 *
   					 * @see http://www.w3.org/TR/xml-names/#defaulting
   					 */
   					if (name.length === 1)
   					{
   						insertNamespaceIfNotDeclared.call(this, nodes, '', allAttributeNodes[i].nodeValue, node);
   						continue;
   					}

   					/**
   					 * Normal attribute checking for namespace declarations
   					 */
   					insertNamespaceIfNotDeclared.call(this, nodes, name[1], allAttributeNodes[i].nodeValue, node);
   				}

   				/**
   				 * ... resolving the namespaceURI from a given prefix using the
   				 * current information available in the node's hierarchy ...
   				 *
   				 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator-createNSResolver
   				 */
   				nodeNamespace.call(this, node.parentNode, nodes);

   				// finished with tracking down all nodes
   				if (nsNodes === undefined)
   				{
   					// always need this namespace
   					insertNamespaceIfNotDeclared.call(this, nodes, 'xml', NAMESPACE_URI_XML, node);

   					// if the default namespace is empty, remove it
   					if (nodes[0] && nodes[0].prefix === '' && nodes[0].namespaceURI === '')
   					{
   						nodes.shift();
   					}
   				}

   				if (nsNodes === undefined)
   				{
   					// before returning to original caller, we need to ensure all namespace nodes are
   					// specific to this parent node
   					for(i = 0; i < nodes.length; i++)
   					{
   						if (nodes[i].ownerElement !== node)
   						{
   							nodes[i] = createNamespaceNode(nodes[i].prefix, nodes[i].nodeValue, node);
   						}
   					}
   				}
   			}

   			return nodes;
   		},

   		insertNamespaceIfNotDeclared = function(namespaces, prefix, ns, parent)
   		{
   			var i, namespace;

   			if (!this.opts['case-sensitive'])
   			{
   				prefix = prefix.toLowerCase();
   			}

   			for(i=0; i < namespaces.length; i++)
   			{
   				if (namespaces[i].prefix === prefix)
   				{
   					// namespace already set, do not allow it to be overwritten
   					return false;
   				}
   			}

   			namespace = createNamespaceNode(prefix, ns, parent);

   			if (prefix === '' && ns !== null)
   			{
   				namespaces.unshift(namespace);
   			}
   			else
   			{
   				namespaces.push(namespace);
   			}

   			return true;
   		},

   		isNamespaceAttributeNode = function(node)
   		{
   			var name = node.nodeName.split(':');

   			if (name[0] === 'xmlns')
   			{
   				return name;
   			}

   			return false;
   		},

   		nodeIdAttribute = function(node, attribute)
   		{
   			var i,
   				j,
   				attributes,
   				namespaces,
   				ns,
   				name,
   				id
   			;

   			if (node.nodeType === 1)
   			{
   				attributes = (!attribute) ? nodeAttribute(node) : [attribute];
   				namespaces = nodeNamespace.call(this, node);

   				for(i=0; i<attributes.length; i++)
   				{
   					name = attributes[i].nodeName.split(':');

   					if (name.length === 1)
   					{
   						// set default namespace
   						name[1] = name[0];
   						name[0] = '';
   					}

   					// check namespace of attribute
   					ns = null;
   					for(j=0; j < namespaces.length; j++)
   					{
   						if (namespaces[j].prefix === name[0])
   						{
   							ns = namespaces[j].namespaceURI;
   							break;
   						}
   					}

   					if (ns === null)
   						ns = '';

   					if (this.opts['unique-ids'][ns] === name[1])
   					{
   						// found it
   						return attributes[i];
   					}
   				}
   			}

   			return null;
   		},

   		nodeAttributeSearch = function(startNode, stopAfterFirstMatch, fn)
   		{
   			var i,
   				j,
   				elements,
   				element,
   				matches = [];
   			;

   			// TODO: Possibly cache attribute nodes
   			elements = startNode.getElementsByTagName("*");
   			for (i = 0; i < elements.length; i++) {
   				element = elements.item(i);
   				if (element.nodeType != 1 /*Node.ELEMENT_NODE*/)
   				{
   					continue;
   				}
   				for (j = 0; j < element.attributes.length; j++) {
   					if (!element.attributes[j].specified)
   					{
   						continue;
   					}

   					if (fn(element, element.attributes[j]) === true)
   					{
   						if (stopAfterFirstMatch)
   						{
   							return element;
   						}
   						else
   						{
   							matches.push(element);
   							break;
   						}
   					}
   				}
   			}

   			if (stopAfterFirstMatch)
   			{
   				return null;
   			}
   			else
   			{
   				return matches;
   			}
   		},

   		nodeExpandedName = function(node)
   		{
   			var name,
   				namespaces,
   				i,
   				qname
   			;

   			switch(node.nodeType)
   			{
   				/**
   				 * There is an element node for every element in the document. An element node has an
   				 * expanded-name computed by expanding the QName of the element specified in the
   				 * tag in accordance with the XML Namespaces Recommendation [XML Names]. The namespace
   				 * URI of the element's expanded-name will be null if the QName has no prefix and there
   				 * is no applicable default namespace.
   				 */
   				case 1: // element
   					/**
   					 * @see http://tanalin.com/en/articles/ie-version-js/
   					 */
   					if (typeof node.scopeName != 'undefined' && /* < IE9 */ !document.addEventListener)
   					{
   						/**
   						 * IE specific
   						 *
   						 * @see http://msdn.microsoft.com/en-us/library/ms534388(v=vs.85).aspx
   						 */
   						qname = {
   							prefix: (node.scopeName == 'HTML') ? '' : node.scopeName,
   							name: node.nodeName
   						}
   					}
   					else
   					{
   						// other browsers
   						name = node.nodeName.split(':');

   						// check for namespace prefix
   						if (name.length == 1)
   						{
   							qname = {
   								prefix: '',
   								name: name[0]
   							};
   						}
   						else
   						{
   							qname = {
   								prefix: name[0],
   								name: name[1]
   							};
   						}
   					}

   					if (!this.opts['case-sensitive'])
   					{
   						qname.prefix = qname.prefix.toLowerCase();
   						qname.name = qname.name.toLowerCase();
   					}

   					// resolve namespace
   					namespaces = nodeNamespace.call(this, node);

   					for(i=0; i < namespaces.length; i++)
   					{
   						if (namespaces[i].prefix === qname.prefix)
   						{
   							qname.ns = namespaces[i].namespaceURI;
   							return qname;
   						}
   					}

   					if (qname.prefix === '')
   					{
   						qname.ns = null;
   						return qname;
   					}

   					throw new Error('Internal Error: nodeExpandedName - Failed to expand namespace prefix "' + qname.prefix + '" on element: ' + node.nodeName);
   					break;

   				case 2: // attribute
   					name = node.nodeName.split(':');

   					// check for namespace prefix
   					if (name.length == 1)
   					{
   						/**
   						 * The namespace URI of the attribute's name will be null if
   						 * the QName of the attribute does not have a prefix.
   						 */
   						return {
   							prefix: '',
   							ns: null,
   							name: name[0]
   						};
   					}

   					qname = {
   						prefix: name[0],
   						name: name[1]
   					};

   					if (!this.opts['case-sensitive'])
   					{
   						qname.prefix = qname.prefix.toLowerCase();
   						qname.name = qname.name.toLowerCase();
   					}

   					// resolve namespace
   					namespaces = nodeNamespace.call(this, nodeParent(node)); // attribute

   					for(i=0; i < namespaces.length; i++)
   					{
   						if (namespaces[i].prefix === qname.prefix)
   						{
   							qname.ns = namespaces[i].namespaceURI;
   							return qname;
   						}
   					}

   					throw new Error('Internal Error: nodeExpandedName - Failed to expand namespace prefix "' + qname.prefix + '" on attribute: ' + node.nodeName);
   					break;

   				case 13: // namespace
   					return {
   						prefix: null,
   						ns: null,
   						name: ((!this.opts['case-sensitive']) ? node.prefix : node.prefix.toLowerCase())
   					}
   					break;

   				case 7: // processing instruction
   					return {
   						prefix: null,
   						ns: null,
   						name: ((!this.opts['case-sensitive']) ? node.target : node.target.toLowerCase())
   					}
   					break;

   				default:
   					return false;
   					break;
   			}
   		},

   		nodeStringValue = function(node)
   		{
   			var i,
   				nodeset,
   				value = ''
   			;

   			switch(node.nodeType)
   			{
   				/**
   				 * The string-value of the root node is the concatenation of the string-values of all
   				 * text node descendants of the root node in document order.
   				 */
   				case 9: // document
   				/**
   				 * The string-value of an element node is the concatenation of the string-values of all
   				 * text node descendants of the element node in document order.
   				 */
   				case 1: // element
   					nodeset = evaluateExpressionTree(
   						new Context(node, 1, 1, {}, {}, {}), {
   							type: 'step',
   							args: [
   								'descendant',
   								{
   									type: 'nodeType',
   									args: [
   										'text',
   										[]
   									]
   								}
   							]
   						}
   					);

   					nodeset.sortDocumentOrder();

   					for(i=0; i< nodeset.value.length; i++)
   					{
   						value += nodeset.value[i].data;
   					}

   					return value;
   					break;

   				/**
   				 * The string-value is the normalized value as specified by the XML Recommendation [XML].
   				 * An attribute whose normalized value is a zero-length string is not treated specially:
   				 * it results in an attribute node whose string-value is a zero-length string.
   				 *
   				 * @see http://www.w3.org/TR/1998/REC-xml-19980210#AVNormalize
   				 */
   				case 2: // attribute
   					return node.nodeValue;
   					break;

   				/**
   				 * The string-value of a namespace node is the namespace URI that is being bound to the
   				 * namespace prefix;
   				 * TODO-FUTURE: if it is relative, it must be resolved just like a namespace URI in an expanded-name.
   				 */
   				case 13: // namespace
   					return node.namespaceURI;
   					break;

   				/**
   				 * The string-value of a processing instruction node is the part of the processing instruction following
   				 * the target and any whitespace. It does not include the terminating ?>.
   				 */
   				case 7: // processing instruction
   				/**
   				 * The string-value of comment is the content of the comment not including the opening <!-- or the closing -->.
   				 */
   				case 8: // comment
   				/**
   				 * The string-value of a text node is the character data. A text node always has at least one character of data.
   				 */
   				case 3: // text
   				case 4: // CDATAsection
   					return node.data;
   					break;

   				default:
   					throw new Error('Internal Error: nodeStringValue does not support node type: ' + node.nodeType);
   					break;
   			}
   		},

   		createError = function(code, name, message)
   		{
   			var err = new Error(message);
   			err.name = name;
   			err.code = code;
   			return err;
   		},

   		/**
   		 * @param {Object} needle
   		 * @param {Array} haystack
   		 * @return {Number}
   		 */
   		arrayIndexOf = function(needle, haystack)
   		{
   			var i = haystack.length;
   			while (i--) {
   				if (haystack[i] === needle) {
   					return i;
   				}
   			}
   			return false;
   		},

   		/**
   		 * @see http://www.w3.org/TR/xpath/#booleans
   		 */
   		compareOperator = function(left, right, operator, compareFunction)
   		{
   			var i,
   				j,
   				leftValues,
   				rightValues,
   				result
   			;
   			if (left instanceof NodeSetType)
   			{
   				if (right instanceof NodeSetType)
   				{
   					/**
   					 * If both objects to be compared are node-sets, then the comparison
   					 * will be true if and only if there is a node in the first node-set
   					 * and a node in the second node-set such that the result of performing
   					 * the comparison on the string-values of the two nodes is true.
   					 */
   					rightValues = right.stringValues();
   					leftValues = left.stringValues();

   					for(i=0; i < leftValues.length; i++)
   					{
   						for(j=0; j < rightValues.length; j++)
   						{
   							result = compareOperator(leftValues[i], rightValues[j], operator, compareFunction);
   							if (result.toBoolean())
   							{
   								return result;
   							}
   						}
   					}
   				}
   				else
   				{
   					/**
   					 * If one object to be compared is a node-set and the other is a number,
   					 * then the comparison will be true if and only if there is a node in the node-set
   					 * such that the result of performing the comparison on the number to be compared
   					 * and on the result of converting the string-value of that node to a
   					 * number using the number function is true.
   					 */
   					if (right instanceof NumberType)
   					{
   						leftValues = left.stringValues();

   						for(i=0; i < leftValues.length; i++)
   						{
   							result = compareOperator(new NumberType(leftValues[i].toNumber()), right, operator, compareFunction);
   							if (result.toBoolean())
   							{
   								return result;
   							}
   						}
   					}
   					/**
   					 * JavaRosa addition:
   					 * Check whether string is a date object or a datestring. A datestring is converted to an
   					 * instance of DateType. Note that we've already checked for numbers and that DateType is basically
   					 * just the native JavaScript Date object. So any string, except a number string, that can convert to
   					 * a valid date is considered a date string. It is safe enough hopefully....
   					 */
   					else if (right instanceof DateType || (right instanceof StringType && right.isDateString()))
   					{
   						if (right instanceof StringType)
   						{
   							right = new DateType(right);
   						}

   						leftValues = left.stringValues();

   						for(i=0; i < leftValues.length; i++)
   						{
   							result = compareOperator(new DateType(leftValues[i].toDate()), right, operator, compareFunction);
   							if (result.toBoolean())
   							{
   								return result;
   							}
   						}
   					}
   					/**
   					 * If one object to be compared is a node-set and the other is a string, then the
   					 * comparison will be true if and only if there is a node in the node-set such
   					 * that the result of performing the comparison on the string-value of
   					 * the node and the other string is true.
   					 */
   					else if (right instanceof StringType)
   					{
   						leftValues = left.stringValues();

   						for(i=0; i < leftValues.length; i++)
   						{
   							result = compareOperator(leftValues[i], right, operator, compareFunction);
   							if (result.toBoolean())
   							{
   								return result;
   							}
   						}
   					}
   					/**
   					 * If one object to be compared is a node-set and the other is a boolean, then the comparison
   					 * will be true if and only if the result of performing the comparison on the boolean
   					 * and on the result of converting the node-set to a boolean using the boolean function is true.
   					 */
   					else
   					{
   						return compareOperator(new BooleanType(left.toBoolean()), right, operator, compareFunction);
   					}
   				}
   			}
   			else
   			{
   				if (right instanceof NodeSetType)
   				{
   					/**
   					 * If one object to be compared is a node-set and the other is a number,
   					 * then the comparison will be true if and only if there is a node in the node-set
   					 * such that the result of performing the comparison on the number to be compared
   					 * and on the result of converting the string-value of that node to a
   					 * number using the number function is true.
   					 */
   					if (left instanceof NumberType)
   					{
   						rightValues = right.stringValues();

   						for(i=0; i < rightValues.length; i++)
   						{
   							result = compareOperator(left, new NumberType(rightValues[i].toNumber()), operator, compareFunction);
   							if (result.toBoolean())
   							{
   								return result;
   							}
   						}
   					}
   					/** JavaRosa addition:
   					 * If one object to be compared is a date object or a datestring....etc. A datestring is converted to an
   					 * instance of DateType. Note that we've already checked for numbers and that DateType is basically
   					 * just the native JavaScript Date object. So any string, except a number string, that can convert to
   					 * a valid date is considered a date string. It is safe enough hopefully...
   					 */
   					else if (left instanceof DateType || (left instanceof StringType && left.isDateString()))
   					{
   						if (left instanceof StringType)
   						{
   							left = new DateType(left);
   						}

   						rightValues = right.stringValues();

   						for(i=0; i < rightValues.length; i++)
   						{
   							result = compareOperator(left, new DateType(rightValues[i].toDate()), operator, compareFunction);
   							if (result.toBoolean())
   							{
   								return result;
   							}
   						}
   					}
   					/**
   					 * If one object to be compared is a node-set and the other is a string, then the
   					 * comparison will be true if and only if there is a node in the node-set such
   					 * that the result of performing the comparison on the string-value of
   					 * the node and the other string is true.
   					 */
   					else if (left instanceof StringType)
   					{
   						rightValues = right.stringValues();

   						for(i=0; i < rightValues.length; i++)
   						{
   							result = compareOperator(left, rightValues[i], operator, compareFunction);
   							if (result.toBoolean())
   							{
   								return result;
   							}
   						}
   					}
   					/**
   					 * If one object to be compared is a node-set and the other is a boolean, then the comparison
   					 * will be true if and only if the result of performing the comparison on the boolean
   					 * and on the result of converting the node-set to a boolean using the boolean function is true.
   					 */
   					else
   					{
   						return compareOperator(left, new BooleanType(right.toBoolean()), operator, compareFunction);
   					}
   				}
   				else
   				{
   					switch(operator)
   					{
   						/**
   						 * When neither object to be compared is a node-set and the operator is = or !=,
   						 * then the objects are compared by converting them to a common type as
   						 * follows and then comparing them.
   						 */
   						case '=':
   						case '!=':
   							/**
   							 * If at least one object to be compared is a boolean, then each object to be
   							 * compared is converted to a boolean as if by applying the boolean function.
   							 */
   							if (left instanceof BooleanType || right instanceof BooleanType)
   							{
   								return new BooleanType(compareFunction(left.toBoolean(), right.toBoolean()));
   							}
   							/**
   							 * Otherwise, if at least one object to be compared is a number, then each object
   							 * to be compared is converted to a number as if by applying the number function.
   							 */
   							else if (left instanceof NumberType || right instanceof NumberType)
   							{
   								return new BooleanType(compareFunction(left.toNumber(), right.toNumber()));
   							}

   							/**
   							 * Otherwise, both objects to be compared are converted to strings
   							 * as if by applying the string function.
   							 */
   							return new BooleanType(compareFunction(left.toString(), right.toString()));

   							break;

   						/**
   						 * When neither object to be compared is a node-set and the operator is <=, <, >= or >,
   						 * then the objects are compared by converting both objects to numbers and comparing
   						 * the numbers according to IEEE 754.
   						 */
   						default:
   							return new BooleanType(compareFunction(left.toNumber(), right.toNumber()));
   							break;
   					}
   				}
   			}

   			return new BooleanType(false);
   		},

   		getComparableNode = function(node)
   		{
   			switch(node.nodeType)
   			{
   				case 2: // attribute
   				case 3: // text
   				case 4: // CDATASection
   				case 7: // processing instruction
   				case 8: // comment
   					return nodeParent(node);
   					break;

   				case 1: // element
   				case 9: // document
   					// leave as is
   					return node;
   					break;

   				case 13: // namespace
   				default:
   					throw new Error('Internal Error: getComparableNode - Node type not supported: ' + node.nodeType);
   					break;
   			}
   		},

   		compareDocumentPosition = function(a, b)
   		{
   			var result, nodes, i;

   			if (a.nodeType == 13 &&
   				b.nodeType == 13 &&
   				a.ownerElement == b.ownerElement
   			) {
   				// identical
   				if (a === b) return 0;

   				nodes = nodeNamespace.call(currentExpression, a.ownerElement);

   				for(i=0; i < nodes.length; i++)
   				{
   					if (nodes[i] === a)
   					{
   						result = 4;
   						break;
   					}
   					else if (nodes[i] === b)
   					{
   						result = 2;
   						break;
   					}
   				}
   			}
   			else
   			{
   				if (a.nodeType == 13) a = a.ownerElement;
   				if (b.nodeType == 13) b = b.ownerElement;

   				result = compareDocumentPositionNoNamespace(a, b);
   			}

   			return result;
   		},

   		/**
   		 * @see http://ejohn.org/blog/comparing-document-position/
   		 */
   		compareDocumentPositionNoNamespace = function(a, b)
   		{
   			var a2,
   				b2,
   				result,
   				i,
   				item,
   				compareOriginalVsComparableNode = function(a, a2, b, b2, result, v16, v8, v4, v2) {
   					// if a contains b2 or a == b2
   					if (result === 0 || (result & v16) === v16)
   					{
   						// return result
   						return v4 + v16;
   					}
   					// else if b2 contains a
   					else if ((result & v8) === v8)
   					{
   						// since b != b2, b is an attribute
   						// and since a == a2, a is a node,
   						// so b has to come before a
   						return v2;
   					}
   					else
   					{
   						// return result
   						return result;
   					}
   				}
   			;

   			// check for native implementation
   			if (a.compareDocumentPosition)
   			{
   				return a.compareDocumentPosition(b);
   			}

   			if (a === b)
   			{
   				return 0;
   			}

   			a2 = getComparableNode(a);
   			b2 = getComparableNode(b);

   			// handle document case
   			if (a2.nodeType === 9)
   			{
   				if (b2.nodeType === 9)
   				{
   					if (a2 !== b2)
   					{
   						return 1; // different documents
   					}
   					else
   					{
   						result = 0; // same nodes
   					}
   				}
   				else
   				{
   					if (a2 !== b2.ownerDocument)
   					{
   						return 1; // different documents
   					}
   					else
   					{
   						result = 4 + 16; // a2 before b2, a2 contains b2
   					}
   				}
   			}
   			else
   			{
   				if (b2.nodeType === 9)
   				{
   					if (b2 !== a2.ownerDocument)
   					{
   						return 1; // different documents
   					}
   					else
   					{
   						result = 2 + 8 // b2 before a2, b2 contains a2
   					}
   				}
   				else
   				{
   					if (a2.ownerDocument !== b2.ownerDocument)
   					{
   						return 1; // different documents
   					}
   					else
   					{
   						// do a contains comparison for element nodes
   						if (!a2.contains || typeof a2.sourceIndex === 'undefined' || !b2.contains || typeof b2.sourceIndex === 'undefined')
   						{
   							throw new Error('Cannot compare elements. Neither "compareDocumentPosition" nor "contains" available.');
   						}
   						else
   						{
   							result =
   								(a2 != b2 && a2.contains(b2) && 16) +
   								(a2 != b2 && b2.contains(a2) && 8) +
   								(a2.sourceIndex >= 0 && b2.sourceIndex >= 0
   									? (a2.sourceIndex < b2.sourceIndex && 4) + (a2.sourceIndex > b2.sourceIndex && 2)
   									: 1 ) +
   								0 ;
   						}
   					}
   				}
   			}

   			if (a === a2 && b === b2)
   			{
   				return result;
   			}
   			else if (a === a2)
   			{
   				return compareOriginalVsComparableNode(a, a2, b, b2, result, 16, 8, 4, 2);
   			}
   			else if (b === b2)
   			{
   				return compareOriginalVsComparableNode(b, b2, a, a2, result, 8, 16, 2, 4);
   			}
   			else
   			{
   				// if a2 contains b2
   				if ((result & 16) === 16)
   				{
   					// since a and b are attributes, a has to come before b
   					return 4;
   				}
   				// else if b2 contains a2
   				else if ((result & 8) === 8)
   				{
   					// since a and b are attributes, b has to come before a
   					return 2;
   				}
   				// else if a2 === b2
   				else if (result === 0)
   				{
   					// since a and b are attributes, and both have the same parent
   					// find out which attribute comes first

   					// return "a pre b" or "b pre a" depending on a or b occurs first in a2.childNodes
   					for(i=0; i<a2.attributes.length; i++)
   					{
   						item = a2.attributes[i];
   						if (!item.specified) continue;

   						if (item === b)
   						{
   							return 2;
   						}
   						else if (item === a)
   						{
   							return 4;
   						}
   					}

   					throw new Error('Internal Error: compareDocumentPosition failed to sort attributes.');
   				}
   				// else
   				else
   				{
   					// return result
   					return result;
   				}
   			}

   			throw new Error('Internal Error: compareDocumentPosition failed to sort nodes.');
   		},

   		nodeSupported = function(contextNode)
   		{
   			if (!contextNode) {
   				throw createError(9, 'NOT_SUPPORTED_ERR', 'Context node was not supplied.');
   			}
   			else if (
   					contextNode.nodeType != 9 && // Document
   					contextNode.nodeType != 1 && // Element
   					contextNode.nodeType != 2 && // Attribute
   					contextNode.nodeType != 3 && // Text
   					contextNode.nodeType != 4 && // CDATASection
   					contextNode.nodeType != 8 && // Comment
   					contextNode.nodeType != 7 && // ProcessingInstruction
   					contextNode.nodeType != 13   // XPathNamespace
   			) {
   				throw createError(9, 'NOT_SUPPORTED_ERR', 'The supplied node type is not supported. (nodeType: ' + contextNode.nodeType + ')');
   			}
   			else if (contextNode.nodeType == 2 && !contextNode.specified)
   			{
   				throw createError(9, 'NOT_SUPPORTED_ERR', 'The supplied node is a non-specified attribute node. Only specified attribute nodes are supported.');
   			}
   		},

   		createNamespaceNode = function(prefix, ns, parent)
   		{
   			var i, namespaceNode;

   			for(i = 0; i < namespaceCache.length; i++)
   			{
   				namespaceNode = namespaceCache[i];

   				if (namespaceNode.prefix === prefix &&
   					namespaceNode.nodeValue === ns &&
   					namespaceNode.ownerElement === parent)
   				{
   					// we have already created this namespace node, so use this one
   					return namespaceNode;
   				}
   			}

   			// no such node created in the past, so create it now
   			namespaceNode = new XPathNamespace(prefix, ns, parent);

   			// add node to cache
   			namespaceCache.push(namespaceNode);

   			return namespaceNode;
   		}
   	;

   	BaseType = function(value, type, supports)
   	{
   		this.value = value;
   		this.type = type;
   		this.supports = supports
   	}

   	BaseType.prototype = {
   		value: null,
   		type: null,
   		supports: [],

   		toBoolean: function() {
   			throw new Error('Unable to convert "' + this.type + '" to "boolean".');
   		},

   		toString: function() {
   			throw new Error('Unable to convert "' + this.type + '" to "string".');
   		},

   		toNumber: function() {
   			throw new Error('Unable to convert "' + this.type + '" to "number".');
   		},

   		toNodeSet: function() {
   			throw new Error('Unable to convert "' + this.type + '" to "node-set".');
   		},

   		toDate: function() {
   			throw new Error('Unable to convert "' + this.type + '" to "date".');
   		},

   		/**
   		 * Check if this type can be converted to a particular javascript type.
   		 */
   		canConvertTo: function(type)
   		{
   			return false !== arrayIndexOf(type, this.supports);
   		}
   	}

   	BooleanType = function(value)
   	{
   		BaseType.call(this, value, 'boolean', [
   			'boolean',
   			'string',
   			'number',
   			'date'
   		]);
   	}
   	BooleanType.prototype = new BaseType;
   	BooleanType.constructor = BooleanType;
   	BooleanType.prototype.toBoolean = function() {
   		return this.value;
   	}
   	/**
   	 * The boolean false value is converted to the string false. The boolean true value is converted to the string true.
   	 */
   	BooleanType.prototype.toString = function() {
   		return (this.value === true) ? 'true' : 'false';
   	}
   	/**
   	 * boolean true is converted to 1; boolean false is converted to 0
   	 */
   	BooleanType.prototype.toNumber = function() {
   		return (this.value) ? 1 : 0;
   	}
   	BooleanType.prototype.toDate = function(){
   		return null;
   	}

   	NodeSetType = function(value, documentOrder)
   	{
   		BaseType.call(this, value, 'node-set', [
   			'boolean',
   			'string',
   			'number',
   			'node-set',
   			'date'
   		]);

   		this.docOrder = (documentOrder || 'unsorted');
   	}
   	NodeSetType.prototype = new BaseType;
   	NodeSetType.constructor = NodeSetType;
   	/**
   	 * a node-set is true if and only if it is non-empty
   	 */
   	NodeSetType.prototype.toBoolean = function() {
   		return (this.value.length > 0) ? true : false;
   	}
   	/**
   	 * A node-set is converted to a string by returning the string-value of the node
   	 * in the node-set that is first in document order. If the node-set
   	 * is empty, an empty string is returned.
   	 */
   	NodeSetType.prototype.toString = function() {
   		if (this.value.length < 1)
   		{
   			return '';
   		}

   		this.sortDocumentOrder();
   		return nodeStringValue(this.value[0]);
   	}
   	/**
   	 * a node-set is first converted to a string as if by a call to the string
   	 * function and then converted in the same way as a string argument
   	 */
   	NodeSetType.prototype.toNumber = function() {
   		return (new StringType(this.toString())).toNumber();
   	}
   	NodeSetType.prototype.toNodeSet = function() {
   		return this.value;
   	}
   	NodeSetType.prototype.toDate = function(){
   		return (new StringType(this.toString())).toDate();
   	}
   	NodeSetType.prototype.sortDocumentOrder = function() {
   		switch(this.docOrder)
   		{
   			case 'document-order':
   				// already sorted
   				break;

   			case 'reverse-document-order':
   				// reverse the order
   				this.value.reverse();
   				break;

   			default:
   				this.value.sort(function(a, b) {
   					var result = compareDocumentPosition(a, b);

   					if ( (result & 4) == 4 ) // a before b
   					{
   						return -1;
   					}
   					else if ( (result & 2) == 2 ) // b before a
   					{
   						return 1;
   					}
   					else
   					{
   						throw new Error('NodeSetType.sortDocumentOrder - unexpected compare result: ' + result);
   					}
   				});
   				break;
   		}

   		this.docOrder = 'document-order';
   	}
   	NodeSetType.prototype.sortReverseDocumentOrder = function() {
   		switch(this.docOrder)
   		{
   			case 'document-order':
   				// reverse the order
   				this.value.reverse();
   				break;

   			case 'reverse-document-order':
   				// already sorted
   				break;

   			default:
   				this.sortDocumentOrder();
   				this.value.reverse();
   				break;
   		}

   		this.docOrder = 'reverse-document-order';
   	}

   	NodeSetType.prototype.append = function(nodeset) {
   		var length,
   			i = 0,
   			j = 0,
   			result
   		;

   		if(!nodeset instanceof NodeSetType)
   		{
   			throw new Error('NodeSetType can be passed into NodeSetType.append method');
   		}

   		// use merge sort algorithm
   		this.sortDocumentOrder();
   		nodeset.sortDocumentOrder();

   		while(i < this.value.length && j < nodeset.value.length)
   		{
   			result = compareDocumentPosition(this.value[i], nodeset.value[j]);

   			if (result == 0) // same nodes
   			{
   				// ignore duplicates
   				j++
   			}
   			else if ( (result & 4) == 4 ) // a before b
   			{
   				i++;
   			}
   			else if ( (result & 2) == 2 ) // b before a
   			{
   				this.value.splice(i, 0, nodeset.value[j]);
   				i++;
   				j++;
   			}
   			else
   			{
   				throw new Error('Internal Error: NodeSetType.append - unable to sort nodes. (result: ' + result + ')');
   			}
   		}

   		// append remaining elements
   		for (;j < nodeset.value.length; j++)
   		{
   			this.value.push(nodeset.value[j]);
   		}

   		this.docOrder = 'document-order';
   	}

   	NodeSetType.prototype.stringValues = function()
   	{
   		var i, obj,
   			values = []
   		;

   		for(i=0; i < this.value.length; i++)
   		{
   			//seems like an ugly hack, original commented out below
   			obj = new StringType(nodeStringValue(this.value[i]));
   			if (obj.isDateString()){
   				obj = new DateType(obj.value);
   			}
   			values.push(obj);
   			//values.push(new StringType(nodeStringValue(this.value[i])));
   		}

   		return values;
   	}

   	StringType = function(value)
   	{
   		BaseType.call(this, value, 'string', [
   			'boolean',
   			'string',
   			'number',
   			'date'
   		]);
   	}
   	StringType.prototype = new BaseType;
   	StringType.constructor = StringType;
   	/**
   	 * a string is true if and only if its length is non-zero
   	 */
   	StringType.prototype.toBoolean = function() {
   		return (this.value.length > 0) ? true : false;
   	}
   	StringType.prototype.toString = function() {
   		return this.value;
   	}
   	/**
   	 * a string that consists of optional whitespace followed by an optional minus sign
   	 * followed by a Number followed by whitespace is converted to the IEEE 754 number
   	 * that is nearest (according to the IEEE 754 round-to-nearest rule) to the mathematical
   	 * value represented by the string; any other string is converted to NaN
   	 */
   	StringType.prototype.toNumber = function() {
   		var result;

   		if (this.isDateString(this.value)){
   			return new DateType(this.value).toNumber();
   		}

   		// Digits ('.' Digits?)?
   		result = this.value.match(/^[ \t\r\n]*(-?[0-9]+(?:[.][0-9]*)?)[ \t\r\n]*$/)
   		if (result !== null)
   		{
   			return parseFloat(result[1]);
   		}

   		// '.' Digits
   		result = this.value.match(/^[ \t\r\n]*(-?[.][0-9]+)[ \t\r\n]*$/)
   		if (result !== null)
   		{
   			return parseFloat(result[1]);
   		}

   		// Invalid number
   		return Number.NaN;
   	}
   	StringType.prototype.toDate = function() {
   		return new Date(this.value);
   	}
   	/**
   	 * Test whether the value of a String is (probably a date string)
   	 * It seems like a bit of a hack (and inefficient because it is called for all strings)
   	 * but not sure how else to do this.
   	 * Note that "'4'" and '"4'" can be parse as valid dates.
   	 *
   	 * @return {Boolean}
   	 */
   	StringType.prototype.isDateString = function(){
   		// if it is a number
   		if (!isNaN(this.value)){
   			return false;
   		}
   		// if JavaScript cannot parse the value to a date
   		if (isNaN(Date.parse(this.value))){
   			return false;
   		}
   		// if it does not conform to this crude regex
   		// (required on old versions of Android webview that parse weird strings such as "opv_3" to a valid date...)
   		// it is just a bug fix we can remove around 2018 probably
   		if (!/('|")?[0-9]{4}(-|\/)[0-9]{2}(-|\/)[0-9]{2}('|")?/.test(this.value)){
   			return false;
   		}
   		return true;
   	}

   	NumberType = function(value)
   	{
   		BaseType.call(this, value, 'number', [
   			'boolean',
   			'string',
   			'number',
   			'date'
   		]);
   	}
   	NumberType.prototype = new BaseType;
   	NumberType.constructor = NumberType;
   	/**
   	 * a number is true if and only if it is neither positive or negative zero nor NaN
   	 */
   	NumberType.prototype.toBoolean = function() {
   		return (this.value !== 0 && !isNaN(this.value)) ? true : false;
   	}
   	/**
   	 * A number is converted to a string as follows:
   	 *     NaN is converted to the string NaN
   	 *     positive zero is converted to the string 0
   	 *     negative zero is converted to the string 0
   	 *     positive infinity is converted to the string Infinity
   	 *     negative infinity is converted to the string -Infinity
   	 *     if the number is an integer, the number is represented in decimal form as a Number with no decimal point
   	 *     and no leading zeros, preceded by a minus sign (-) if the number is negative ...
   	 *     otherwise, the number is represented in decimal form as a Number
   	 */
   	NumberType.prototype.toString = function() {
   		return this.value.toString();
   	}
   	NumberType.prototype.toNumber = function() {
   		return this.value;
   	}
   	/**
   	 * This is where JavaRosa's date object deviates from the built-in
   	 * javascript Date object. It instantiates a date based on the amount of days since the
   	 * epoch (and not milliseconds)
   	 *
   	 */
   	NumberType.prototype.toDate = function() {
   		return new Date(this.value * (1000 * 60 * 60 * 24) );
   	}
   	/**
   	 * Date type used in JavaRosa functions
   	 **/
   	DateType = function(value)
   	{
   		BaseType.call(this, value, 'date', [
   			'date',
   			'string',
   			'number',
   			'boolean'
   		])
   	}

   	DateType.prototype = new BaseType;
   	DateType.constructor = DateType;

   	DateType.prototype.toDate = function() {
   		return new Date(this.value);
   	}
   	//maybe the string should be build 'manually' with milliseconds appended to it
   	//more in line with JavaRosa
   	DateType.prototype.toString = function(){
   		return new Date(this.value).toUTCString();
   	}
   	//gets milliseconds since epoch
   	DateType.prototype.toNumber = function(){
   		return ( new Date(this.value).getTime() ) / (1000 * 60 * 60 * 24) ;
   	}

   	DateType.prototype.toBoolean = function(){
   		return (!isNaN(new Date(this.value).getTime()));
   	}

   	/**
   	 * A new exception has been created for exceptions specific to these XPath interfaces.
   	 *
   	 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathException
   	 *
   	 */
   	XPathException = function(code, message)
   	{
   		var err;

   		/**
   		 * @type {number}
   		 */
   		this.code = code;

   		switch(this.code)
   		{
   			case XPathException.INVALID_EXPRESSION_ERR:
   				this.name = 'INVALID_EXPRESSION_ERR';
   				break;

   			case XPathException.TYPE_ERR:
   				this.name = 'TYPE_ERR';
   				break;

   			default:
   				err = new Error('Unsupported XPathException code: ' + this.code);
   				err.name = 'XPathExceptionInternalError';
   				throw err;
   				break;
   		}

   		this.message = (message || "");
   	}

   	XPathException.prototype.toString = function() {
   		return 'XPathException: "' + this.message + '"'
   			+ ', code: "' + this.code + '"'
   			+ ', name: "' + this.name + '"'
   		;
   	}

   	/**
   	 * If the expression has a syntax error or otherwise is not a legal expression
   	 * according to the rules of the specific XPathEvaluator or contains specialized
   	 * extension functions or variables not supported by this implementation.
   	 *
   	 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#INVALID_EXPRESSION_ERR
   	 */
   	XPathException.INVALID_EXPRESSION_ERR = 51;

   	/**
   	 * If the expression cannot be converted to return the specified type.
   	 *
   	 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#TYPE_ERR
   	 */
   	XPathException.TYPE_ERR = 52;

   	/**
   	 * The evaluation of XPath expressions is provided by XPathEvaluator. In a DOM
   	 * implementation which supports the XPath 3.0 feature, as described above,
   	 * the XPathEvaluator interface will be implemented on the same object which
   	 * implements the Document interface permitting it to be obtained by the usual
   	 * binding-specific method such as casting or by using the DOM Level 3
   	 * getInterface method. In this case the implementation obtained from the Document
   	 * supports the XPath DOM module and is compatible with the XPath 1.0 specification.
   	 *
   	 * Evaluation of expressions with specialized extension functions or variables
   	 * may not work in all implementations and is, therefore, not portable.
   	 * XPathEvaluator implementations may be available from other sources that
   	 * could provide specific support for specialized extension functions or variables
   	 * as would be defined by other specifications.
   	 *
   	 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator
   	 */
   	XPathEvaluator = function(options)
   	{
   		var option, defaultOption, found;

   		for (option in options)
   		{
   			found = false;
   			for(defaultOption in this.opts)
   			{
   				if (option === defaultOption)
   				{
   					this.opts[option] = options[option];
   					found = true;
   					break;
   				}
   			}
   			if (found)
   				continue;

   			throw new Error('Unsupported option: ' + option);
   		}

   		// define unique ids
   		this.opts['unique-ids'][NAMESPACE_URI_XML] = 'id';
   		this.opts['unique-ids'][NAMESPACE_URI_XHTML] = 'id';
   	}
   	XPathEvaluator.prototype = {
   		opts: {
   			/**
   			 * List of unique ID for each namespace
   			 *
   			 * @see http://www.w3.org/TR/xpath/#unique-id
   			 */
   			'unique-ids': {},

   			/**
   			 * Specifies whether node name tests should be case sensitive
   			 */
   			'case-sensitive': false
   		},

   		/**
   		 * Creates a parsed XPath expression with resolved namespaces. This is
   		 * useful when an expression will be reused in an application since it
   		 * makes it possible to compile the expression string into a more efficient
   		 * internal form and preresolve all namespace prefixes which occur within
   		 * the expression.
   		 *
   		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator-createExpression
   		 * @param {string} expression The XPath expression string to be parsed.
   		 * @param {XPathNSResolver} resolver The resolver permits translation of all prefixes,
   		 *        including the xml namespace prefix, within the XPath expression into
   		 *        appropriate namespace URIs. If this is specified as null, any namespace
   		 *        prefix within the expression will result in DOMException being thrown
   		 *        with the code NAMESPACE_ERR.
   		 * @return {XPathExpression} The compiled form of the XPath expression.
   		 * @exception {XPathException} INVALID_EXPRESSION_ERR: Raised if the expression is not
   		 *        legal according to the rules of the XPathEvaluator.
   		 * @exception {DOMException} NAMESPACE_ERR: Raised if the expression contains namespace
   		 *        prefixes which cannot be resolved by the specified XPathNSResolver.
   		 */
   		createExpression: function(expression, resolver)
   		{
   			var tree,
   				message,
   				i,
   				nsMapping = {},
   				prefix
   			;

   			// Parse the expression
   			try {
   				tree = XPathJS._parser.parse(expression);
   			} catch(err) {
   				message = 'The expression is not a legal expression.';
   				if (err instanceof XPathJS._parser.SyntaxError)
   				{
   					message += ' (line: ' + err.line + ', character: ' + err.column + ')';
   				}
   				else
   				{
   					// this shouldn't happen, but it's here just in case
   					message += ' (' + err.message + ')';
   				}
   				throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, message);
   			}

   			// Resolve namespaces if any
   			if (tree.nsPrefixes.length > 0)
   			{
   				// ensure resolver supports lookupNamespaceURI function
   				if (typeof resolver != 'object' ||
   					typeof resolver.lookupNamespaceURI === 'undefined')
   				{
   					throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,
   						"No namespace resolver provided or lookupNamespaceURI function not supported."
   					);
   				}

   				for(i=0; i < tree.nsPrefixes.length; i++)
   				{
   					prefix = tree.nsPrefixes[i];
   					nsMapping[prefix] = resolver.lookupNamespaceURI(prefix);

   					if (nsMapping[prefix] === null)
   					{
   						throw createError(14, 'NAMESPACE_ERR', 'Undefined namespace prefix "' + prefix + '" in the context of the given resolver.');
   					}
   				}
   			}

   			return new XPathExpression(tree, nsMapping, this.opts);
   		}

   		/**
   		 * Adapts any DOM node to resolve namespaces so that an XPath expression
   		 * can be easily evaluated relative to the context of the node where it
   		 * appeared within the document. This adapter works like the DOM Level 3
   		 * method lookupNamespaceURI on nodes in resolving the namespaceURI from a
   		 * given prefix using the current information available in the node's
   		 * hierarchy at the time lookupNamespaceURI is called. also correctly
   		 * resolving the implicit xml prefix.
   		 *
   		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator-createNSResolver
   		 * @param {Node} nodeResolver The node to be used as a context for namespace resolution.
   		 * @return {XPathNSResolver} Resolves namespaces with respect to the definitions in scope for a specified node.
   		 */
   		,createNSResolver: function(nodeResolver)
   		{
   			return new XPathNSResolver(nodeResolver);
   		}

   		/**
   		 * Evaluates an XPath expression string and returns a result of the specified type if possible.
   		 *
   		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator-evaluate
   		 * @param {string} expression The XPath expression string to be parsed and evaluated.
   		 * @param {Node} contextNode The context is context node for the evaluation of this XPath expression.
   		 *        If the XPathEvaluator was obtained by casting the Document then this must
   		 *        be owned by the same document and must be a Document, Element, Attribute,
   		 *        Text, CDATASection, Comment, ProcessingInstruction, or XPathNamespace node.
   		 *        If the context node is a Text or a CDATASection, then the context is
   		 *        interpreted as the whole logical text node as seen by XPath, unless the node
   		 *        is empty in which case it may not serve as the XPath context.
   		 * @param {XPathNSResolver} resolver The resolver permits translation of all prefixes, including the
   		 *        xml namespace prefix, within the XPath expression into appropriate namespace
   		 *        URIs. If this is specified as null, any namespace prefix within the
   		 *        expression will result in DOMException being thrown with the code NAMESPACE_ERR.
   		 * @param {number} type If a specific type is specified, then the result will be returned as the corresponding type.
   		 *        For XPath 1.0 results, this must be one of the codes of the XPathResult interface.
   		 * @param {XPathResult} result The result specifies a specific result object which may be reused and
   		 *        returned by this method. If this is specified as nullor the implementation does
   		 *        not reuse the specified result, a new result object will be constructed and returned.
   		 * @return {XPathResult} The result of the evaluation of the XPath expression.
   		 * @exception {XPathException} INVALID_EXPRESSION_ERR: Raised if the expression is not
   		 *        legal according to the rules of the XPathEvaluator.
   		 *        TYPE_ERR: Raised if the result cannot be converted to return the specified type.
   		 * @exception {Error} NAMESPACE_ERR: Raised if the expression contains namespace prefixes
   		 *        which cannot be resolved by the specified XPathNSResolver.
   		 *        WRONG_DOCUMENT_ERR: The Node is from a document that is not supported by this XPathEvaluator.
   		 *        NOT_SUPPORTED_ERR: The Node is not a type permitted as an XPath context node or the request
   		 *        type is not permitted by this XPathEvaluator.
   		 */
   		,evaluate: function(expression, contextNode, resolver, type, result)
   		{
   			// create expression
   			var expression = this.createExpression(expression, resolver);

   			// evaluate expression
   			return expression.evaluate(contextNode, type, result);
   		}
   	};

   	/**
   	 * The XPathExpression interface represents a parsed and resolved XPath expression.
   	 *
   	 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathExpression
   	 */
   	XPathExpression = function(parsedExpression, namespaceMapping, options) {
   		this.parsedExpression = parsedExpression;
   		this.namespaceMapping = namespaceMapping;
   		this.opts = options || {};
   	}

   	XPathExpression.prototype = {
   		/**
   		 * Parsed expression tree
   		 *
   		 * @type {Object}
   		 */
   		parsedExpression: null,

   		/**
   		 * Mapping of prefixes to namespaces
   		 *
   		 * @type {Object}
   		 */
   		namespaceMapping: null,

   		/**
   		 * Options used to tweak expression evaluation
   		 *
   		 * @type {Object}
   		 */
   		opts: {},

   		/**
   		 * Evaluates this XPath expression and returns a result.
   		 *
   		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathExpression-evaluate
   		 * @param {Node} contextNode The context is context node for the evaluation of this XPath expression.
   		 *        If the XPathEvaluator was obtained by casting the Document then this must
   		 *        be owned by the same document and must be a Document, Element, Attribute,
   		 *        Text, CDATASection, Comment, ProcessingInstruction, or XPathNamespace node.
   		 *        If the context node is a Text or a CDATASection, then the context is
   		 *        interpreted as the whole logical text node as seen by XPath, unless the node
   		 *        is empty in which case it may not serve as the XPath context.
   		 * @param {number} type If a specific type is specified, then the result will be
   		 *        coerced to return the specified type relying on XPath conversions and
   		 *        fail if the desired coercion is not possible. This must be one of the
   		 *        type codes of XPathResult.
   		 * @param {XPathResult} result The result specifies a specific result object which may be reused and
   		 *        returned by this method. If this is specified as nullor the implementation does
   		 *        not reuse the specified result, a new result object will be constructed and returned.
   		 * @return {XPathResult} The result of the evaluation of the XPath expression.
   		 * @exception {XPathException} TYPE_ERR: Raised if the result cannot be converted to return the specified type.
   		 * @exception {Error} WRONG_DOCUMENT_ERR: The Node is from a document that is not supported by this XPathEvaluator.
   		 *        NOT_SUPPORTED_ERR: The Node is not a type permitted as an XPath context node or the request
   		 *        type is not permitted by this XPathEvaluator.
   		 */
   		evaluate: function(contextNode, type, result)
   		{
   			var context;

   			// HACK: track current expression being evaluated
   			currentExpression = this;

   			// check if our implementation supports this node type
   			nodeSupported(contextNode);

   			context = new Context(contextNode, 1, 1, {}, functions, this.namespaceMapping, this.opts);

   			return XPathResult.factory(
   				context,
   				type,
   				evaluateExpressionTree(context, this.parsedExpression.tree)
   			)
   		}
   	}

   	/**
   	 * Expression evaluation occurs with respect to a context.
   	 *
   	 * @see http://www.w3.org/TR/xpath/#dt-context-node
   	 */
   	Context = function(node, position, size, vars, functions, namespaceMap, options)
   	{
   		this.node = node;
   		this.pos = position;
   		this.size = size;
   		this.vars = vars;
   		this.fns = functions;
   		this.nsMap = namespaceMap;
   		this.opts = options || {};
   	}

   	Context.prototype = {
   		// a node (the context node)
   		node: null,

   		// a pair of non-zero positive integers (the context position and the context size)
   		pos: null,
   		size: null,

   		// a set of variable bindings
   		vars: null,

   		// a function library
   		fns: null,

   		// the set of namespace declarations in scope for the expression
   		nsMap: null,

   		// Options used to tweak expression evaluation
   		opts: null,

   		clone: function(node, position, size)
   		{
   			return new Context(
   				node || this.node,
   				(typeof position != 'undefined') ? position : this.pos,
   				(typeof size != 'undefined') ? size : this.size,
   				this.vars,
   				this.fns,
   				this.nsMap,
   				this.opts
   			);
   		}
   	};

   	/**
   	 * The XPathNSResolver interface permit prefix strings in the expression to be
   	 * properly bound to namespaceURI strings. XPathEvaluator can construct an
   	 * implementation of XPathNSResolver from a node, or the interface may be
   	 * implemented by any application.
   	 *
   	 * @see http://www.w3.org/TR/DOM-Lstring-3-XPath/xpath.html#XPathNSResolver
   	 */
   	XPathNSResolver = function(nodeResolver)
   	{
   		nodeSupported(nodeResolver);
   		this.node = nodeResolver;
   	}

   	XPathNSResolver.prototype = {

   		/**
   		 * Node used as a reference to resolve prefix to a namespace.
   		 *
   		 * @type {Node}
   		 */
   		node: null,

   		/**
   		 * Look up the namespace URI associated to the given namespace prefix.
   		 * The XPath evaluator must never call this with a null or empty argument,
   		 * because the result of doing this is undefined.
   		 *
   		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathNSResolver-lookupNamespaceURI
   		 * @param {string} prefix The prefix to look for.
   		 * @return {string} Returns the associated namespace URI or null if none is found.
   		 */
   		lookupNamespaceURI: function(prefix)
   		{
   			var node = this.node
   				,i
   				,namespace
   				,tmpNode
   			;

   			switch(prefix)
   			{
   				case 'xml': // http://www.w3.org/TR/REC-xml-names/#xmlReserved
   					return NAMESPACE_URI_XML;
   					break;

   				case 'xmlns': // http://www.w3.org/TR/REC-xml-names/#xmlReserved
   					return NAMESPACE_URI_XMLNS;
   					break;

   				default:
   					switch(this.node.nodeType)
   					{
   						case 9: // Node.DOCUMENT_NODE
   							node = node.documentElement;
   							break;

   						case 1: // Node.ELEMENT_NODE
   							// leave as is
   							break;

   						default:
   							node = nodeParent(node);
   							break;
   					}

   					if (node != null && node.nodeType == 1 /*Node.ELEMENT_NODE*/)
   					{
   						/**
   						 * Check the default namespace
   						 *
   						 * @see http://www.w3.org/TR/xml-names/#defaulting
   						 */
   						if ('' == prefix)
   						{
   							namespace = node.getAttribute('xmlns');
   							if (namespace  !== null)
   							{
   								return namespace;
   							}

   						} else {
   							/**
   							 * IE puts all namespaces inside document.namespaces for HTML node
   							 *
   							 * @see http://msdn.microsoft.com/en-us/library/ms537470(VS.85).aspx
   							 * @see http://msdn.microsoft.com/en-us/library/ms535854(v=VS.85).aspx
   							 */
   							if (node.ownerDocument.documentElement === node && typeof node.ownerDocument.namespaces === 'object')
   							{
   								for(i=0; i<node.ownerDocument.namespaces.length; i++)
   								{
   									namespace = node.ownerDocument.namespaces.item(i);
   									if (namespace.name == prefix)
   									{
   										return namespace.urn;
   									}
   								}
   							}

   							/**
   							 * Normal attribute checking for namespace declarations
   							 */
   							for(i=0; i<node.attributes.length; i++)
   							{
   								if (!node.attributes[i].specified)
   								{
   									continue;
   								}
   								if ('xmlns:' + prefix == node.attributes[i].nodeName)
   								{
   									return node.attributes[i].nodeValue;
   								}
   							}
   						}

   						/**
   						 * ... resolving the namespaceURI from a given prefix using the
   						 * current information available in the node's hierarchy ...
   						 *
   						 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator-createNSResolver
   						 */
   						if (node.ownerDocument.documentElement !== node && node.parentNode)
   						{
   							// HACK: Maybe replace with a function call and pass in prefix with parentNode
   							tmpNode = this.node;
   							this.node = node.parentNode;
   							namespace = this.lookupNamespaceURI(prefix);
   							this.node = tmpNode;
   							return namespace;
   						}
   					}
   					return null;
   					break;
   			}
   		}
   	}

   	expressions = {
   		'/': function(left, right)
   		{
   			var type,
   				i,
   				nodeset,
   				nodeset2,
   				resultNodeset,
   				newContext
   			;

   			// Evaluate left
   			if (left === null)
   			{
   				// A / by itself selects the root node of the document containing the context node.
   				nodeset = new NodeSetType([nodeOwnerDocument(this.node)], 'document-order');
   			}
   			else
   			{
   				nodeset = evaluateExpressionTree(this, left);

   				if (!nodeset instanceof NodeSetType)
   				{
   					throw new Error('Left side of path separator (/) must be of node-set type. (type: ' + nodeset.type + ')');
   				}
   			}

   			// Evaluate right with respect to left
   			if (right === null)
   			{
   				resultNodeset = nodeset;
   			}
   			else
   			{
   				/**
   				 * If it is followed by a relative location path, then the location path selects
   				 * the set of nodes that would be selected by the relative location path relative
   				 * to the root node of the document containing the context node.
   				 */

   				resultNodeset = new NodeSetType([], 'document-order');

   				for(i=0; i<nodeset.value.length; i++)
   				{
   					newContext = this.clone(nodeset.value[i]);
   					nodeset2 = evaluateExpressionTree(newContext, right);

   					if (!nodeset2 instanceof NodeSetType)
   					{
   						throw new Error('Right side of path separator (/) must be of node-set type. (type: ' + nodeset2.type + ')');
   					}

   					resultNodeset.append(nodeset2);
   				}
   			}

   			return resultNodeset;
   		},

   		step: function(axis, nodeTest)
   		{
   			var nodeset,
   				i,
   				node,
   				nodes,
   				qname,
   				nodeType,
   				expandedName
   			;

   			/*
   			 * @ see http://www.w3.org/TR/xpath/#axes
   			 */
   			switch(axis)
   			{
   				/*
   				 * the child axis contains the children of the context node
   				 */
   				case 'child':
   					nodeset = new NodeSetType(nodeChildren(this.node), 'document-order');
   					break;

   				/*
   				 * the descendant axis contains the descendants of the context
   				 * node; a descendant is a child or a child of a child and so on;
   				 * thus the descendant axis never contains attribute or namespace nodes
   				 */
   				case 'descendant':
   					nodeset = new NodeSetType(nodeDescendant(this.node), 'document-order');
   					break;

   				/*
   				 * the parent axis contains the parent of the context node, if there is one
   				 */
   				case 'parent':
   					node = nodeParent(this.node);
   					nodeset = new NodeSetType((!node) ? [] : [node], 'document-order');
   					break;

   				/*
   				 * the ancestor axis contains the ancestors of the context node; the ancestors
   				 * of the context node consist of the parent of context node and the parent's
   				 * parent and so on; thus, the ancestor axis will always include the root node,
   				 * unless the context node is the root node
   				 */
   				case 'ancestor':
   					nodeset = new NodeSetType(nodeAncestor(this.node), 'reverse-document-order');
   					break;

   				/*
   				 * the following-sibling axis contains all the following siblings of the context node;
   				 * if the context node is an attribute node or namespace node, the following-sibling axis is empty
   				 */
   				case 'following-sibling':
   					nodeset = new NodeSetType(nodeFollowingSibling(this.node), 'document-order');
   					break;

   				/*
   				 * the preceding-sibling axis contains all the preceding siblings of the context node; if the
   				 * context node is an attribute node or namespace node, the preceding-sibling axis is empty
   				 */
   				case 'preceding-sibling':
   					nodeset = new NodeSetType(nodePrecedingSibling(this.node), 'reverse-document-order');
   					break;

   				/*
   				 * the following axis contains all nodes in the same document as the context node that are after
   				 * the context node in document order, excluding any descendants and excluding attribute
   				 * nodes and namespace nodes
   				 */
   				case 'following':
   					nodeset = new NodeSetType(nodeFollowing(this.node), 'document-order');
   					break;

   				/*
   				 * the preceding axis contains all nodes in the same document as the context node that are before
   				 * the context node in document order, excluding any ancestors and excluding attribute
   				 * nodes and namespace nodes
   				 */
   				case 'preceding':
   					nodeset = new NodeSetType(nodePreceding(this.node), 'reverse-document-order');
   					break;

   				/*
   				 * the attribute axis contains the attributes of the context node; the axis will
   				 * be empty unless the context node is an element
   				 */
   				case 'attribute':
   					nodeset = new NodeSetType(nodeAttribute(this.node), 'document-order');
   					break;

   				/*
   				 * the namespace axis contains the namespace nodes of the context node; the axis
   				 * will be empty unless the context node is an element
   				 */
   				case 'namespace':
   					nodeset = new NodeSetType(nodeNamespace.call(this, this.node), 'document-order');
   					break;

   				/*
   				 * the self axis contains just the context node itself
   				 */
   				case 'self':
   					nodeset = new NodeSetType([this.node], 'document-order');
   					break;

   				/*
   				 * the descendant-or-self axis contains the context node and the descendants of the context node
   				 */
   				case 'descendant-or-self':
   					nodes = nodeDescendant(this.node);
   					nodes.unshift(this.node);
   					nodeset = new NodeSetType(nodes, 'document-order');
   					break;

   				/*
   				 * the ancestor-or-self axis contains the context node and the ancestors of the context node;
   				 * thus, the ancestor axis will always include the root node
   				 */
   				case 'ancestor-or-self':
   					nodes = nodeAncestor(this.node);
   					nodes.unshift(this.node);
   					nodeset = new NodeSetType(nodes, 'reverse-document-order');
   					break;

   				default:
   					throw new Error("Axis type not supported: " + axis);
   					break;
   			}

   			switch(nodeTest.type)
   			{
   				case 'nodeType':
   					if (nodeTest.args[0] == 'node')
   					{
   						// leave node as is
   						break;
   					}

   					for(i=nodeset.value.length-1; i>=0; i--)
   					{
   						// TODO-FUTURE: perhaps move the switch outside of the loop
   						switch(nodeTest.args[0])
   						{
   							case 'text':
   								if (nodeset.value[i].nodeType != 3 && // text
   									nodeset.value[i].nodeType != 4 // cdata
   								) {
   									nodeset.value.splice(i, 1);
   								}
   								break;

   							case 'comment':
   								if (nodeset.value[i].nodeType != 8) // comment
   								{
   									nodeset.value.splice(i, 1);
   								}
   								break;

   							case 'processing-instruction':
   								if (nodeset.value[i].nodeType != 7 || // processing-instruction
   									(nodeTest.args[1].length > 0 &&
   										evaluateExpressionTree(this, nodeTest.args[1][0]) != nodeset.value[i].nodeName) // name
   								) {
   									nodeset.value.splice(i, 1);
   								}
   								break;
   						}
   					}
   					break;

   				case 'name':
   					qname = evaluateExpressionTree(this, nodeTest);

   					/**
   					 * Every axis has a principal node type. If an axis can contain elements, then the
   					 * principal node type is element; otherwise, it is the type of the nodes
   					 * that the axis can contain.
   					 *
   					 * @see http://www.w3.org/TR/xpath/#node-tests
   					 */
   					switch(axis)
   					{
   						// For the attribute axis, the principal node type is attribute.
   						case 'attribute':
   							nodeType = 2;
   							break;

   						// For the namespace axis, the principal node type is namespace.
   						case 'namespace':
   							nodeType = 13;
   							break;

   						// For other axes, the principal node type is element.
   						default:
   							nodeType = 1;
   							break;
   					}

   					for(i=nodeset.value.length-1; i>=0; i--)
   					{
   						if (nodeset.value[i].nodeType != nodeType)
   						{
   							// not of principal node type, so remove node
   							nodeset.value.splice(i, 1);
   							continue;
   						}

   						// *
   						if (qname.ns === null && qname.name === null)
   						{
   							continue;
   						}

   						// get expanded name
   						expandedName = nodeExpandedName.call(this, nodeset.value[i]);

   						// check namespace
   						//alert(expandedName.ns + ' ' + qname.ns + "\r\n" + expandedName.name + ' ' + qname.name);
   						if (expandedName === false || expandedName.ns !== qname.ns)
   						{
   							// namespaces don't match
   							nodeset.value.splice(i, 1);
   							continue;
   						}

   						// check name
   						if (qname.name !== null &&
   							// TODO: provide option for case sensitivity
   							expandedName.name.toLowerCase() != qname.name.toLowerCase()
   						) {
   							// names don't match
   							nodeset.value.splice(i, 1);
   						}
   					}
   					break;

   				default:
   					throw new Error('NodeTest type not supported in step: ' + nodeTest.type);
   					break;
   			}

   			return nodeset;
   		},

   		/**
   		 * @see http://www.w3.org/TR/xpath/#predicates
   		 */
   		predicate: function(axis, expr, predicateExprs)
   		{
   			var nodeset,
   				i,
   				result,
   				j,
   				k,
   				length
   			;

   			// Evaluate expression
   			nodeset = evaluateExpressionTree(this, expr);

   			// Ensure we get a node-set
   			if (!nodeset instanceof NodeSetType)
   			{
   				throw new Error('Expected "node-set", got: ' + nodeset.type);
   			}

   			/**
   			 * A predicate filters a node-set with respect to an axis to produce a new node-set.
   			 */
   			switch(axis)
   			{
   				case 'ancestor':
   				case 'ancestor-or-self':
   				case 'preceding':
   				case 'preceding-sibling':
   					nodeset.sortReverseDocumentOrder();
   					break;

   				default:
   					nodeset.sortDocumentOrder();
   					break;
   			}

   			for (j=0; j<predicateExprs.length; j++)
   			{
   				/**
   				 * For each node in the node-set to be filtered, ...
   				 */
   				for(i=0,k=1, length=nodeset.value.length; i<nodeset.value.length;k++)
   				{
   					/**
   					 * ... the PredicateExpr is evaluated with that node as the context node, with the
   					 * number of nodes in the node-set as the context size, and with the proximity
   					 * position of the node in the node-set with respect to the axis as the context
   					 * position; if PredicateExpr evaluates to true for that node, the node is
   					 * included in the new node-set; otherwise, it is not included.
   					 */
   					result = evaluateExpressionTree(this.clone(nodeset.value[i], k, length), predicateExprs[j]);

   					/**
   					 * If the result is a number, the result will be converted to true if the number
   					 * is equal to the context position and will be converted to false otherwise;
   					 */
   					if (result instanceof NumberType)
   					{
   						if (result.value != k)
   						{
   							nodeset.value.splice(i, 1);
   							continue;
   						}
   					}

   					/**
   					 * if the result is not a number, then the result will be converted as
   					 * if by a call to the boolean function.
   					 */
   					else if (!result.toBoolean())
   					{
   						nodeset.value.splice(i, 1);
   						continue;
   					}

   					i++;
   				}
   			}

   			return nodeset;
   		},

   		/**
   		 * @see http://www.w3.org/TR/xpath/#section-Function-Calls
   		 */
   		'function': function(name, args)
   		{
   			var qname,
   				argVals = [],
   				formatName = function(qname)
   				{
   					return ((qname.ns !== null) ? '{' + qname.ns + '}' : '{}') + qname.name;
   				},
   				formatFnArgs = function(args)
   				{
   					var i,
   						types = [],
   						type
   					;

   					for(i=0; i < args.length; i++)
   					{
   						type = (args[i].t === undefined) ? 'object' : args[i].t;

   						if (args[i].r !== false) // required
   						{
   							if (args[i].rep === true)
   							{
   								type += '+'; // one or more
   							}
   						}
   						else
   						{
   							if (args[i].rep === true)
   							{
   								type += '*'; // zero or more
   							}
   							else
   							{
   								type += '?' // optional
   							}
   						}

   						types.push(type);
   					}

   					return '(' + types.join(', ') + ')';
   				},
   				fnInfo,
   				i,
   				j = 0,
   				argTypes = [],
   				val
   			;

   			/**
   			 * Does the function exist?
   			 * TODO-FUTURE: this should be done during createExpression, not evaluate
   			 */
   			qname = evaluateExpressionTree(this, name);

   			if (qname.ns === null)
   			{
   				// since we cannot use null as key
   				qname.ns = '';
   			}

   			if (!this.fns[qname.ns] || !this.fns[qname.ns][qname.name])
   			{
   				throw new Error('Function "' + formatName(qname) + '" does not exist.');
   			}

   			fnInfo = this.fns[qname.ns][qname.name];

   			/**
   			 * Does the supplied number of arguments match what the function expects?
   			 * TODO-FUTURE: this should be done during createExpression, not evaluate
   			 */
   			if (!fnInfo.args) fnInfo.args = [];

   			for(i=0, j=0; i < fnInfo.args.length; j++, i++)
   			{
   				if (args[j] === undefined)
   				{
   					// no supplied arg
   					if (fnInfo.args[i].r !== false) // required
   					{
   						// not enough supplied args
   						throw new Error('Function "' + formatName(qname) + '" expects ' + formatFnArgs(fnInfo.args) + '.');
   					}
   				}
   				else
   				{
   					// has supplied arg
   					argTypes.push(
   						(fnInfo.args[i].t === undefined) ? 'object' : fnInfo.args[i].t
   					);
   				}

   				if (fnInfo.args[i].rep === true)
   				{
   					// repeated args
   					for(;j < args.length; j++)
   					{
   						argTypes.push(
   							(fnInfo.args[i].t === undefined) ? 'object' : fnInfo.args[i].t
   						);
   					}
   					break;
   				}
   			}

   			if (argTypes.length < args.length)
   			{
   				// too many supplied args
   				throw new Error('Function "' + formatName(qname) + '" expects ' + formatFnArgs(fnInfo.args) + '.');
   			}

   			// Evaluate args
   			for(i=0; i<args.length; i++)
   			{
   				// Evaluate expression
   				val = evaluateExpressionTree(this, args[i]);

   				if (argTypes[i] !== 'object' && !val.canConvertTo(argTypes[i]))
   				{
   					// TODO-FUTURE: supported arg types should be checked during createExpression
   					throw new Error('Function "' + formatName(qname) + '" expects ' + formatFnArgs(fnInfo.args) + '.' +
   						'Cannot convert "' + val.type + '" to "' + argTypes[i] +'".' );
   				}

   				argVals.push(val);
   			}

   			result = fnInfo.fn.apply(this, argVals);

   			if (!result instanceof BaseType)
   			{
   				throw new Error('Function "' + formatName(qname) + '" did not return a value that inherits from BaseType.');
   			}
   			else if (fnInfo.ret !== 'object' && !result.canConvertTo(fnInfo.ret))
   			{
   				throw new Error('Function "' + formatName(qname) + '" return "' + result.type + '" type that cannot be converted to "' + fnInfo.ret + '".');
   			}

   			return result;
   		},

   		'|': function(left, right)
   		{
   			left = evaluateExpressionTree(this, left);
   			right = evaluateExpressionTree(this, right);

   			if (typeof left == 'undefined' ||
   				typeof right == 'undefined' ||
   				!left instanceof NodeSetType ||
   				!right instanceof NodeSetType)
   			{
   				throw new Error('Unable to perform union on non-"node-set" types.');
   			}

   			left.append(right);
   			return left;
   		},

   		/**
   		 * An or expression is evaluated by evaluating each operand and converting its value to a boolean
   		 * as if by a call to the boolean function. The result is true if either value is true and
   		 * false otherwise. The right operand is not evaluated if the left operand evaluates to true.
   		 *
   		 * @see http://www.w3.org/TR/xpath/#booleans
   		 * @return {BooleanType}
   		 */
   		or: function(left, right)
   		{
   			if (evaluateExpressionTree(this, left).toBoolean())
   			{
   				return new BooleanType(true);
   			}

   			return new BooleanType(evaluateExpressionTree(this, right).toBoolean());
   		},

   		/**
   		 * An and expression is evaluated by evaluating each operand and converting its value to a boolean
   		 * as if by a call to the boolean function. The result is true if both values are true and
   		 * false otherwise. The right operand is not evaluated if the left operand evaluates to false.
   		 *
   		 * @see http://www.w3.org/TR/xpath/#booleans
   		 * @return {BooleanType}
   		 */
   		and: function(left, right)
   		{
   			if (evaluateExpressionTree(this, left).toBoolean())
   			{
   				return new BooleanType(evaluateExpressionTree(this, right).toBoolean());
   			}

   			return new BooleanType(false);
   		},

   		'=': function(left, right)
   		{
   			return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '=', function(left, right) {
   				return left == right;
   			});
   		},

   		'!=': function(left, right)
   		{
   			return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '!=', function(left, right) {
   				return left != right;
   			});
   		},

   		'<=': function(left, right)
   		{
   			return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '<=', function(left, right) {
   				return left <= right;
   			});
   		},

   		'<': function(left, right)
   		{
   			return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '<', function(left, right) {
   				return left < right;
   			});
   		},

   		'>=': function(left, right)
   		{
   			return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '>=', function(left, right) {
   				return left >= right;
   			});
   		},

   		'>': function(left, right)
   		{
   			return compareOperator.call(this, evaluateExpressionTree(this, left), evaluateExpressionTree(this, right), '>', function(left, right) {
   				return left > right;
   			});
   		},

   		'+': function(left, right)
   		{
   			return new NumberType(
   				evaluateExpressionTree(this, left).toNumber()
   				+
   				evaluateExpressionTree(this, right).toNumber()
   			);
   		},

   		'-': function(left, right)
   		{
   			return new NumberType(
   				evaluateExpressionTree(this, left).toNumber()
   				-
   				evaluateExpressionTree(this, right).toNumber()
   			);
   		},

   		div: function(left, right)
   		{
   			return new NumberType(
   				evaluateExpressionTree(this, left).toNumber()
   				/
   				evaluateExpressionTree(this, right).toNumber()
   			);
   		},

   		mod: function(left, right)
   		{
   			return new NumberType(
   				evaluateExpressionTree(this, left).toNumber()
   				%
   				evaluateExpressionTree(this, right).toNumber()
   			);
   		},

   		'*': function(left, right)
   		{
   			return new NumberType(
   				evaluateExpressionTree(this, left).toNumber()
   				*
   				evaluateExpressionTree(this, right).toNumber()
   			);
   		},

   		/**
   		 * @param {String} string
   		 * @return {String}
   		 */
   		string: function(string)
   		{
   			return new StringType(string);
   		},

   		/**
   		 * @param {Number} number
   		 * @return {Number}
   		 */
   		number: function(number)
   		{
   			return new NumberType(number);
   		},

   		'$': function(name)
   		{
   			throw new Error("TODO: Not implemented.16");
   		},

   		/**
   		 * @param {String} ns
   		 * @param {String} name
   		 * @return {Object}
   		 */
   		name: function(prefix, name)
   		{
   			var ns = null;

   			if (prefix !== null)
   			{
   				ns = this.nsMap[prefix];
   				if (!ns)
   				{
   					throw new Error('Namespace prefix "' + prefix + '" is not mapped to a namespace.');
   				}
   			}

   			return {
   				ns: ns,
   				name: name
   			};
   		}
   	}

   	functions = {
   		/**
   		 * Core Function Library
   		 *
   		 * This section describes functions that XPath implementations must always include in the function library that is used to evaluate expressions.
   		 * Each function in the function library is specified using a function prototype, which gives the return type, the name of the function, and the type of the arguments. If an argument type is followed by a question mark, then the argument is optional; otherwise, the argument is required.
   		 */
   		'' : {
   			// Node Set Functions

   			last: {
   				/**
   				 * The last function returns a number equal to the context size from the expression evaluation context.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-last
   				 * @return {NumberType}
   				 */
   				fn: function()
   				{
   					return new NumberType(this.size);
   				},

   				ret: 'number'
   			},

   //			position: {
   //				/**
   //				 * The position function returns a number equal to the context position from the expression evaluation context.
   //				 *
   //				 * @see http://www.w3.org/TR/xpath/#function-position
   //				 * @return {NumberType}
   //				 */
   //				fn: function()
   //				{
   //					return new NumberType(this.pos);
   //				},
   //
   //				ret: 'number'
   //			},

   			count: {
   				/**
   				 * The count function returns the number of nodes in the argument node-set.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-count
   				 * @param {NodeSetType} nodeset
   				 * @return {NumberType}
   				 */
   				fn: function(nodeset)
   				{
   					return new NumberType(nodeset.toNodeSet().length);
   				},

   				args: [
   					{t: 'node-set'}
   				],

   				ret: 'number'
   			},

   			id: {
   				/**
   				 * The id function selects elements by their unique ID.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-id
   				 * @param {BaseType} object
   				 * @return {NodeSetType}
   				 */
   				fn: function(object)
   				{
   					var context = this,
   						ids = [],
   						i,
   						j,
   						node,
   						nodes = [],
   						value,
   						splitStringByWhitespace = function(str)
   						{
   							var i,
   								// split string by whitespace (#x20 | #x9 | #xD | #xA)+
   								chunks = str.split(/[\u0020\u0009\u000D\u000A]+/)
   							;

   							for(i = chunks.length - 1; i >= 0; i--)
   							{
   								// trim left/right
   								if (chunks[i].length == 0)
   								{
   									chunks.splice(i, 1);
   								}
   							}

   							return chunks;
   						}
   					;

   					if (object instanceof NodeSetType)
   					{
   						/**
   						 * When the argument to id is of type node-set, then the result is the
   						 * union of the result of applying id to the string-value of
   						 * each of the nodes in the argument node-set.
   						 */
   						for(i=0; i<object.value.length; i++)
   						{
   							ids.push.apply(ids, splitStringByWhitespace(nodeStringValue(object.value[i])));
   						}
   					}
   					else
   					{
   						/**
   						 * When the argument to id is of any other type, the argument is
   						 * converted to a string as if by a call to the string function
   						 */
   						object = object.toString();

   						/**
   						 * the string is split into a whitespace-separated list of tokens
   						 */

   						// split string by whitespace (#x20 | #x9 | #xD | #xA)+
   						ids = splitStringByWhitespace(object);
   					}

   					// remove duplicate ids
   					for(i=ids.length-1; i>=0; i--)
   					{
   						for(j=i-1; j >= 0; j--)
   						{
   							if (ids[i] == ids[j] && i != j)
   							{
   								ids.splice(i, 1);
   								break;
   							}
   						}
   					}

   					/**
   					 * the result is a node-set containing the elements in the same document
   					 * as the context node that have a unique ID equal to any of the tokens in the list.
   					 *
   					 * An element node may have a unique identifier (ID). This is the value of the
   					 * attribute that is declared in the DTD as type ID.
   					 */
   					for(i=0; i<ids.length; i++)
   					{
   						node = nodeOwnerDocument(this.node).getElementById(ids[i]);

   						if (node)
   						{
   							// ensure that this node does indeed have a valid id attibute in namespace scope
   							if (nodeIdAttribute.call(this, node))
   							{
   								nodes.push(node);
   								continue;
   							}
   						}

   						// node not found by id, need to search manually
   						nodeAttributeSearch(nodeOwnerDocument(this.node), true, function(element, attribute) {

   							var idAttribute = nodeIdAttribute.call(context, element, attribute);

   							if (idAttribute && idAttribute.nodeValue == ids[i])
   							{
   								nodes.push(element);
   								return true;
   							}
   						});
   					}

   					return new NodeSetType(nodes);
   				},

   				args: [
   					{}
   				],

   				ret: 'node-set'
   			},

   			'local-name': {
   				/**
   				 * The local-name function returns the local part of the expanded-name
   				 * of the node in the argument node-set that is first in document order.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-local-name
   				 * @param {NodeSetType} nodeset
   				 * @return {StringType}
   				 */
   				fn: function(nodeset)
   				{
   					var qname,
   						localName = ''
   					;

   					/**
   					 * If the argument is omitted, it defaults to a node-set with the context node as its only member.
   					 */
   					if (arguments.length == 0)
   					{
   						nodeset = new NodeSetType([this.node]);
   					}

   					/**
   					 * If the argument node-set is empty or the first node has no expanded-name, an empty string is returned.
   					 */
   					if (nodeset.toNodeSet().length > 0)
   					{
   						nodeset.sortDocumentOrder();
   						qname = nodeExpandedName.call(this, nodeset.value[0]);

   						if (qname !== false)
   						{
   							localName = qname.name;
   						}
   					}

   					return new StringType(localName);
   				},

   				args: [
   					{t: 'node-set', r: false}
   				],

   				ret: 'string'
   			},

   			'namespace-uri': {
   				/**
   				 * The namespace-uri function returns the namespace URI of the expanded-name
   				 * of the node in the argument node-set that is first in document order.
   				 *
   				 * The string returned by the namespace-uri function will be empty
   				 * except for element nodes and attribute nodes.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-namespace-uri
   				 * @param {NodeSetType} nodeset
   				 * @return {StringType}
   				 */
   				fn: function(nodeset)
   				{
   					var qname,
   						namespaceURI = ''
   					;

   					/**
   					 * If the argument is omitted, it defaults to a node-set with the context node as its only member.
   					 */
   					if (arguments.length == 0)
   					{
   						nodeset = new NodeSetType([this.node]);
   					}

   					/**
   					 * If the argument node-set is empty, the first node has no expanded-name,
   					 * or the namespace URI of the expanded-name is null, an empty string is returned.
   					 */
   					if (nodeset.toNodeSet().length > 0)
   					{
   						nodeset.sortDocumentOrder();
   						qname = nodeExpandedName.call(this, nodeset.value[0]);

   						if (qname !== false && qname.ns !== null)
   						{
   							namespaceURI = qname.ns;
   						}
   					}

   					return new StringType(namespaceURI);
   				},

   				args: [
   					{t: 'node-set', r: false}
   				],

   				ret: 'string'
   			},

   			name: {
   				/**
   				 * The name function returns a string containing a QName representing the expanded-name
   				 * of the node in the argument node-set that is first in document order.
   				 *
   				 * The string returned by the name function will be the same as the string returned
   				 * by the local-name function except for element nodes and attribute nodes.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-name
   				 * @param {NodeSetType} nodeset
   				 * @param {StringType}
   				 */
   				fn: function(nodeset)
   				{
   					var qname,
   						name = ''
   					;

   					/**
   					 * If the argument is omitted, it defaults to a node-set with the context node as its only member.
   					 */
   					if (arguments.length == 0)
   					{
   						nodeset = new NodeSetType([this.node]);
   					}

   					if (nodeset.toNodeSet().length > 0)
   					{
   						nodeset.sortDocumentOrder();
   						qname = nodeExpandedName.call(this, nodeset.value[0]);

   						if (qname !== false)
   						{
   							name = (qname.prefix && qname.prefix.length > 0)
   								? qname.prefix + ':' + qname.name
   								: qname.name
   							;
   						}
   					}

   					return new StringType(name);
   				},

   				args: [
   					{t: 'node-set', r: false}
   				],

   				ret: 'string'
   			},

   			// String functions

   			string: {
   				/**
   				 * The string function converts an object to a string.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-string
   				 * @param {BaseType} object
   				 * @return {StringType}
   				 */
   				fn: function(object)
   				{
   					/**
   					 * If the argument is omitted, it defaults to a node-set with the context node as its only member.
   					 */
   					if (arguments.length == 0)
   					{
   						object = new NodeSetType([this.node], 'document-order');
   					}

   					return new StringType(object.toString());
   				},

   				args: [
   					{t: 'object', r: false}
   				],

   				ret: 'string'
   			},

   			//native concat() was replaced with a javarosa-style concat() without breaking the native functionality
   			//concat: {
   			//	/**
   			//	 * The concat function returns the concatenation of its arguments.
   			//	 *
   			//	 * @see http://www.w3.org/TR/xpath/#function-concat
   			//	 * @param {StringType} str1
   			//	 * @param {StringType} str2
   			//	 * @return {StringType}
   			//	 */
   			//	fn: function(str1, str2 /*, str3 ... */)
   			//	{
   			//		var i,
   			//			value = ''
   			//		;
   			//
   			//		for(i=0; i < arguments.length; i++)
   			//		{
   			//			value += arguments[i].toString();
   			//		}
   			//
   			//		return new StringType(value);
   			//	},
   			//
   			//	args: [
   			//		{t: 'string'},
   			//		{t: 'string'},
   			//		{t: 'string', r: false, rep: true}
   			//	],
   			//
   			//	ret: 'string'
   			//},

   			'starts-with': {
   				/**
   				 * The starts-with function returns true if the first argument string
   				 * starts with the second argument string, and otherwise returns false.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-starts-with
   				 * @param {StringType} haystack
   				 * @param {StringType} needle
   				 * @return {StringType}
   				 */
   				fn: function(haystack, needle)
   				{
   					return new BooleanType(haystack.toString().substr(0, (needle = needle.toString()).length) == needle);
   				},

   				args: [
   					{t: 'string'},
   					{t: 'string'}
   				],

   				ret: 'string'
   			},

   			contains: {
   				/**
   				 * The contains function returns true if the first argument string
   				 * contains the second argument string, and otherwise returns false.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-contains
   				 * @param {StringType} haystack
   				 * @param {StringType} needle
   				 * @return {StringType}
   				 */
   				fn: function(haystack, needle)
   				{
   					return new BooleanType(haystack.toString().indexOf(needle = needle.toString()) != -1);
   				},

   				args: [
   					{t: 'string'},
   					{t: 'string'}
   				],

   				ret: 'string'
   			},

   			'substring-before': {
   				/**
   				 * The substring-before function returns the substring of the first argument
   				 * string that precedes the first occurrence of the second argument string
   				 * in the first argument string, or the empty string if the first argument
   				 * string does not contain the second argument string.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-substring-before
   				 * @param {StringType} haystack
   				 * @param {StringType} needle
   				 * @return {StringType}
   				 */
   				fn: function(haystack, needle)
   				{
   					haystack = haystack.toString();
   					needle = haystack.indexOf(needle.toString());
   					return new StringType(needle == -1 ?  '' : haystack.substr(0, needle));
   				},

   				args: [
   					{t: 'string'},
   					{t: 'string'}
   				],

   				ret: 'string'
   			},

   			'substring-after': {
   				/**
   				 * The substring-after function returns the substring of the first argument
   				 * string that follows the first occurrence of the second argument string
   				 * in the first argument string, or the empty string if the first argument
   				 * string does not contain the second argument string.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-substring-after
   				 * @param {StringType} haystack
   				 * @param {StringType} needle
   				 * @return {StringType}
   				 */
   				fn: function(haystack, needle)
   				{
   					var pos;

   					haystack = haystack.toString();
   					needle = needle.toString();
   					pos = haystack.indexOf(needle);

   					return new StringType(pos == -1 ?  '' : haystack.substr(pos + needle.length));
   				},

   				args: [
   					{t: 'string'},
   					{t: 'string'}
   				],

   				ret: 'string'
   			},

   			substring: {
   				/**
   				 * The substring function returns the substring of the first argument
   				 * starting at the position specified in the second argument
   				 * with length specified in the third argument.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-substring
   				 * @param {StringType} str
   				 * @param {NumberType} start
   				 * @param {NumberType} length
   				 * @return {StringType}
   				 */
   				fn: function(str, start, length)
   				{
   					str = str.toString();

   					start = Math.round(start.toNumber()) - 1;

   					return new StringType(
   						isNaN(start)
   							? ''
   							: ((arguments.length == 2)
   								? str.substring(start < 0 ? 0 : start)
   								: str.substring(start < 0 ? 0 : start, start + Math.round(length.toNumber()))
   							)
   					);
   				},

   				args: [
   					{t: 'string'},
   					{t: 'number'},
   					{t: 'number', r: false}
   				],

   				ret: 'string'
   			},

   			'string-length': {
   				/**
   				 * The string-length returns the number of characters in the string.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-string-length
   				 * @param {StringType} str
   				 * @return {NumberType}
   				 */
   				fn: function(str)
   				{
   					str = (arguments.length == 0)
   						? nodeStringValue(this.node)
   						: str.toString()
   					;
   					return new NumberType(str.length);
   				},

   				args: [
   					{t: 'string', r: false}
   				],

   				ret: 'number'
   			},

   			'normalize-space': {
   				/**
   				 * The normalize-space function returns the argument string with whitespace
   				 * normalized by stripping leading and trailing whitespace and replacing
   				 * sequences of whitespace characters by a single space.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-normalize-space
   				 * @param {StringType} str
   				 * @return {StringType}
   				 */
   				fn: function(str)
   				{
   					str = (arguments.length == 0)
   						? nodeStringValue(this.node)
   						: str.toString()
   					;
   					return new StringType(str.replace(/^[\u0020\u0009\u000D\u000A]+/,'').replace(/[\u0020\u0009\u000D\u000A]+$/,'').replace(/[\u0020\u0009\u000D\u000A]+/g, ' '));
   				},

   				args: [
   					{t: 'string', r: false}
   				],

   				ret: 'string'
   			},

   			translate: {
   				/**
   				 * The translate function returns the first argument string with occurrences
   				 * of characters in the second argument string replaced by the character
   				 * at the corresponding position in the third argument string.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-normalize-space
   				 * @param {StringType} haystack
   				 * @param {StringType} search
   				 * @param {StringType} replace
   				 * @return {StringType}
   				 */
   				fn: function(haystack, search, replace)
   				{
   					var result = '',
   						i,
   						j,
   						x
   					;

   					haystack = haystack.toString();
   					search = search.toString();
   					replace = replace.toString();

   					for(i = 0; i < haystack.length; i++)
   					{
   						if ((j = search.indexOf(x = haystack.charAt(i))) == -1 ||
   							(x = replace.charAt(j)))
   							result += x;
   					}

   					return new StringType(result);
   				},

   				args: [
   					{t: 'string'},
   					{t: 'string'},
   					{t: 'string'}
   				],

   				ret: 'string'
   			},

   			// Boolean Functions

   			'boolean': {
   				/**
   				 * The boolean function converts its argument to a boolean.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-boolean
   				 * @param {BaseType}
   				 * @return {BooleanType}
   				 */
   				fn: function(object)
   				{
   					return new BooleanType(object.toBoolean());
   				},

   				args: [
   					{r: true}
   				],

   				ret: 'boolean'
   			},

   			not: {
   				/**
   				 * The not function returns true if its argument is false, and false otherwise.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-not
   				 * @param {BooleanType}
   				 * @return {BooleanType}
   				 */
   				fn: function(bool)
   				{
   					return new BooleanType(!bool.toBoolean());
   				},

   				args: [
   					{t: 'boolean'}
   				],

   				ret: 'boolean'
   			},

   			'true': {
   				/**
   				 * The true function returns true.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-true
   				 * @return {BooleanType}
   				 */
   				fn: function()
   				{
   					return new BooleanType(true);
   				},

   				ret: 'boolean'
   			},

   			'false': {
   				/**
   				 * The false function returns false.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-false
   				 * @return {BooleanType}
   				 */
   				fn: function()
   				{
   					return new BooleanType(false);
   				},

   				ret: 'boolean'
   			},

   			/**
   			 * The lang function returns true or false depending on whether the language
   			 * of the context node as specified by xml:lang attributes is the same
   			 * as or is a sublanguage of the language specified by the argument string.
   			 *
   			 * @see http://www.w3.org/TR/xpath/#function-lang
   			 * @param {StringType}
   			 * @return {BooleanType}
   			 */
   			lang: {
   				fn: function(string)
   				{
   					var node = this.node,
   						attributes,
   						attributeName,
   						attributeValueParts,
   						langParts = string.toString().toLowerCase().split('-'),
   						namespaceNodes,
   						i,
   						j,
   						partsEqual
   					;

   					for(;node.nodeType != 9; node = nodeParent(node)) // document node
   					{
   						attributes = nodeAttribute(node);

   						for(i = 0; i < attributes.length; i++)
   						{
   							// parse attribute name and namespace prefix
   							attributeName = attributes[i].nodeName.split(':');
   							if (attributeName.length === 1)
   							{
   								// set default namespace
   								attributeName[1] = attributeName[0];
   								attributeName[0] = '';
   							}

   							// compare attribute name
   							if (attributeName[1] == 'lang')
   							{
   								attributeValueParts = attributes[i].nodeValue.toLowerCase().split('-');

   								if (attributeValueParts.length < langParts.length)
   									continue;

   								// compare attribute value
   								partsEqual = true;
   								for(j=0; j < langParts.length; j++)
   								{
   									if (langParts[j] != attributeValueParts[j])
   									{
   										partsEqual = false;
   										break;
   									}
   								}

   								if (partsEqual)
   								{
   									// ensure xml namespace
   									namespaceNodes = nodeNamespace.call(this, node);

   									for(j=0; j < namespaceNodes.length; j++)
   									{
   										if(namespaceNodes[j].prefix == attributeName[0]
   											&& namespaceNodes[j].nodeValue == NAMESPACE_URI_XML)
   										{
   											return new BooleanType(true);
   										}
   									}
   								}
   							}
   						}
   					}

   					return new BooleanType(false);
   				},

   				args: [
   					{t: 'string'}
   				],

   				ret: 'boolean'
   			},

   			// Number Functions

   			number: {
   				/**
   				 * The number function converts its argument to a number.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-number
   				 * @param {BaseType} object
   				 * @return {NumberType}
   				 */
   				fn: function(object)
   				{
   					/**
   					 * If the argument is omitted, it defaults to a node-set with the context node as its only member.
   					 */
   					if (arguments.length == 0)
   					{
   						object = new NodeSetType([this.node], 'document-order');
   					}

   					return new NumberType(object.toNumber());
   				},

   				args: [
   					{t: 'object', r: false}
   				],

   				ret: 'number'
   			},

   			sum: {
   				/**
   				 * The sum function returns the sum, for each node in the argument node-set,
   				 * of the result of converting the string-values of the node to a number.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-sum
   				 * @param {NodeSetType}
   				 * @return {NumberType}
   				 */
   				fn: function(nodeset)
   				{
   					var i,
   						sum = 0;
   					;

   					nodeset = nodeset.toNodeSet();

   					for(i = 0; i < nodeset.length; i++)
   					{
   						sum += (new StringType(nodeStringValue(nodeset[i]))).toNumber();
   					}

   					return new NumberType(sum);
   				},

   				args: [
   					{t: 'node-set'}
   				],

   				ret: 'number'
   			},

   			floor: {
   				/**
   				 * The floor function returns the largest (closest to positive infinity)
   				 * number that is not greater than the argument and that is an integer.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-floor
   				 * @param {NumberType}
   				 * @return {NumberType}
   				 */
   				fn: function(number)
   				{
   					return new NumberType(Math.floor(number));
   				},

   				args: [
   					{t: 'number'}
   				],

   				ret: 'number'
   			},

   			ceiling: {
   				/**
   				 * The ceiling function returns the smallest (closest to negative infinity)
   				 * number that is not less than the argument and that is an integer.
   				 *
   				 * @see http://www.w3.org/TR/xpath/#function-ceiling
   				 * @param {NumberType}
   				 * @return {NumberType}
   				 */
   				fn: function(number)
   				{
   					return new NumberType(Math.ceil(number));
   				},

   				args: [
   					{t: 'number'}
   				],

   				ret: 'number'
   			},

   			//Native round() function is overwritten with a custom javarosa round()
   			//round: {
   			//	/**
   			//	 * The round function returns the number that is closest
   			//	 * to the argument and that is an integer.
   			//	 *
   			//	 * @see http://www.w3.org/TR/xpath/#function-round
   			//	 * @param {NumberType}
   			//	 * @return {NumberType}
   			//	 */
   			//	fn: function(number)
   			//	{
   			//		return new NumberType(Math.round(number));
   			//	},
   			//
   			//	args: [
   			//		{t: 'number'}
   			//	],
   			//
   			//	ret: 'number'
   			//},

   			/********************************************************************/
   			/**** OpenRosa-specific XPath functions (or XPath 2.0 functions) ****/
   			/********************************************************************/

   			'count-non-empty': {
   				/**
   				 * The count-non-empty function returns the number of non-empty nodes in argument node-set.
   				 * A node is considered non-empty if it is convertible into a string with a greater-than zero length.
   				 *
   				 * @see https://www.w3.org/TR/2003/REC-xforms-20031014/slice7.html#fn-count-non-empty
   				 * @param {NodeSetType} nodeset
   				 * @return {NumberType}
   				 */
   				fn: function(nodeset)
   				{
   					var i;
   					var count=0;

   					nodeset = nodeset.toNodeSet();

   					for ( i=0 ; i < nodeset.length ; i++){
   						if ((new StringType(nodeStringValue(nodeset[i]))).toString().length > 0) {
   							count++;
   						}
   					}

   					return new NumberType(count);
   				},

   				args: [
   					{t: 'node-set'}
   				],

   				ret: 'number'
   			},

   			position: {
   				/**
   				 * Hacked OpenRosa function to return the position of a nodeset argument
   				 * the native position function accepts no arguments and always returns one.
   				 *
   				 * This should not break proper XPath functioning with /path/to/node[position() < 3],
   				 * but this is not supported in JavaRosa anyway.
   				 *
   				 * Note that these are actually two different functions into one...
   				 *
   				 * @param {NodeSetType?} node
   				 * @return {NumberType}
   				 */
   				fn: function(nodeset)
   				{

   					// this is the JavaRosa behaviour
   					if (nodeset) {
   						var node, nodeName, position;

   						nodeset = nodeset.toNodeSet();

   						if (nodeset.length === 1) {
   							node = nodeset[0];
   							position = 1;
   							nodeName = node.tagName;

   							while (node.previousElementSibling && node.previousElementSibling.tagName === nodeName) {
   								node = node.previousElementSibling;
   								position++;
   							}

   							return new NumberType(position);
   						} else {
   							throw new Error('nodeset provided to position() contained multiple nodes');
   						}
   					}
   					// this is the native XPath behaviour
   					return new NumberType(this.pos);
   				},

   				args: [
   					{t: 'node-set', r: false}
   				],

   				ret: 'number'
   			},

   			concat: {
   				/**
   				 * The concat function returns the concatenation of its arguments. This function
   				 * goes beyond the XPath Native function by also accepting only 1 argument as well
   				 * as node-set arguments that contain multiple nodes
   				 *
   				 * @see https://bitbucket.org/m.sundt/javarosa/src/62409ae3b803/core/src/org/javarosa/xpath/expr/XPathFuncExpr.java#cl-129
   				 * @param {Object} o1
   				 * @return {StringType}
   				 */
   				fn: function(o1 /*, o2 ... */)
   				{
   					var i, add,
   						value = '';

   					for(i=0; i < arguments.length; i++)
   					{
   						if (arguments[i] instanceof NodeSetType)
   						{
   							add = arguments[i].stringValues().join('');
   						}
   						else
   						{
   							add = arguments[i].toString();
   						}

   						value += add;
   					}

   					return new StringType(value);
   				},

   				args: [
   					{t: 'object', r:false, rep: true}
   				],

   				ret: 'string'
   			},

   			round: {
   				/**
   				 * The round function returns the number rounded to the amount of desired decimal places
   				 * or nearest integer if the decimal places argument is not provided. The latter is the
   				 * same behaviour of the native round().
   				 *
   				 * @see http://opendatakit.org/help/form-design/binding/
   				 * @param {NumberType} number
   				 * @param {NumberType} decimals [description]
   				 * @return {NumberType}
   				 */
   				fn: function(number, decimals)
   				{
   					decimals = Math.round(decimals) || 0;
   					return new NumberType(Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals));
   				},

   				args: [
   					{t: 'number'},
   					{t: 'number', r: false}
   				],

   				ret: 'number'
   			},

   			selected: {
   				/**
   				 * The selected function returns true or false if the argument
   				 * is included in the space-separated list of selected multiselect values
   				 *
   				 * @see https://bitbucket.org/javarosa/javarosa/wiki/xform-jr-compat
   				 * @param {Object} object
   				 * @param {StringType} value
   				 * @return {BooleanType}
   				 *
   				 */
   				fn: function(node, value)
   				{
   					var i, values;

   					value = value.toString().trim();
   					values = node.toString();

   					return new BooleanType( (" "+values+" ").indexOf(" "+value+" ") != -1 );
   				},

   				args: [
   					{t: 'object'},
   					{t: 'string'}
   				],

   				ret: 'boolean'
   			},

   			"selected-at" : {

   				fn: function(node, position)
   				{
   					var value, values, selectValue;

   					position = Math.round(position.toNumber());
   					value = node.toString();
   					values = value.split(' ');
   					selectValue = (position >= 0 && position < values.length) ? values[position] : '';

   					return new StringType(selectValue);
   				},

   				args: [
   					{t: 'object'},
   					{t: 'number'}
   				],

   				ret: 'string'

   			},

   			'count-selected': {
   				/**
   				 * The count-selected function returns the number of multiselect values currently selected
   				 *
   				 * @see https://bitbucket.org/javarosa/javarosa/wiki/xform-jr-compat
   				 * @param {NodeSetType} nodeset
   				 * @return {NumberType}
   				 *
   				 */
   				fn: function(nodeset)
   				{
   					var values = [];

   					nodeset = nodeset.toNodeSet();

   					if (nodeset.length > 0){

   						//only value of first node
   						values = nodeStringValue(nodeset[0]).trim().split(' ');
   						//return new Number(1);
   						return (values.length == 1 && values[0] === "") ? new NumberType(0) : new NumberType(values.length);
   					}

   					return new NumberType(0);
   				},

   				args: [
   					{t: 'node-set'}
   				],

   				ret: 'number'
   			},

   			checklist: {
   				/**
   				 * The checklist function returns true if the amount of 'yes' answers (take as true())
   				 * is between min and max inclusive. Min or max may be -1 to indicate 'not applicable'.
   				 *
   				 * @see http://opendatakit.org/help/form-design/binding/
   				 * @param {NumberType} min
   				 * @param {NumberType} max
   				 * @param {BaseType} oA, oB, oC etc...
   				 * @return {BooleanType}
   				 *
   				 */

   				fn: function(min, max, oA /*, oB .... */)
   				{
   					var i, j,
   						trues = 0
   					;
   					min = min.toNumber();
   					max = max.toNumber();

   					for (i=2 ; i<arguments.length ; i++)
   					{
   						if (arguments[i] instanceof NodeSetType)
   						{
   							for (j=0; j<arguments[i].stringValues().length ; j++)
   							{
   								if (arguments[i].stringValues()[j].toBoolean() === true)
   								{
   									trues++;
   								}
   							}
   						}
   						else if (arguments[i].toBoolean() === true)
   						{
   							trues++;
   						}
   					}

   					return new BooleanType((min < 0 || trues >= min) && (max < 0 || trues <= max));
   				},

   				args: [
   					{t: 'number'},
   					{t: 'number'},
   					{t: 'object'},
   					{t: 'object', r: false, rep: true}
   				],

   				ret: 'boolean'
   			},

   			'weighted-checklist': {
   				/**
   				 * The weighted-checklist function returns true if the amount of 'yes' answers (take as true())
   				 * multiplied by each weight, is between min and max inclusive.
   				 * Min or max may be -1 to indicate 'not applicable'.
   				 *
   				 * @see http://opendatakit.org/help/form-design/binding/
   				 * @param {NumberType} min
   				 * @param {NumberType} max
   				 * @param {BaseType} vA, vB, vC etc...
   				 * @return {BooleanType}
   				 *
   				 */

   				fn: function(min, max, vA, wA /*, vB , wB.... */)
   				{
   					var i, j,
   						values = [],
   						weights = [],
   						weightedTrues = 0;

   					min = min.toNumber();
   					max = max.toNumber();

   					for (i=2 ; i < arguments.length ; i=i+2)
   					{
   						v = arguments[i];
   						w = arguments[i+1];
   						if (v && w)
   						{
   							if (v instanceof NodeSetType)
   							{
   								values = values.concat(v.stringValues());
   							}
   							else
   							{
   								values.push(v);
   							}
   							if (w instanceof NodeSetType)
   							{
   								weights = weights.concat(w.stringValues());
   							}
   							else
   							{
   								weights.push(w);
   							}
   						}
   					}

   					for (i=0 ; i < values.length ; i++)
   					{
   						if (values[i].toBoolean() === true)
   						{
   							weightedTrues += weights[i].toNumber();
   						}
   					}

   					return new BooleanType((min < 0 || weightedTrues >= min) && (max < 0 || weightedTrues <= max));
   				},

   				args: [
   					{t: 'number'},
   					{t: 'number'},
   					{t: 'object'},
   					{t: 'object'},
   					{t: 'object', r: false, rep: true}
   				],

   				ret: 'boolean'
   			},

   			'boolean-from-string': {
   				/**
   				 * The boolean-from-string function returns true if the string is 'true' or '1'.
   				 * Note that a number is cast to a string.
   				 *
   				 * @see http://opendatakit.org/help/form-design/binding/
   				 * @param {StrType} str
   				 * @return {BooleanType}
   				 *
   				 */
   				fn: function(str)
   				{
   					return new BooleanType(str.toString().toLowerCase() === 'true' || String(str) === '1');
   				},

   				args: [
   					{t: 'string'}
   				],

   				ret: 'boolean'
   			},

   			'if': {

   				fn: function(cond, a, b)
   				{
   					return ( cond.toBoolean() ? a : b );
   				},

   				args: [
   					{t: 'object'},
   					{t: 'object'},
   					{t: 'object'}
   				],

   				ret: 'object'

   			},

   			'date': {

   				fn: function(obj)
   				{
   					return new DateType(obj.toDate());
   				},

   				args: [
   					{t: 'object'}
   				],

   				ret: 'string'
   			},

   			/**
   			 * Alias of "date"
   			 * Note: Javarosa makes a distinction between date and date-time() in that
   			 * time is removed from date(). We have to do that too, but all date() tests pass.
   			 */
   			'date-time': {

   				fn: function(obj)
   				{
   					return new DateType(obj.toDate());
   				},

   				args: [
   					{t: 'object'}
   				],

   				ret: 'string'
   			},

   			/* Alias of "date-time"
   			 * Not 100% sure this is correct, but I think the behaviour will match ODK's behaviour.
   			 */
   			'decimal-date-time': {

   				fn: function(obj)
   				{
   					return new DateType(obj.toDate());
   				},

   				args: [
   					{t: 'object'}
   				],

   				ret: 'string'
   			},

   			today: {

   				fn: function()
   				{
   					var today = new Date();
   					return new DateType(new Date(today.getFullYear(), today.getMonth(), today.getDate()));
   				},

   				ret: 'string'
   			},

   			now: {
   				/**
   				 * The now function returns the date in seconds between now and the epoch.
   				 *
   				 * @see https://bitbucket.org/javarosa/javarosa/wiki/xform-jr-compat
   				 * @return {NumberType}
   				 *
   				 */

   				fn: function()
   				{
   					return new DateType(new Date());
   				},

   				ret: 'string'
   			},

   			regex: {
   				/**
   				 * The regex function evaluates a regular expression and returns true or false.
   				 *
   				 * @see https://bitbucket.org/javarosa/javarosa/wiki/xform-jr-compat
   				 * @return {BooleanType}
   				 *
   				 */
   				fn: function(obj, expr)
   				{
   					var value, patt;

   					value = obj.toString();

   					patt = new RegExp(expr);

   					return new BooleanType(patt.test(value));
   				},

   				args: [
   					{t: 'object'},
   					{t: 'string'}
   				],

   				ret: 'boolean'

   			},

   			uuid: {
   				/**
   				 * The uuid function returns an RFC 4122 Version 4 UUID string.
   				 *
   				 * @see http://opendatakit.org/help/form-design/binding/
   				 * @return {StringType}
   				 *
   				 */
   				fn: function()
   				{
   					//from broofa: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
   					var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
   						var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
   						return v.toString(16);
   					});
   					return new StringType(uuid);
   				},

   				ret: 'string'
   			},

   			'int': {
   				/**
   				 * The int function turns a parameter into a number and truncates the fractional part
   				 *
   				 * @see http://opendatakit.org/help/form-design/binding/
   				 * @return {NumberType}
   				 *
   				 */
   				fn: function(str)
   				{
   					// Using ParseInt, creates a problem for very small or large numbers that are displayed in scientific
   					// notation. E.g. parseInt(1/47999799999, 10) is 2 instead of 0 (2.08e-11)
   					return new NumberType( ( str.toNumber() >= 0 ) ? Math.floor( str.toNumber() ) : -Math.floor( Math.abs( str.toNumber() ) ) );
   				},
   				args: [
   					{t: 'string'}
   				],

   				ret: 'number'
   			},

   			substr: {
   				/**
   				 * The substr function returns the substring of the first argument
   				 * starting at the position specified in the second argument
   				 * with end character position specified in the third argument.
   				 *
   				 * THE DIFFERENCE WITH THE XPATH 1.0 NATIVE FUNCTION IS THAT POSITIONS ARE 0-BASED HERE,
   				 * THE LENGTH IS GIVEN AS A CHARACTER POSITION (END) AND NEGATIVE VALUES ARE DEALT WITH
   				 * DIFFERENTLY
   				 *
   				 * @see http://opendatakit.org/help/form-design/binding/
   				 * @param {StringType} str
   				 * @param {NumberType} start
   				 * @param {NumberType} end
   				 * @return {StringType}
   				 */
   				fn: function(str, start, end)
   				{
   					str = str.toString();
   					length = str.length;

   					start = Math.round(start.toNumber());
   					end = (end) ? Math.round(end.toNumber()) : length;

   					return new StringType(
   						isNaN(start)
   							? ''
   							: str.substring( start < 0 ? length + start : start, end < 0 ? length + end : end )
   					);
   				},

   				args: [
   					{t: 'string'},
   					{t: 'number'},
   					{t: 'number', r: false}
   				],

   				ret: 'string'
   			},

   			random: {
   				/**
   				 * The random function returns a random number between 0.0 (inclusive) and 1.0 (exclusive).
   				 *
   				 * @see http://opendatakit.org/help/form-design/binding/
   				 * @return {NumberType}
   				 */
   				fn: function()
   				{

   					return new NumberType(Math.random().toFixed(15))

   				},

   				ret: 'number'
   			},

   			min: {
   				/**
   				 * The min function returns the smallest values in the argument node-sets,
   				 * of the result of converting the string-values of the nodes to a number.
   				 *
   				 * A slight improvement over JavaRosa is that each argument can be a nodeset
   				 *
   				 * @see http://opendatakit.org/help/form-design/binding/
   				 * @param {BaseType} object1
   				 * @param {BaseType} object2
   				 * @return {NumberType}
   				 */
   				fn: function(object1, object2 /*, object3 ... */)
   				{
   					var i, j, min, val, nodeset;

   					for (i = 0; i < arguments.length; i++)
   					{

   						if (arguments[i] instanceof NodeSetType ){

   							nodeset = arguments[i].toNodeSet();

   							for(j = 0; j < nodeset.length; j++)
   							{
   								val = new StringType(nodeStringValue(nodeset[j]));
   								if (val)
   								{
   									min = (min) ? Math.min(min, val.toNumber()) : val.toNumber();
   								}
   							}
   						}
   						else
   						{
   							val = new StringType(arguments[i].toString());
   							if (val)
   							{
   								min = (min) ? Math.min(min, val.toNumber()) : val.toNumber();
   							}
   						}
   					}

   					return new NumberType(min);
   				},

   				args: [
   					{t: 'object'},
   					{t: 'object', r: false, rep: true}
   				],

   				ret: 'number'
   			},

   			max: {
   				/**
   				 * The max function returns the largest value in the argument node-sets,
   				 * of the result of converting the string-values of the nodes to a number.
   				 *
   				 * A slight improvement over JavaRosa is that each argument can be a nodeset
   				 *
   				 * @see http://opendatakit.org/help/form-design/binding/
   				 * @param {BaseType}  object1
   				 * @param {BaseType}  object2
   				 * @return {NumberType}
   				 */
   				fn: function(object1, object2 /* object3 ... */)
   				{
   					var i, j, max, val, nodeset;

   					for (i = 0; i < arguments.length; i++)
   					{
   						if (arguments[i] instanceof NodeSetType ){

   							nodeset = arguments[i].toNodeSet();

   							for(j = 0; j < nodeset.length; j++)
   							{
   								val = new StringType(nodeStringValue(nodeset[j]));
   								if (val)
   								{
   									max = (max) ? Math.max(max, val.toNumber()) : val.toNumber();
   								}
   							}
   						}
   						else {
   							val = new StringType(arguments[i].toString());
   							if (val)
   							{
   								max = (max) ? Math.max(max, val.toNumber()) : val.toNumber();
   							}
   						}

   					}

   					return new NumberType(max);
   				},

   				args: [
   					{t: 'object'},
   					{t: 'object', r: false, rep: true}
   				],

   				ret: 'number'
   			},

   			join: {
   				/**
   				 * The join function returns the concatenation of arguments, separated by the
   				 * first argument string.
   				 *
   				 * @see http://opendatakit.org/help/form-design/binding/
   				 * @param {StringType} str1
   				 * @param {Object} obj1
   				 * @return {StringType}
   				 */
   				fn: function(str1, obj1 /*, obj2 ... */)
   				{
   					var i,
   						values = []
   					;

   					for (i=1; i < arguments.length; i++)
   					{
   						if (arguments[i] instanceof NodeSetType){
   							values = values.concat(arguments[i].stringValues());
   						}
   						else{
   							values.push(arguments[i].toString());
   						}
   					}

   					value = values[0] || '';

   					for (i = 1; i < values.length; i++ )
   					{
   						value += str1.toString() + values[i];
   					}

   					return new StringType(value);
   				},

   				args: [
   					{t: 'string'},
   					{t: 'object', r: false, rep: true}
   				],

   				ret: 'string'
   			},

   			/**
   			 * The coalesce function returns the first non-empty value for the two
   			 * arguments provided.
   			 *
   			 * @see http://opendatakit.org/help/form-design/binding/
   			 * @param {Object} a
   			 * @param {Object} b
   			 * @return {StringType}
   			 */
   			coalesce : {

   				fn: function(a, b)
   				{
   					return ( a.toString().length > 0 ) ? a : b ;
   				},

   				args: [
   					{t: 'object'},
   					{t: 'object'}
   				],

   				ret: 'string'

   			},

   			/**
   			 * The date-format function returns the first non-empty value for the two
   			 * arguments provided. It returns date properties in the LOCAL timezone.
   			 * TODO: check how ODK Collect deals with timezones
   			 *
   			 * @see http://opendatakit.org/help/form-design/binding/
   			 * @param {Object} a
   			 * @param {Object} b
   			 * @return {StringType}
   			 */
   			'format-date' : {

   				fn: function(dateO, format)
   				{
   					var i,j,
   						dateO = new DateType(dateO), //not sure why this did not happen automatically
   						date = dateO.toDate(),
   						result = format.toString(),
   						intPad = function(num, l)
   						{
   							var str = num.toString(),
   								zeros = l - str.length;
   							for (j=0 ; j < zeros ; j++)
   							{
   								str = '0'+str;
   							}
   							return str;
   						};
   					var locale = window ? window.enketoFormLocale : undefined;

   					if (!dateO.toBoolean())
   					{
   						return new StringType(date.toString());
   					}

   					props = {
   						'Y'	: date.getFullYear(),
   						'y'	: date.getFullYear().toString().substring(2,4),
   						'm'	: intPad((date.getMonth()+1), 2),
   						'n'	: date.getMonth()+1,
   						'b'	: date.toLocaleDateString( locale, { month: 'short' } ),
   						'd'	: intPad(date.getDate(), 2),
   						'e'	: date.getDate(),
   						'H'	: intPad(date.getHours(), 2),
   						'h'	: date.getHours(),
   						'M'	: intPad(date.getMinutes(), 2),
   						'S'	: intPad(date.getSeconds(), 2),
   						'3'	: intPad(date.getMilliseconds(), 3),
   						'a'	: date.toLocaleDateString( locale, { weekday: 'short' } )
   					}

   					for (prop in props)
   					{
   						result = result.replace('%'+prop, props[prop]);
   					}

   					return new StringType(result);
   				},

   				args: [
   					{t: 'date'},
   					{t: 'string'}
   				],

   				ret: 'string'

   			},

   			/**
   			 * The pow function returns exponentiated result
   			 * arguments provided.
   			 *
   			 * @see temporary: https://bitbucket.org/m.sundt/javarosa/pull-request/2/adding-pow-support/diff
   			 * @param {NumberType} a
   			 * @param {NumberType} b
   			 * @return {NumberType}
   			 */
   			pow : {

   				fn: function(a, b)
   				{
   					return new NumberType( Math.pow(a, b) ) ;
   				},

   				args: [
   					{t: 'number'},
   					{t: 'number'}
   				],

   				ret: 'number'

   			},


   			/**
   			 * The sin function returns the sine of the argument, expressed in radians.
   			 *
   			 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-sin
   			 * @param {NumberType} a
   			 * @return {NumberType}
   			 */
   			sin : {

   				fn: function(a)
   				{
   					return new NumberType( Math.sin(a) ) ;
   				},

   				args: [
   					{t: 'number'}
   				],

   				ret: 'number'
   			},


   			/**
   			 * The cos function returns the cosine of the argument, expressed in radians.
   			 *
   			 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-cos
   			 * @param {NumberType} a
   			 * @return {NumberType}
   			 */
   			cos : {

   				fn: function(a)
   				{
   					return new NumberType( Math.cos(a) ) ;
   				},

   				args: [
   					{t: 'number'}
   				],

   				ret: 'number'
   			},

   			/**
   			 * The tan function returns the tangent of the argument, expressed in radians.
   			 *
   			 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-tan
   			 * @param {NumberType} a
   			 * @return {NumberType}
   			 */
   			tan : {

   				fn: function(a)
   				{
   					return new NumberType( Math.tan(a) ) ;
   				},

   				args: [
   					{t: 'number'}
   				],

   				ret: 'number'
   			},


   			/**
   			 * The acos function returns the arc cosine of the argument, the result being in the range zero to + radians.
   			 *
   			 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-acos
   			 * @param {NumberType} a
   			 * @return {NumberType}
   			 */
   			acos : {

   				fn: function(a)
   				{
   					return new NumberType( Math.acos(a) ) ;
   				},

   				args: [
   					{t: 'number'}
   				],

   				ret: 'number'
   			},

   			/**
   			 * The asin function returns the arc sine of the argument, the result being in the range -/2 to +/2 radians.
   			 *
   			 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-asin
   			 * @param {NumberType} a
   			 * @return {NumberType}
   			 */
   			asin : {

   				fn: function(a)
   				{
   					return new NumberType( Math.asin(a) ) ;
   				},

   				args: [
   					{t: 'number'}
   				],

   				ret: 'number'
   			},


   			/**
   			 * The atan function returns the arc tangent of the argument, the result being in the range -/2 to +/2 radians.
   			 *
   			 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-atan
   			 * @param {NumberType} a
   			 * @return {NumberType}
   			 */
   			atan : {

   				fn: function(a)
   				{
   					return new NumberType( Math.atan(a) ) ;
   				},

   				args: [
   					{t: 'number'}
   				],

   				ret: 'number'
   			},

   			/**
   			 * The atan2 function returns the angle in radians subtended at the origin by the point on a plane
   			 * with coordinates (x, y) and the positive x-axis, the result being in the range - to +.
   			 *
   			 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-atan2
   			 * @param {NumberType} a
   			 * @param {NumberType} b
   			 * @return {NumberType}
   			 */
   			atan2 : {

   				fn: function(a, b)
   				{
   					return new NumberType( Math.atan2(a, b) ) ;
   				},

   				args: [
   					{t: 'number'},
   					{t: 'number'}
   				],

   				ret: 'number'
   			},

   			/**
   			 * The log10 function returns the base-ten logarithm of the argument.
   			 *
   			 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-log10
   			 * @param {NumberType} a
   			 * @return {NumberType}
   			 */
   			log10 : {

   				fn: function(a)
   				{
   					// Math.log10 doesn't have cross-browser support. The polyfill has a smallrounding error.
   					if (typeof Math.log10 !== 'undefined'){
   						return new NumberType( Math.log10(a) );
   					} else {
   						return new NumberType( Math.log(a) / Math.LN10 ) ;
   					}
   				},

   				args: [
   					{t: 'number'}
   				],

   				ret: 'number'
   			},

   			/**
   			 * The log function returns the natural logarithm of the argument.
   			 *
   			 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-log
   			 * @param {NumberType} a
   			 * @return {NumberType}
   			 */
   			log : {

   				fn: function(a)
   				{
   					return new NumberType( Math.log(a) ) ;
   				},

   				args: [
   					{t: 'number'}
   				],

   				ret: 'number'
   			},

   			/**
   			 * The pi function returns an approximation to the mathematical constant .
   			 *
   			 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-pi
   			 * @return {NumberType}
   			 */
   			pi : {

   				fn: function()
   				{
   					return new NumberType( Math.PI ) ;
   				},

   				args: [],

   				ret: 'number'
   			},

   			/**
   			 * The exp function returns the value of e^x.
   			 *
   			 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-exp
   			 * @param {NumberType} a
   			 * @return {NumberType}
   			 */
   			exp : {

   				fn: function(a)
   				{
   					return new NumberType( Math.exp(a) ) ;
   				},

   				args: [
   					{t: 'number'}
   				],

   				ret: 'number'
   			},


   			/**
   			 * The exp10 function returns the value of 10^x.
   			 *
   			 * @see https://www.w3.org/TR/xpath-functions-30/#func-math-exp10
   			 * @param {NumberType} a
   			 * @return {NumberType}
   			 */
   			exp10 : {

   				fn: function(a)
   				{
   					return new NumberType( Math.pow(10, a) ) ;
   				},

   				args: [
   					{t: 'number'}
   				],

   				ret: 'number'
   			},

   			/**
   			 * The sqrt function returns the non-negative square root of the argument.
   			 *
   			 * @see https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/#func-math-sqrt
   			 * @param {NumberType} a
   			 * @return {NumberType}
   			 */
   			sqrt : {

   				fn: function(a)
   				{
   					return new NumberType( Math.sqrt(a) ) ;
   				},

   				args: [
   					{t: 'number'}
   				],

   				ret: 'number'
   			},

   			/**
   			 * The version function returns the value of the version attribute of the root element
   			 *
   			 * @return {StringType}
   			 */
   			version : {

   				fn: function()
   				{
   					var root = (this.node.nodeName === '#document') ? this.node.documentElement : this.node.ownerDocument.documentElement,
   						versionAttr = root.attributes['version'];

   					if( versionAttr ) {
   						return new StringType(versionAttr.textContent);
   					}
   					return new StringType('');
   				},

   				args: [],

   				ret: 'string'

   			},

   			/**
   			 * The once function returns the value of the parameter if its own value
   			 * is not empty, NaN, [Infinity or -Infinity]. The naming is therefore misleading!
   			 * Also note that the parameter expr is always evaluated.
   			 * This function simply decides whether to return the new result or the old value.
   			 *
   			 * @return {StringType}
   			 */
   			once : {

   				fn: function(a)
   				{
   					var curValue = nodeStringValue(this.node),
   						newValue = a.toString();

   					// disable NaN, Infinity and -Infinity...
   					newValue = (newValue === 'NaN' /*|| newValue === 'Infinity' || newValue === '-Infinity'*/) ? "" : newValue;

   					return (curValue !== "") ? new StringType(curValue) : new StringType(newValue);
   				},

   				args: [
   					{t: 'string'}
   				],

   				ret: 'string'

   			},

   			/**
   			 * The area function returns the area in m2 of a single geoshape
   			 * value, or of a nodeset of ordered geopoints.
   			 *
   			 * @return {NumberType}
   			 */
   			"area" : {

   				fn: function(a)
   				{
   					var area, allValid,
   						geopoints = [],
   						latLngs = [];

   					if (a instanceof NodeSetType && a.value.length > 1){
   						a.value.forEach(function(node){
   							geopoints.push(nodeStringValue(node));
   						});
   					} else if (a instanceof NodeSetType) {
   						geopoints = nodeStringValue(a.value[0]).split(';');
   					} else if (a instanceof StringType) {
   						geopoints = a.value.split(';');
   					}

   					latLngs = geopoints.map(function(geopoint){
   						return geopoint.trim().split(' ');
   					});

   					// check if all geopoints are valid (copied from Enketo FormModel)
   					allValid = latLngs.every(function(coords){
   						return (
   							(coords[ 0 ] !== '' && coords[ 0 ] >= -90 && coords[ 0 ] <= 90 ) &&
   							( coords[ 1 ] !== '' && coords[ 1 ] >= -180 && coords[ 1 ] <= 180 ) &&
   							( typeof coords[ 2 ] == 'undefined' || !isNaN( coords[ 2 ] ) ) &&
   							( typeof coords[ 3 ] == 'undefined' || ( !isNaN( coords[ 3 ] ) && coords[ 3 ] >= 0 ) )
   							);
   					});

   					if (!allValid) {
   						area = Number.NaN;
   					} else {
   						var EARTH_RADIUS = 6378100,
   							pointsCount = latLngs.length,
   							d2r = Math.PI / 180,
   							p1, p2;
   							area = 0.0;

   						if ( pointsCount > 2 ) {
   							for ( var i = 0; i < pointsCount; i++ ) {
   								p1 = {
   									lat: latLngs[ i ][ 0 ],
   									lng: latLngs[ i ][ 1 ]
   								};
   								p2 = {
   									lat: latLngs[ ( i + 1 ) % pointsCount ][ 0 ],
   									lng: latLngs[ ( i + 1 ) % pointsCount ][ 1 ]
   								};
   								area += ( ( p2.lng - p1.lng ) * d2r ) *
   									( 2 + Math.sin( p1.lat * d2r ) + Math.sin( p2.lat * d2r ) );
   							}
   							area = area * EARTH_RADIUS * EARTH_RADIUS / 2.0;
   						}
   						area = Math.abs( Math.round(area*100) ) / 100;
   					}

   					return new NumberType(area);
   				},

   				args: [
   					{t: 'string'}
   				],

   				ret: 'number'
   			},

   			'ends-with': {
   				/**
   				 * The ends-with function returns true if the first argument string
   				 * ends with the second argument string, and otherwise returns false.
   				 *
   				 * An alternative (faster?) would be to reverse the first argument and use starts-with (in Enketo Core)?
   				 *
   				 * @see https://www.w3.org/TR/xpath-functions-30/#func-ends-with
   				 * @param {StringType} haystack
   				 * @param {StringType} needle
   				 * @return {StringType}
   				 */
   				fn: function(haystack, needle)
   				{
   					return new BooleanType(haystack.toString().substr(haystack.toString().length - needle.toString().length) === needle.toString());
   				},

   				args: [
   					{t: 'string'},
   					{t: 'string'}
   				],

   				ret: 'string'
   			},

   			abs: {
   				/**
   				 * Returns the absolute value of the argument.
   				 *
   				 * @see https://www.w3.org/TR/xpath-functions-30/#func-abs
   				 * @param {NumberType}
   				 * @return {NumberType}
   				 */
   				fn: function(number)
   				{
   					return new NumberType(Math.abs(number));
   				},

   				args: [
   					{t: 'number'}
   				],

   				ret: 'number'
   			},

   			/**
   			 * MOVED TO ENKETO-CORE WHERE IT TRANSFORMED INTO REGULAR XPATH
   			 *
   			 * @param { NodeSetType} nodeset 	 	Collection of nodes of which to select one
   			 * @param { NodeSetType} r1,r2,r3,r4,r5 The repeat nodes
   			 * @param { NumberType}  p1,p2,p3,p4,p5 The position of the repeat that contains the node to return
   			 * @return {NodeSetType}
   			 */
   			/*'indexed-repeat': {

   				fn: function(nodeset, r1, p1, r2, p2, r3, p3, r4, p4, r5, p5) {
   					var tagName, node, repeat, position, repeats, positions, i;

   					nodeset = nodeset.toNodeSet();

   					if (nodeset.length === 0) {
   						throw new Error('indexed-repeat called with empty nodeset in first parameter');
   						return;
   					}
   					if (arguments.length % 2 !== 1) {
   						throw new Error('indexed-repeat received invalid number of arguments');
   						return;
   					}

   					for ( i = 1; i < arguments.length - 1; i += 2) {
   						position = arguments[ i + 1 ].toNumber();
   						repeats = arguments[ i ].toNodeSet();
   						if (repeats.length === 0) {
   							throw new Error('indexed-repeat called with empty nodeset as repeat parameter');
   						}
   						tagName = repeats[0].tagName;
   						repeat = (repeat) ? repeat.getElementsByTagName(tagName)[position - 1] : repeats[position - 1];
   					}

   					tagName = nodeset[0].tagName;
   					node = repeat.getElementsByTagName(tagName);

   					return new NodeSetType(node, 'document-order');
   				},

   				args: [
   					{ t: 'node-set' },
   					{ t: 'node-set' },
   					{ t: 'number' },
   					{ t: 'node-set', r: false},
   					{ t: 'number', r: false },
   					{ t: 'node-set', r:false },
   					{ t: 'number', r: false},
   					{ t: 'node-set', r: false },
   					{ t: 'number', r:false },
   					{ t: 'node-set', r:false },
   					{ t: 'number', r:false }
   				],

   				ret: 'node-set'

   			}*/
   		}
   	}
   	/**
   	 * Alias functions
   	 */
   	functions[""]['format-date-time'] = functions[""]['format-date'];

   	/**
   	 * Evaluate parsed expression tree.
   	 *
   	 * @param {Object} context
   	 * @param {Object} tree
   	 * @return {Object}
   	 */
   	evaluateExpressionTree = function(context, tree)
   	{
   		if (typeof expressions[tree.type] != 'function')
   		{
   			throw new Error('Internal Error: Expression type does not exist: ' + tree.type);
   		}

   		return expressions[tree.type].apply(context, tree.args)
   	}

   	/**
   	 * The XPathResult interface represents the result of the evaluation of a
   	 * XPath 1.0 expression within the context of a particular node. Since
   	 * evaluation of an XPath expression can result in various result types,
   	 * this object makes it possible to discover and manipulate the type
   	 * and value of the result.
   	 *
   	 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult
   	 *
   	 * @param {Context} context
   	 * @param {Number} type
   	 * @param {BaseType} value
   	 */
   	XPathResult = function(context, type, value)
   	{
   		switch(type)
   		{
   			case XPathResult.NUMBER_TYPE:
   				this.resultType = XPathResult.NUMBER_TYPE;
   				this.numberValue = value.toNumber();
   				break;

   			case XPathResult.STRING_TYPE:
   				this.resultType = XPathResult.STRING_TYPE;
   				this.stringValue = value.toString();
   				break;

   			case XPathResult.BOOLEAN_TYPE:
   				this.resultType = XPathResult.BOOLEAN_TYPE;
   				this.booleanValue = value.toBoolean();
   				break;

   			case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
   			case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
   			case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
   			case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
   			case XPathResult.ANY_UNORDERED_NODE_TYPE:
   			case XPathResult.FIRST_ORDERED_NODE_TYPE:
   				if (!value instanceof NodeSetType)
   				{
   					throw new Error('Expected result of type "node-set", got: "' + value.type + '"');
   				}

   				this.resultType = type;

   				switch(type)
   				{
   					case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
   					case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
   						this._value = value.toNodeSet();
   						this.snapshotLength = this._value.length;
   						break;

   					case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
   					case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
   						// ensure in document order
   						value.sortDocumentOrder();

   						this._value = value.toNodeSet();
   						this.snapshotLength = this._value.length;
   						break;

   					case XPathResult.ANY_UNORDERED_NODE_TYPE:
   						value = value.toNodeSet();
   						this.singleNodeValue = (value.length) ? value[0] : null;
   						break;

   					case XPathResult.FIRST_ORDERED_NODE_TYPE:
   						// ensure in document order
   						value.sortDocumentOrder();
   						value = value.toNodeSet();
   						this.singleNodeValue = (value.length) ? value[0] : null;
   						break;

   					default:
   						throw new XPathException(XPathException.TYPE_ERR, 'XPath result type not supported. (type: ' + type + ')');
   						break;
   				}

   				break;

   			default:
   				throw new XPathException(XPathException.TYPE_ERR, 'XPath result type not supported. (type: ' + type + ')');
   				break;
   		};
   	}

   	XPathResult.factory = function(context, type, value)
   	{
   		var result;

   		if (type !== XPathResult.ANY_TYPE)
   		{
   			return new XPathResult(context, type, value);
   		}

   		// handle any type result
   		if (value instanceof NodeSetType)
   		{
   			result = new XPathResult(context, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, value);
   		}
   		else if (value instanceof NumberType)
   		{
   			result = new XPathResult(context, XPathResult.NUMBER_TYPE, value);
   		}
   		else if (value instanceof BooleanType)
   		{
   			result = new XPathResult(context, XPathResult.BOOLEAN_TYPE, value);
   		}
   		else if (value instanceof StringType)
   		{
   			result = new XPathResult(context, XPathResult.STRING_TYPE, value);
   		}
   		else
   		{
   			throw new XPathException(XPathException.TYPE_ERR, 'Internal Error: Unsupported value type: ' + typeof value);
   		}

   		return result;
   	}

   	XPathResult.prototype = {
   		/**
   		 * A code representing the type of this result, as defined by the type constants.
   		 *
   		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-resultType
   		 * @type {number}
   		 */
   		resultType: null,

   		/**
   		 * The value of this number result.
   		 *
   		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-numberValue
   		 * @type {number}
   		 */
   		numberValue: null,

   		/**
   		 * The value of this string result.
   		 *
   		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-stringValue
   		 * @type {String}
   		 */
   		stringValue: null,

   		/**
   		 * The value of this boolean result.
   		 *
   		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-booleanValue
   		 * @type {boolean}
   		 */
   		booleanValue: null,

   		/**
   		 * The value of this single node result, which may be null.
   		 *
   		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-singleNodeValue
   		 * @type {Node}
   		 */
   		singleNodeValue: null,

   		/**
   		 * Signifies that the iterator has become invalid. True if resultType is
   		 * UNORDERED_NODE_ITERATOR_TYPE or ORDERED_NODE_ITERATOR_TYPE and the
   		 * document has been modified since this result was returned.
   		 *
   		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-invalid-iterator-state
   		 * @type {boolean}
   		 */
   		invalidIteratorState: null,

   		/**
   		 * The number of nodes in the result snapshot.
   		 *
   		 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult-snapshot-length
   		 * @type {number}
   		 */
   		snapshotLength: null,

   		_iteratorIndex: 0,

   		iterateNext: function()
   		{
   			if (
   				this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE &&
   				this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE
   			) {
   				throw new XPathException(XPathException.TYPE_ERR, 'iterateNext() method may only be used with results of type UNORDERED_NODE_ITERATOR_TYPE or ORDERED_NODE_ITERATOR_TYPE');
   			}

   			if (this._iteratorIndex < this._value.length)
   			{
   				return this._value[this._iteratorIndex++];
   			}

   			return null;
   		},

   		snapshotItem: function(index)
   		{
   			if (
   				this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE &&
   				this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE
   			) {
   				throw new XPathException(XPathException.TYPE_ERR, 'snapshotItem() method may only be used with results of type UNORDERED_NODE_SNAPSHOT_TYPE or ORDERED_NODE_SNAPSHOT_TYPE');
   			}

   			return this._value[index];
   		}
   	}

   	/**
   	 * XPathResultType
   	 *
   	 * An integer indicating what type of result this is.
   	 *
   	 * If a specific type is specified, then the result will be returned as the corresponding
   	 * type, using XPath type conversions where required and possible.
   	 */

   	XPathResult.ANY_TYPE = 0;
   	XPathResult.NUMBER_TYPE = 1;
   	XPathResult.STRING_TYPE = 2;
   	XPathResult.BOOLEAN_TYPE = 3;
   	XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
   	XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
   	XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
   	XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
   	XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
   	XPathResult.FIRST_ORDERED_NODE_TYPE = 9;

   	/**
   	 * The XPathNamespace interface is returned by XPathResult interfaces to
   	 * represent the XPath namespace node type that DOM lacks. There is no public
   	 * constructor for this node type. Attempts to place it into a hierarchy or a
   	 * NamedNodeMap result in a DOMException with the code HIERARCHY_REQUEST_ERR.
   	 * This node is read only, so methods or setting of attributes that would
   	 * mutate the node result in a DOMException with the code NO_MODIFICATION_ALLOWED_ERR.
   	 *
   	 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathNamespace
   	 * @param {string} prefix Prefix of the namespace represented by the node.
   	 * @param {string} namespaceURI Namespace URI of the namespace represented by the node.
   	 * @param {Element} ownerElement The Element on which the namespace was in scope when it was requested.
   	 */
   	XPathNamespace = function(prefix, namespaceURI, ownerElement)
   	{
   		if(ownerElement.nodeType != 1)
   		{
   			throw new Error('Internal Error: XPathNamespace owner element must be an Element node.');
   		}
   		this.ownerElement = ownerElement;

   		// ownerDocument matches the ownerDocument of the ownerElement even if the element is later adopted.
   		// TODO-FUTURE: ownerDocument == ownerElement.ownerDocument when ownerElement changes ownerDocument
   		this.ownerDocument = ownerElement.ownerDocument;

   		// nodeName is always the string "#namespace".
   		this.nodeName = '#namespace';

   		// prefix is the prefix of the namespace represented by the node.
   		this.prefix = prefix;

   		// localName is the same as prefix.
   		this.localName = prefix;

   		// nodeType is equal to XPATH_NAMESPACE_NODE.
   		this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE

   		// namespaceURI is the namespace URI of the namespace represented by the node.
   		this.namespaceURI = namespaceURI;

   		// nodeValue is the same as namespaceURI.
   		this.nodeValue = namespaceURI;

   		// adoptNode, cloneNode, and importNode fail on this node type by raising a DOMException with the code NOT_SUPPORTED_ERR.
   		// TODO-FUTURE: implement exceptions above, see: http://www.w3.org/TR/DOM-Level-3-Core/

   		// TODO-FUTURE: find all other attributes of Node not set above, and set the to null or false
   		// see: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-1950641247
   	}

   	/**
   	 * An integer indicating which type of node this is.
   	 *
   	 * Note: There is currently only one type of node which is specific to XPath. The numbers in this list must not collide with the values assigned to core node types.
   	 *
   	 * @see http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPATH_NAMESPACE_NODE
   	 * @property {number} The node is a Namespace.
   	 */
   	XPathNamespace.XPATH_NAMESPACE_NODE = 13;

   	module = {
   		XPathException: XPathException,
   		XPathEvaluator: XPathEvaluator,
   		XPathNSResolver: XPathNSResolver,
   		XPathExpression: XPathExpression,
   		XPathResult: XPathResult,
   		XPathNamespace: XPathNamespace,

   		/**
   		 * Get the current list of DOM Level 3 XPath window and document objects
   		 * that are in use.
   		 *
   		 * @return {Object} List of DOM Level 3 XPath window and document objects
   		 *         that are currently in use.
   		 */
   		getCurrentDomLevel3XPathBindings: function()
   		{
   			return {
   				'window': {
   					XPathException: window.XPathException,
   					XPathExpression: window.XPathExpression,
   					XPathNSResolver: window.XPathNSResolver,
   					XPathResult: window.XPathResult,
   					XPathNamespace: window.XPathNamespace
   				},
   				'document': {
   					createExpression: document.createExpression,
   					createNSResolver: document.createNSResolver,
   					evaluate: document.evaluate
   				}
   			}
   		},

   		/**
   		 * Get the list of DOM Level 3 XPath objects that are implemented by
   		 * the XPathJS module.
   		 *
   		 * @return {Object} List of DOM Level 3 XPath objects implemented by
   		 *         the XPathJS module.
   		 */
   		createDomLevel3XPathBindings: function(options)
   		{
   			var evaluator = new XPathEvaluator(options)
   			;

   			return {
   				'window': {
   					XPathException: XPathException,
   					XPathExpression: XPathExpression,
   					XPathNSResolver: XPathNSResolver,
   					XPathResult: XPathResult,
   					XPathNamespace: XPathNamespace
   				},
   				'document': {
   					createExpression: function() {
   						return evaluator.createExpression.apply(evaluator, arguments);
   					},
   					createNSResolver: function() {
   						return evaluator.createNSResolver.apply(evaluator, arguments);
   					},
   					evaluate: function() {
   						return evaluator.evaluate.apply(evaluator, arguments);
   					}
   				}
   			}
   		},

   		/**
   		 * Bind DOM Level 3 XPath interfaces to the DOM.
   		 *
   		 * @param {Object} doc the document or (Document.prototype!) to bind the evaluator etc. to
   		 * @return List of original DOM Level 3 XPath objects that has been replaced
   		 */
   		bindDomLevel3XPath: function(doc, bindings)
   		{
   			var newBindings = (bindings || module.createDomLevel3XPathBindings()),
   				currentBindings = module.getCurrentDomLevel3XPathBindings(),
   				doc = doc || document,
   				i
   			;

   			for(i in newBindings['window'])
   			{
   				window[i] = newBindings['window'][i];
   			}

   			for(i in newBindings['document'])
   			{
   				doc[i] = newBindings['document'][i];
   			}

   			return currentBindings;
   		}
   	}

   	return module;

   })();
   XPathJS._parser = (function() {
     "use strict";

     /*
      * Generated by PEG.js 0.9.0.
      *
      * http://pegjs.org/
      */

     function peg$subclass(child, parent) {
       function ctor() { this.constructor = child; }
       ctor.prototype = parent.prototype;
       child.prototype = new ctor();
     }

     function peg$SyntaxError(message, expected, found, location) {
       this.message  = message;
       this.expected = expected;
       this.found    = found;
       this.location = location;
       this.name     = "SyntaxError";

       if (typeof Error.captureStackTrace === "function") {
         Error.captureStackTrace(this, peg$SyntaxError);
       }
     }

     peg$subclass(peg$SyntaxError, Error);

     function peg$parse(input) {
       var options = arguments.length > 1 ? arguments[1] : {},
           parser  = this,

           peg$FAILED = {},

           peg$startRuleFunctions = { XPath: peg$parseXPath },
           peg$startRuleFunction  = peg$parseXPath,

           peg$c0 = function(expr) {
           		return {
           			 tree: expr
           			,nsPrefixes: nsPrefixes
           		}
           	},
           peg$c1 = "/",
           peg$c2 = { type: "literal", value: "/", description: "\"/\"" },
           peg$c3 = function(path) {
           		return {
           			 type: '/'
           			,args: [
           				null,
           				(path) ? path[1] : null
           			]
           		};
           	},
           peg$c4 = "//",
           peg$c5 = { type: "literal", value: "//", description: "\"//\"" },
           peg$c6 = function(expr, repeatedExpr) {
           		var i;

           		for(i=0; i < repeatedExpr.length; i++)
           		{
           			expr = expandSlashAbbrev(repeatedExpr[i][1], expr, repeatedExpr[i][3]);
           		}

           		return expr;
           	},
           peg$c7 = function(axis, node, predicate) {
           		return predicateExpression({
           			type: 'step',
           			args: [
           				axis,
           				node
           			]},
           			axis,
           			predicate,
           			1
           		);
           	},
           peg$c8 = "::",
           peg$c9 = { type: "literal", value: "::", description: "\"::\"" },
           peg$c10 = function(axis) {
           		return axis;
           	},
           peg$c11 = function(aas) {
           		return (aas.length) ? aas : 'child';
           	},
           peg$c12 = "ancestor-or-self",
           peg$c13 = { type: "literal", value: "ancestor-or-self", description: "\"ancestor-or-self\"" },
           peg$c14 = "ancestor",
           peg$c15 = { type: "literal", value: "ancestor", description: "\"ancestor\"" },
           peg$c16 = "attribute",
           peg$c17 = { type: "literal", value: "attribute", description: "\"attribute\"" },
           peg$c18 = "child",
           peg$c19 = { type: "literal", value: "child", description: "\"child\"" },
           peg$c20 = "descendant-or-self",
           peg$c21 = { type: "literal", value: "descendant-or-self", description: "\"descendant-or-self\"" },
           peg$c22 = "descendant",
           peg$c23 = { type: "literal", value: "descendant", description: "\"descendant\"" },
           peg$c24 = "following-sibling",
           peg$c25 = { type: "literal", value: "following-sibling", description: "\"following-sibling\"" },
           peg$c26 = "following",
           peg$c27 = { type: "literal", value: "following", description: "\"following\"" },
           peg$c28 = "namespace",
           peg$c29 = { type: "literal", value: "namespace", description: "\"namespace\"" },
           peg$c30 = "parent",
           peg$c31 = { type: "literal", value: "parent", description: "\"parent\"" },
           peg$c32 = "preceding-sibling",
           peg$c33 = { type: "literal", value: "preceding-sibling", description: "\"preceding-sibling\"" },
           peg$c34 = "preceding",
           peg$c35 = { type: "literal", value: "preceding", description: "\"preceding\"" },
           peg$c36 = "self",
           peg$c37 = { type: "literal", value: "self", description: "\"self\"" },
           peg$c38 = "(",
           peg$c39 = { type: "literal", value: "(", description: "\"(\"" },
           peg$c40 = ")",
           peg$c41 = { type: "literal", value: ")", description: "\")\"" },
           peg$c42 = function(nodeType) {
           		return {
           			 type: 'nodeType'
           			,args: [
           				nodeType,
           				[]
           			]
           		};
           	},
           peg$c43 = "processing-instruction",
           peg$c44 = { type: "literal", value: "processing-instruction", description: "\"processing-instruction\"" },
           peg$c45 = function(pi, arg) {
           		return {
           			 type: 'nodeType'
           			,args: [
           				pi,
           				[arg]
           			]
           		};
           	},
           peg$c46 = function(nt) {
           		return nt;
           	},
           peg$c47 = "[",
           peg$c48 = { type: "literal", value: "[", description: "\"[\"" },
           peg$c49 = "]",
           peg$c50 = { type: "literal", value: "]", description: "\"]\"" },
           peg$c51 = function(expr) {
           		return expr;
           	},
           peg$c52 = function(path) {
           		return expandSlashAbbrev('//', null, path);
           	},
           peg$c53 = "..",
           peg$c54 = { type: "literal", value: "..", description: "\"..\"" },
           peg$c55 = ".",
           peg$c56 = { type: "literal", value: ".", description: "\".\"" },
           peg$c57 = function(abbrev) {
           		/*
           		 * @see http://www.w3.org/TR/xpath/#path-abbrev
           		 */
           		var result = {
           			type: 'step',
           			args: [
           				'self', // assume .
           				{
           					type: 'nodeType',
           					args: [
           						'node',
           						[]
           					]
           				}
           			]
           		}

           		if (abbrev == '..')
           		{
           			result.args[0] = 'parent';
           		}

           		return result;
           	},
           peg$c58 = "@",
           peg$c59 = { type: "literal", value: "@", description: "\"@\"" },
           peg$c60 = function(attribute) {
           		return (attribute) ? 'attribute' : '';
           	},
           peg$c61 = function(vr) {
           		return vr;
           	},
           peg$c62 = function(l) {
           		return l;
           	},
           peg$c63 = function(n) {
           		return n;
           	},
           peg$c64 = ",",
           peg$c65 = { type: "literal", value: ",", description: "\",\"" },
           peg$c66 = function(name, arg) {
           		var i, args = [];
           		if (arg)
           		{
           			args.push(arg[1]);
           			for (i=0; i < arg[2].length; i++)
           			{
           				args.push(arg[2][i][3]);
           			}
           		}
           		return {
           			 type: 'function'
           			,args: [
           				name,
           				args
           			]
           		};
           	},
           peg$c67 = "|",
           peg$c68 = { type: "literal", value: "|", description: "\"|\"" },
           peg$c69 = function(expr, repeatedExpr) {
           		return expressionSimplifier(expr, repeatedExpr, 1, 3);
           	},
           peg$c70 = function(expr, path) {
           		if (!path)
           			return expr;

           		return expandSlashAbbrev(path[1], expr, path[3]);
           	},
           peg$c71 = function(path) {
           		return path;
           	},
           peg$c72 = function(expr, repeatedExpr) {
           		return predicateExpression(expr, 'child', repeatedExpr, 1);
           	},
           peg$c73 = "or",
           peg$c74 = { type: "literal", value: "or", description: "\"or\"" },
           peg$c75 = "and",
           peg$c76 = { type: "literal", value: "and", description: "\"and\"" },
           peg$c77 = "=",
           peg$c78 = { type: "literal", value: "=", description: "\"=\"" },
           peg$c79 = "!=",
           peg$c80 = { type: "literal", value: "!=", description: "\"!=\"" },
           peg$c81 = "<=",
           peg$c82 = { type: "literal", value: "<=", description: "\"<=\"" },
           peg$c83 = "<",
           peg$c84 = { type: "literal", value: "<", description: "\"<\"" },
           peg$c85 = ">=",
           peg$c86 = { type: "literal", value: ">=", description: "\">=\"" },
           peg$c87 = ">",
           peg$c88 = { type: "literal", value: ">", description: "\">\"" },
           peg$c89 = "+",
           peg$c90 = { type: "literal", value: "+", description: "\"+\"" },
           peg$c91 = "-",
           peg$c92 = { type: "literal", value: "-", description: "\"-\"" },
           peg$c93 = "div",
           peg$c94 = { type: "literal", value: "div", description: "\"div\"" },
           peg$c95 = "mod",
           peg$c96 = { type: "literal", value: "mod", description: "\"mod\"" },
           peg$c97 = function(expr) {
           		return {
           			 type: '*' // multiply
           			,args: [
           				{
           					type: 'number',
           					args: [
           						-1
           					]
           				},
           				expr
           			]
           		}
           	},
           peg$c98 = "\"",
           peg$c99 = { type: "literal", value: "\"", description: "\"\\\"\"" },
           peg$c100 = /^[^"]/,
           peg$c101 = { type: "class", value: "[^\"]", description: "[^\"]" },
           peg$c102 = function(literals) {
           		return {
           			type: 'string',
           			args: [
           				literals.join('')
           			]
           		};
           	},
           peg$c103 = "'",
           peg$c104 = { type: "literal", value: "'", description: "\"'\"" },
           peg$c105 = /^[^']/,
           peg$c106 = { type: "class", value: "[^']", description: "[^']" },
           peg$c107 = function(digits, decimals) {
           		return {
           			 type: 'number'
           			,args: [
           				(decimals) ? parseFloat(digits + '.' + decimals[1]) : parseInt(digits)
           			]
           		};
           	},
           peg$c108 = function(digits) {
           		return {
           			type: 'number',
           			args: [
           				parseFloat('.' + digits)
           			]
           		};
           	},
           peg$c109 = /^[0-9]/,
           peg$c110 = { type: "class", value: "[0-9]", description: "[0-9]" },
           peg$c111 = function(digits) {
           		return digits.join('');
           	},
           peg$c112 = "*",
           peg$c113 = { type: "literal", value: "*", description: "\"*\"" },
           peg$c114 = function(name) { // - NodeType
           		var i;

           		// exclude NodeType names
           		if (lastQNameParsed.args[0] === null) // no namespace
           		{
           			for(i=0; i<nodeTypeNames.length; i++)
           			{
           				if (lastQNameParsed.args[1] == nodeTypeNames[i]) // name
           				{
           					// Reserved NodeType name used, so don't allow this function name
           					return false;
           				}
           			}
           		}

           		// function name ok
           		return true;
           	},
           peg$c115 = function(name) {
           		(name.args[0] === '')
           			? name = {  // NOTE: apparently "name.args[0] = null" doesn't work well because NameTest get's screwed up...
           				 type: name.type
           				,args: [
           					null,
           					name.args[1]
           				]
           			}
           			: trackNsPrefix(name.args[0])
           		;
           		return name;
           	},
           peg$c116 = "$",
           peg$c117 = { type: "literal", value: "$", description: "\"$\"" },
           peg$c118 = function(name) {
           		trackNsPrefix(name.args[0]);

           		return {
           			 type: '$'
           			,args: [
           				name
           			]
           		};
           	},
           peg$c119 = function() {
           		return {
           			 type: 'name'
           			,args: [
           				null,
           				null
           			]
           		};
           	},
           peg$c120 = ":",
           peg$c121 = { type: "literal", value: ":", description: "\":\"" },
           peg$c122 = function(ns) {
           		trackNsPrefix(ns);
           		return {
           			 type: 'name'
           			,args: [
           				ns,
           				null
           			]
           		};
           	},
           peg$c123 = function(name) {
           		trackNsPrefix(name.args[0]);
           		return name;
           	},
           peg$c124 = "comment",
           peg$c125 = { type: "literal", value: "comment", description: "\"comment\"" },
           peg$c126 = "text",
           peg$c127 = { type: "literal", value: "text", description: "\"text\"" },
           peg$c128 = "node",
           peg$c129 = { type: "literal", value: "node", description: "\"node\"" },
           peg$c130 = /^[ \t\r\n]/,
           peg$c131 = { type: "class", value: "[\\u0020\\u0009\\u000D\\u000A]", description: "[\\u0020\\u0009\\u000D\\u000A]" },
           peg$c132 = function(name) {
           		lastQNameParsed = name;
           		return name;
           	},
           peg$c133 = function(ns, name) {
           		return {
           			 type: 'name'
           			,args: [
           				ns,
           				name
           			]
           		};
           	},
           peg$c134 = function(name) {
           		return {
           			 type: 'name'
           			,args: [
           				null,
           				name
           			]
           		};
           	},
           peg$c135 = /^[A-Z]/,
           peg$c136 = { type: "class", value: "[A-Z]", description: "[A-Z]" },
           peg$c137 = "_",
           peg$c138 = { type: "literal", value: "_", description: "\"_\"" },
           peg$c139 = /^[a-z]/,
           peg$c140 = { type: "class", value: "[a-z]", description: "[a-z]" },
           peg$c141 = /^[\xC0-\xD6]/,
           peg$c142 = { type: "class", value: "[\\u00C0-\\u00D6]", description: "[\\u00C0-\\u00D6]" },
           peg$c143 = /^[\xD8-\xF6]/,
           peg$c144 = { type: "class", value: "[\\u00D8-\\u00F6]", description: "[\\u00D8-\\u00F6]" },
           peg$c145 = /^[\xF8-\u02FF]/,
           peg$c146 = { type: "class", value: "[\\u00F8-\\u02FF]", description: "[\\u00F8-\\u02FF]" },
           peg$c147 = /^[\u0370-\u037D]/,
           peg$c148 = { type: "class", value: "[\\u0370-\\u037D]", description: "[\\u0370-\\u037D]" },
           peg$c149 = /^[\u037F-\u1FFF]/,
           peg$c150 = { type: "class", value: "[\\u037F-\\u1FFF]", description: "[\\u037F-\\u1FFF]" },
           peg$c151 = /^[\u200C-\u200D]/,
           peg$c152 = { type: "class", value: "[\\u200C-\\u200D]", description: "[\\u200C-\\u200D]" },
           peg$c153 = /^[\u2070-\u218F]/,
           peg$c154 = { type: "class", value: "[\\u2070-\\u218F]", description: "[\\u2070-\\u218F]" },
           peg$c155 = /^[\u2C00-\u2FEF]/,
           peg$c156 = { type: "class", value: "[\\u2C00-\\u2FEF]", description: "[\\u2C00-\\u2FEF]" },
           peg$c157 = /^[\u3001-\uD7FF]/,
           peg$c158 = { type: "class", value: "[\\u3001-\\uD7FF]", description: "[\\u3001-\\uD7FF]" },
           peg$c159 = /^[\uF900-\uFDCF]/,
           peg$c160 = { type: "class", value: "[\\uF900-\\uFDCF]", description: "[\\uF900-\\uFDCF]" },
           peg$c161 = /^[\uFDF0-\uFFFD]/,
           peg$c162 = { type: "class", value: "[\\uFDF0-\\uFFFD]", description: "[\\uFDF0-\\uFFFD]" },
           peg$c163 = /^[\xB7]/,
           peg$c164 = { type: "class", value: "[\\u00B7]", description: "[\\u00B7]" },
           peg$c165 = /^[\u0300-\u036F]/,
           peg$c166 = { type: "class", value: "[\\u0300-\\u036F]", description: "[\\u0300-\\u036F]" },
           peg$c167 = /^[\u203F-\u2040]/,
           peg$c168 = { type: "class", value: "[\\u203F-\\u2040]", description: "[\\u203F-\\u2040]" },
           peg$c169 = function(startchar, chars) {
           		return startchar + chars.join('');
           	},

           peg$currPos          = 0,
           peg$savedPos         = 0,
           peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],
           peg$maxFailPos       = 0,
           peg$maxFailExpected  = [],
           peg$silentFails      = 0,

           peg$result;

       if ("startRule" in options) {
         if (!(options.startRule in peg$startRuleFunctions)) {
           throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
         }

         peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
       }

       function text() {
         return input.substring(peg$savedPos, peg$currPos);
       }

       function location() {
         return peg$computeLocation(peg$savedPos, peg$currPos);
       }

       function expected(description) {
         throw peg$buildException(
           null,
           [{ type: "other", description: description }],
           input.substring(peg$savedPos, peg$currPos),
           peg$computeLocation(peg$savedPos, peg$currPos)
         );
       }

       function error(message) {
         throw peg$buildException(
           message,
           null,
           input.substring(peg$savedPos, peg$currPos),
           peg$computeLocation(peg$savedPos, peg$currPos)
         );
       }

       function peg$computePosDetails(pos) {
         var details = peg$posDetailsCache[pos],
             p, ch;

         if (details) {
           return details;
         } else {
           p = pos - 1;
           while (!peg$posDetailsCache[p]) {
             p--;
           }

           details = peg$posDetailsCache[p];
           details = {
             line:   details.line,
             column: details.column,
             seenCR: details.seenCR
           };

           while (p < pos) {
             ch = input.charAt(p);
             if (ch === "\n") {
               if (!details.seenCR) { details.line++; }
               details.column = 1;
               details.seenCR = false;
             } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
               details.line++;
               details.column = 1;
               details.seenCR = true;
             } else {
               details.column++;
               details.seenCR = false;
             }

             p++;
           }

           peg$posDetailsCache[pos] = details;
           return details;
         }
       }

       function peg$computeLocation(startPos, endPos) {
         var startPosDetails = peg$computePosDetails(startPos),
             endPosDetails   = peg$computePosDetails(endPos);

         return {
           start: {
             offset: startPos,
             line:   startPosDetails.line,
             column: startPosDetails.column
           },
           end: {
             offset: endPos,
             line:   endPosDetails.line,
             column: endPosDetails.column
           }
         };
       }

       function peg$fail(expected) {
         if (peg$currPos < peg$maxFailPos) { return; }

         if (peg$currPos > peg$maxFailPos) {
           peg$maxFailPos = peg$currPos;
           peg$maxFailExpected = [];
         }

         peg$maxFailExpected.push(expected);
       }

       function peg$buildException(message, expected, found, location) {
         function cleanupExpected(expected) {
           var i = 1;

           expected.sort(function(a, b) {
             if (a.description < b.description) {
               return -1;
             } else if (a.description > b.description) {
               return 1;
             } else {
               return 0;
             }
           });

           while (i < expected.length) {
             if (expected[i - 1] === expected[i]) {
               expected.splice(i, 1);
             } else {
               i++;
             }
           }
         }

         function buildMessage(expected, found) {
           function stringEscape(s) {
             function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

             return s
               .replace(/\\/g,   '\\\\')
               .replace(/"/g,    '\\"')
               .replace(/\x08/g, '\\b')
               .replace(/\t/g,   '\\t')
               .replace(/\n/g,   '\\n')
               .replace(/\f/g,   '\\f')
               .replace(/\r/g,   '\\r')
               .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
               .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
               .replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
               .replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
           }

           var expectedDescs = new Array(expected.length),
               expectedDesc, foundDesc, i;

           for (i = 0; i < expected.length; i++) {
             expectedDescs[i] = expected[i].description;
           }

           expectedDesc = expected.length > 1
             ? expectedDescs.slice(0, -1).join(", ")
                 + " or "
                 + expectedDescs[expected.length - 1]
             : expectedDescs[0];

           foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

           return "Expected " + expectedDesc + " but " + foundDesc + " found.";
         }

         if (expected !== null) {
           cleanupExpected(expected);
         }

         return new peg$SyntaxError(
           message !== null ? message : buildMessage(expected, found),
           expected,
           found,
           location
         );
       }

       function peg$parseXPath() {
         var s0, s1, s2, s3;

         s0 = peg$currPos;
         s1 = peg$parse_();
         if (s1 !== peg$FAILED) {
           s2 = peg$parseExpr();
           if (s2 !== peg$FAILED) {
             s3 = peg$parse_();
             if (s3 !== peg$FAILED) {
               peg$savedPos = s0;
               s1 = peg$c0(s2);
               s0 = s1;
             } else {
               peg$currPos = s0;
               s0 = peg$FAILED;
             }
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parseLocationPath() {
         var s0;

         s0 = peg$parseRelativeLocationPath();
         if (s0 === peg$FAILED) {
           s0 = peg$parseAbsoluteLocationPath();
         }

         return s0;
       }

       function peg$parseAbsoluteLocationPath() {
         var s0, s1, s2, s3, s4;

         s0 = peg$parseAbbreviatedAbsoluteLocationPath();
         if (s0 === peg$FAILED) {
           s0 = peg$currPos;
           if (input.charCodeAt(peg$currPos) === 47) {
             s1 = peg$c1;
             peg$currPos++;
           } else {
             s1 = peg$FAILED;
             if (peg$silentFails === 0) { peg$fail(peg$c2); }
           }
           if (s1 !== peg$FAILED) {
             s2 = peg$currPos;
             s3 = peg$parse_();
             if (s3 !== peg$FAILED) {
               s4 = peg$parseRelativeLocationPath();
               if (s4 !== peg$FAILED) {
                 s3 = [s3, s4];
                 s2 = s3;
               } else {
                 peg$currPos = s2;
                 s2 = peg$FAILED;
               }
             } else {
               peg$currPos = s2;
               s2 = peg$FAILED;
             }
             if (s2 === peg$FAILED) {
               s2 = null;
             }
             if (s2 !== peg$FAILED) {
               peg$savedPos = s0;
               s1 = peg$c3(s2);
               s0 = s1;
             } else {
               peg$currPos = s0;
               s0 = peg$FAILED;
             }
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         }

         return s0;
       }

       function peg$parseRelativeLocationPath() {
         var s0, s1, s2, s3, s4, s5, s6, s7;

         s0 = peg$currPos;
         s1 = peg$parseStep();
         if (s1 !== peg$FAILED) {
           s2 = [];
           s3 = peg$currPos;
           s4 = peg$parse_();
           if (s4 !== peg$FAILED) {
             if (input.substr(peg$currPos, 2) === peg$c4) {
               s5 = peg$c4;
               peg$currPos += 2;
             } else {
               s5 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c5); }
             }
             if (s5 === peg$FAILED) {
               if (input.charCodeAt(peg$currPos) === 47) {
                 s5 = peg$c1;
                 peg$currPos++;
               } else {
                 s5 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c2); }
               }
             }
             if (s5 !== peg$FAILED) {
               s6 = peg$parse_();
               if (s6 !== peg$FAILED) {
                 s7 = peg$parseStep();
                 if (s7 !== peg$FAILED) {
                   s4 = [s4, s5, s6, s7];
                   s3 = s4;
                 } else {
                   peg$currPos = s3;
                   s3 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           } else {
             peg$currPos = s3;
             s3 = peg$FAILED;
           }
           while (s3 !== peg$FAILED) {
             s2.push(s3);
             s3 = peg$currPos;
             s4 = peg$parse_();
             if (s4 !== peg$FAILED) {
               if (input.substr(peg$currPos, 2) === peg$c4) {
                 s5 = peg$c4;
                 peg$currPos += 2;
               } else {
                 s5 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c5); }
               }
               if (s5 === peg$FAILED) {
                 if (input.charCodeAt(peg$currPos) === 47) {
                   s5 = peg$c1;
                   peg$currPos++;
                 } else {
                   s5 = peg$FAILED;
                   if (peg$silentFails === 0) { peg$fail(peg$c2); }
                 }
               }
               if (s5 !== peg$FAILED) {
                 s6 = peg$parse_();
                 if (s6 !== peg$FAILED) {
                   s7 = peg$parseStep();
                   if (s7 !== peg$FAILED) {
                     s4 = [s4, s5, s6, s7];
                     s3 = s4;
                   } else {
                     peg$currPos = s3;
                     s3 = peg$FAILED;
                   }
                 } else {
                   peg$currPos = s3;
                   s3 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           }
           if (s2 !== peg$FAILED) {
             peg$savedPos = s0;
             s1 = peg$c6(s1, s2);
             s0 = s1;
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parseStep() {
         var s0, s1, s2, s3, s4, s5, s6, s7;

         s0 = peg$currPos;
         s1 = peg$parseAxisSpecifier();
         if (s1 !== peg$FAILED) {
           s2 = peg$parse_();
           if (s2 !== peg$FAILED) {
             s3 = peg$parseNodeTest();
             if (s3 !== peg$FAILED) {
               s4 = [];
               s5 = peg$currPos;
               s6 = peg$parse_();
               if (s6 !== peg$FAILED) {
                 s7 = peg$parsePredicate();
                 if (s7 !== peg$FAILED) {
                   s6 = [s6, s7];
                   s5 = s6;
                 } else {
                   peg$currPos = s5;
                   s5 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s5;
                 s5 = peg$FAILED;
               }
               while (s5 !== peg$FAILED) {
                 s4.push(s5);
                 s5 = peg$currPos;
                 s6 = peg$parse_();
                 if (s6 !== peg$FAILED) {
                   s7 = peg$parsePredicate();
                   if (s7 !== peg$FAILED) {
                     s6 = [s6, s7];
                     s5 = s6;
                   } else {
                     peg$currPos = s5;
                     s5 = peg$FAILED;
                   }
                 } else {
                   peg$currPos = s5;
                   s5 = peg$FAILED;
                 }
               }
               if (s4 !== peg$FAILED) {
                 peg$savedPos = s0;
                 s1 = peg$c7(s1, s3, s4);
                 s0 = s1;
               } else {
                 peg$currPos = s0;
                 s0 = peg$FAILED;
               }
             } else {
               peg$currPos = s0;
               s0 = peg$FAILED;
             }
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }
         if (s0 === peg$FAILED) {
           s0 = peg$parseAbbreviatedStep();
         }

         return s0;
       }

       function peg$parseAxisSpecifier() {
         var s0, s1, s2, s3;

         s0 = peg$currPos;
         s1 = peg$parseAxisName();
         if (s1 !== peg$FAILED) {
           s2 = peg$parse_();
           if (s2 !== peg$FAILED) {
             if (input.substr(peg$currPos, 2) === peg$c8) {
               s3 = peg$c8;
               peg$currPos += 2;
             } else {
               s3 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c9); }
             }
             if (s3 !== peg$FAILED) {
               peg$savedPos = s0;
               s1 = peg$c10(s1);
               s0 = s1;
             } else {
               peg$currPos = s0;
               s0 = peg$FAILED;
             }
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }
         if (s0 === peg$FAILED) {
           s0 = peg$currPos;
           s1 = peg$parseAbbreviatedAxisSpecifier();
           if (s1 !== peg$FAILED) {
             peg$savedPos = s0;
             s1 = peg$c11(s1);
           }
           s0 = s1;
         }

         return s0;
       }

       function peg$parseAxisName() {
         var s0;

         if (input.substr(peg$currPos, 16) === peg$c12) {
           s0 = peg$c12;
           peg$currPos += 16;
         } else {
           s0 = peg$FAILED;
           if (peg$silentFails === 0) { peg$fail(peg$c13); }
         }
         if (s0 === peg$FAILED) {
           if (input.substr(peg$currPos, 8) === peg$c14) {
             s0 = peg$c14;
             peg$currPos += 8;
           } else {
             s0 = peg$FAILED;
             if (peg$silentFails === 0) { peg$fail(peg$c15); }
           }
           if (s0 === peg$FAILED) {
             if (input.substr(peg$currPos, 9) === peg$c16) {
               s0 = peg$c16;
               peg$currPos += 9;
             } else {
               s0 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c17); }
             }
             if (s0 === peg$FAILED) {
               if (input.substr(peg$currPos, 5) === peg$c18) {
                 s0 = peg$c18;
                 peg$currPos += 5;
               } else {
                 s0 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c19); }
               }
               if (s0 === peg$FAILED) {
                 if (input.substr(peg$currPos, 18) === peg$c20) {
                   s0 = peg$c20;
                   peg$currPos += 18;
                 } else {
                   s0 = peg$FAILED;
                   if (peg$silentFails === 0) { peg$fail(peg$c21); }
                 }
                 if (s0 === peg$FAILED) {
                   if (input.substr(peg$currPos, 10) === peg$c22) {
                     s0 = peg$c22;
                     peg$currPos += 10;
                   } else {
                     s0 = peg$FAILED;
                     if (peg$silentFails === 0) { peg$fail(peg$c23); }
                   }
                   if (s0 === peg$FAILED) {
                     if (input.substr(peg$currPos, 17) === peg$c24) {
                       s0 = peg$c24;
                       peg$currPos += 17;
                     } else {
                       s0 = peg$FAILED;
                       if (peg$silentFails === 0) { peg$fail(peg$c25); }
                     }
                     if (s0 === peg$FAILED) {
                       if (input.substr(peg$currPos, 9) === peg$c26) {
                         s0 = peg$c26;
                         peg$currPos += 9;
                       } else {
                         s0 = peg$FAILED;
                         if (peg$silentFails === 0) { peg$fail(peg$c27); }
                       }
                       if (s0 === peg$FAILED) {
                         if (input.substr(peg$currPos, 9) === peg$c28) {
                           s0 = peg$c28;
                           peg$currPos += 9;
                         } else {
                           s0 = peg$FAILED;
                           if (peg$silentFails === 0) { peg$fail(peg$c29); }
                         }
                         if (s0 === peg$FAILED) {
                           if (input.substr(peg$currPos, 6) === peg$c30) {
                             s0 = peg$c30;
                             peg$currPos += 6;
                           } else {
                             s0 = peg$FAILED;
                             if (peg$silentFails === 0) { peg$fail(peg$c31); }
                           }
                           if (s0 === peg$FAILED) {
                             if (input.substr(peg$currPos, 17) === peg$c32) {
                               s0 = peg$c32;
                               peg$currPos += 17;
                             } else {
                               s0 = peg$FAILED;
                               if (peg$silentFails === 0) { peg$fail(peg$c33); }
                             }
                             if (s0 === peg$FAILED) {
                               if (input.substr(peg$currPos, 9) === peg$c34) {
                                 s0 = peg$c34;
                                 peg$currPos += 9;
                               } else {
                                 s0 = peg$FAILED;
                                 if (peg$silentFails === 0) { peg$fail(peg$c35); }
                               }
                               if (s0 === peg$FAILED) {
                                 if (input.substr(peg$currPos, 4) === peg$c36) {
                                   s0 = peg$c36;
                                   peg$currPos += 4;
                                 } else {
                                   s0 = peg$FAILED;
                                   if (peg$silentFails === 0) { peg$fail(peg$c37); }
                                 }
                               }
                             }
                           }
                         }
                       }
                     }
                   }
                 }
               }
             }
           }
         }

         return s0;
       }

       function peg$parseNodeTest() {
         var s0, s1, s2, s3, s4, s5, s6, s7;

         s0 = peg$currPos;
         s1 = peg$parseNodeType();
         if (s1 !== peg$FAILED) {
           s2 = peg$parse_();
           if (s2 !== peg$FAILED) {
             if (input.charCodeAt(peg$currPos) === 40) {
               s3 = peg$c38;
               peg$currPos++;
             } else {
               s3 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c39); }
             }
             if (s3 !== peg$FAILED) {
               s4 = peg$parse_();
               if (s4 !== peg$FAILED) {
                 if (input.charCodeAt(peg$currPos) === 41) {
                   s5 = peg$c40;
                   peg$currPos++;
                 } else {
                   s5 = peg$FAILED;
                   if (peg$silentFails === 0) { peg$fail(peg$c41); }
                 }
                 if (s5 !== peg$FAILED) {
                   peg$savedPos = s0;
                   s1 = peg$c42(s1);
                   s0 = s1;
                 } else {
                   peg$currPos = s0;
                   s0 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s0;
                 s0 = peg$FAILED;
               }
             } else {
               peg$currPos = s0;
               s0 = peg$FAILED;
             }
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }
         if (s0 === peg$FAILED) {
           s0 = peg$currPos;
           if (input.substr(peg$currPos, 22) === peg$c43) {
             s1 = peg$c43;
             peg$currPos += 22;
           } else {
             s1 = peg$FAILED;
             if (peg$silentFails === 0) { peg$fail(peg$c44); }
           }
           if (s1 !== peg$FAILED) {
             s2 = peg$parse_();
             if (s2 !== peg$FAILED) {
               if (input.charCodeAt(peg$currPos) === 40) {
                 s3 = peg$c38;
                 peg$currPos++;
               } else {
                 s3 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c39); }
               }
               if (s3 !== peg$FAILED) {
                 s4 = peg$parse_();
                 if (s4 !== peg$FAILED) {
                   s5 = peg$parseLiteral();
                   if (s5 !== peg$FAILED) {
                     s6 = peg$parse_();
                     if (s6 !== peg$FAILED) {
                       if (input.charCodeAt(peg$currPos) === 41) {
                         s7 = peg$c40;
                         peg$currPos++;
                       } else {
                         s7 = peg$FAILED;
                         if (peg$silentFails === 0) { peg$fail(peg$c41); }
                       }
                       if (s7 !== peg$FAILED) {
                         peg$savedPos = s0;
                         s1 = peg$c45(s1, s5);
                         s0 = s1;
                       } else {
                         peg$currPos = s0;
                         s0 = peg$FAILED;
                       }
                     } else {
                       peg$currPos = s0;
                       s0 = peg$FAILED;
                     }
                   } else {
                     peg$currPos = s0;
                     s0 = peg$FAILED;
                   }
                 } else {
                   peg$currPos = s0;
                   s0 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s0;
                 s0 = peg$FAILED;
               }
             } else {
               peg$currPos = s0;
               s0 = peg$FAILED;
             }
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
           if (s0 === peg$FAILED) {
             s0 = peg$currPos;
             s1 = peg$parseNameTest();
             if (s1 !== peg$FAILED) {
               peg$savedPos = s0;
               s1 = peg$c46(s1);
             }
             s0 = s1;
           }
         }

         return s0;
       }

       function peg$parsePredicate() {
         var s0, s1, s2, s3, s4, s5;

         s0 = peg$currPos;
         if (input.charCodeAt(peg$currPos) === 91) {
           s1 = peg$c47;
           peg$currPos++;
         } else {
           s1 = peg$FAILED;
           if (peg$silentFails === 0) { peg$fail(peg$c48); }
         }
         if (s1 !== peg$FAILED) {
           s2 = peg$parse_();
           if (s2 !== peg$FAILED) {
             s3 = peg$parseExpr();
             if (s3 !== peg$FAILED) {
               s4 = peg$parse_();
               if (s4 !== peg$FAILED) {
                 if (input.charCodeAt(peg$currPos) === 93) {
                   s5 = peg$c49;
                   peg$currPos++;
                 } else {
                   s5 = peg$FAILED;
                   if (peg$silentFails === 0) { peg$fail(peg$c50); }
                 }
                 if (s5 !== peg$FAILED) {
                   peg$savedPos = s0;
                   s1 = peg$c51(s3);
                   s0 = s1;
                 } else {
                   peg$currPos = s0;
                   s0 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s0;
                 s0 = peg$FAILED;
               }
             } else {
               peg$currPos = s0;
               s0 = peg$FAILED;
             }
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parseAbbreviatedAbsoluteLocationPath() {
         var s0, s1, s2, s3;

         s0 = peg$currPos;
         if (input.substr(peg$currPos, 2) === peg$c4) {
           s1 = peg$c4;
           peg$currPos += 2;
         } else {
           s1 = peg$FAILED;
           if (peg$silentFails === 0) { peg$fail(peg$c5); }
         }
         if (s1 !== peg$FAILED) {
           s2 = peg$parse_();
           if (s2 !== peg$FAILED) {
             s3 = peg$parseRelativeLocationPath();
             if (s3 !== peg$FAILED) {
               peg$savedPos = s0;
               s1 = peg$c52(s3);
               s0 = s1;
             } else {
               peg$currPos = s0;
               s0 = peg$FAILED;
             }
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parseAbbreviatedStep() {
         var s0, s1;

         s0 = peg$currPos;
         if (input.substr(peg$currPos, 2) === peg$c53) {
           s1 = peg$c53;
           peg$currPos += 2;
         } else {
           s1 = peg$FAILED;
           if (peg$silentFails === 0) { peg$fail(peg$c54); }
         }
         if (s1 === peg$FAILED) {
           if (input.charCodeAt(peg$currPos) === 46) {
             s1 = peg$c55;
             peg$currPos++;
           } else {
             s1 = peg$FAILED;
             if (peg$silentFails === 0) { peg$fail(peg$c56); }
           }
         }
         if (s1 !== peg$FAILED) {
           peg$savedPos = s0;
           s1 = peg$c57(s1);
         }
         s0 = s1;

         return s0;
       }

       function peg$parseAbbreviatedAxisSpecifier() {
         var s0, s1;

         s0 = peg$currPos;
         if (input.charCodeAt(peg$currPos) === 64) {
           s1 = peg$c58;
           peg$currPos++;
         } else {
           s1 = peg$FAILED;
           if (peg$silentFails === 0) { peg$fail(peg$c59); }
         }
         if (s1 === peg$FAILED) {
           s1 = null;
         }
         if (s1 !== peg$FAILED) {
           peg$savedPos = s0;
           s1 = peg$c60(s1);
         }
         s0 = s1;

         return s0;
       }

       function peg$parseExpr() {
         var s0, s1;

         s0 = peg$currPos;
         s1 = peg$parseOrExpr();
         if (s1 !== peg$FAILED) {
           peg$savedPos = s0;
           s1 = peg$c51(s1);
         }
         s0 = s1;

         return s0;
       }

       function peg$parsePrimaryExpr() {
         var s0, s1, s2, s3, s4, s5;

         s0 = peg$currPos;
         s1 = peg$parseVariableReference();
         if (s1 !== peg$FAILED) {
           peg$savedPos = s0;
           s1 = peg$c61(s1);
         }
         s0 = s1;
         if (s0 === peg$FAILED) {
           s0 = peg$currPos;
           if (input.charCodeAt(peg$currPos) === 40) {
             s1 = peg$c38;
             peg$currPos++;
           } else {
             s1 = peg$FAILED;
             if (peg$silentFails === 0) { peg$fail(peg$c39); }
           }
           if (s1 !== peg$FAILED) {
             s2 = peg$parse_();
             if (s2 !== peg$FAILED) {
               s3 = peg$parseExpr();
               if (s3 !== peg$FAILED) {
                 s4 = peg$parse_();
                 if (s4 !== peg$FAILED) {
                   if (input.charCodeAt(peg$currPos) === 41) {
                     s5 = peg$c40;
                     peg$currPos++;
                   } else {
                     s5 = peg$FAILED;
                     if (peg$silentFails === 0) { peg$fail(peg$c41); }
                   }
                   if (s5 !== peg$FAILED) {
                     peg$savedPos = s0;
                     s1 = peg$c51(s3);
                     s0 = s1;
                   } else {
                     peg$currPos = s0;
                     s0 = peg$FAILED;
                   }
                 } else {
                   peg$currPos = s0;
                   s0 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s0;
                 s0 = peg$FAILED;
               }
             } else {
               peg$currPos = s0;
               s0 = peg$FAILED;
             }
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
           if (s0 === peg$FAILED) {
             s0 = peg$currPos;
             s1 = peg$parseLiteral();
             if (s1 !== peg$FAILED) {
               peg$savedPos = s0;
               s1 = peg$c62(s1);
             }
             s0 = s1;
             if (s0 === peg$FAILED) {
               s0 = peg$currPos;
               s1 = peg$parseNumber();
               if (s1 !== peg$FAILED) {
                 peg$savedPos = s0;
                 s1 = peg$c63(s1);
               }
               s0 = s1;
               if (s0 === peg$FAILED) {
                 s0 = peg$parseFunctionCall();
               }
             }
           }
         }

         return s0;
       }

       function peg$parseFunctionCall() {
         var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

         s0 = peg$currPos;
         s1 = peg$parseFunctionName();
         if (s1 !== peg$FAILED) {
           s2 = peg$parse_();
           if (s2 !== peg$FAILED) {
             if (input.charCodeAt(peg$currPos) === 40) {
               s3 = peg$c38;
               peg$currPos++;
             } else {
               s3 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c39); }
             }
             if (s3 !== peg$FAILED) {
               s4 = peg$currPos;
               s5 = peg$parse_();
               if (s5 !== peg$FAILED) {
                 s6 = peg$parseExpr();
                 if (s6 !== peg$FAILED) {
                   s7 = [];
                   s8 = peg$currPos;
                   s9 = peg$parse_();
                   if (s9 !== peg$FAILED) {
                     if (input.charCodeAt(peg$currPos) === 44) {
                       s10 = peg$c64;
                       peg$currPos++;
                     } else {
                       s10 = peg$FAILED;
                       if (peg$silentFails === 0) { peg$fail(peg$c65); }
                     }
                     if (s10 !== peg$FAILED) {
                       s11 = peg$parse_();
                       if (s11 !== peg$FAILED) {
                         s12 = peg$parseExpr();
                         if (s12 !== peg$FAILED) {
                           s9 = [s9, s10, s11, s12];
                           s8 = s9;
                         } else {
                           peg$currPos = s8;
                           s8 = peg$FAILED;
                         }
                       } else {
                         peg$currPos = s8;
                         s8 = peg$FAILED;
                       }
                     } else {
                       peg$currPos = s8;
                       s8 = peg$FAILED;
                     }
                   } else {
                     peg$currPos = s8;
                     s8 = peg$FAILED;
                   }
                   while (s8 !== peg$FAILED) {
                     s7.push(s8);
                     s8 = peg$currPos;
                     s9 = peg$parse_();
                     if (s9 !== peg$FAILED) {
                       if (input.charCodeAt(peg$currPos) === 44) {
                         s10 = peg$c64;
                         peg$currPos++;
                       } else {
                         s10 = peg$FAILED;
                         if (peg$silentFails === 0) { peg$fail(peg$c65); }
                       }
                       if (s10 !== peg$FAILED) {
                         s11 = peg$parse_();
                         if (s11 !== peg$FAILED) {
                           s12 = peg$parseExpr();
                           if (s12 !== peg$FAILED) {
                             s9 = [s9, s10, s11, s12];
                             s8 = s9;
                           } else {
                             peg$currPos = s8;
                             s8 = peg$FAILED;
                           }
                         } else {
                           peg$currPos = s8;
                           s8 = peg$FAILED;
                         }
                       } else {
                         peg$currPos = s8;
                         s8 = peg$FAILED;
                       }
                     } else {
                       peg$currPos = s8;
                       s8 = peg$FAILED;
                     }
                   }
                   if (s7 !== peg$FAILED) {
                     s5 = [s5, s6, s7];
                     s4 = s5;
                   } else {
                     peg$currPos = s4;
                     s4 = peg$FAILED;
                   }
                 } else {
                   peg$currPos = s4;
                   s4 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s4;
                 s4 = peg$FAILED;
               }
               if (s4 === peg$FAILED) {
                 s4 = null;
               }
               if (s4 !== peg$FAILED) {
                 s5 = peg$parse_();
                 if (s5 !== peg$FAILED) {
                   if (input.charCodeAt(peg$currPos) === 41) {
                     s6 = peg$c40;
                     peg$currPos++;
                   } else {
                     s6 = peg$FAILED;
                     if (peg$silentFails === 0) { peg$fail(peg$c41); }
                   }
                   if (s6 !== peg$FAILED) {
                     peg$savedPos = s0;
                     s1 = peg$c66(s1, s4);
                     s0 = s1;
                   } else {
                     peg$currPos = s0;
                     s0 = peg$FAILED;
                   }
                 } else {
                   peg$currPos = s0;
                   s0 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s0;
                 s0 = peg$FAILED;
               }
             } else {
               peg$currPos = s0;
               s0 = peg$FAILED;
             }
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parseUnionExpr() {
         var s0, s1, s2, s3, s4, s5, s6, s7;

         s0 = peg$currPos;
         s1 = peg$parsePathExpr();
         if (s1 !== peg$FAILED) {
           s2 = [];
           s3 = peg$currPos;
           s4 = peg$parse_();
           if (s4 !== peg$FAILED) {
             if (input.charCodeAt(peg$currPos) === 124) {
               s5 = peg$c67;
               peg$currPos++;
             } else {
               s5 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c68); }
             }
             if (s5 !== peg$FAILED) {
               s6 = peg$parse_();
               if (s6 !== peg$FAILED) {
                 s7 = peg$parsePathExpr();
                 if (s7 !== peg$FAILED) {
                   s4 = [s4, s5, s6, s7];
                   s3 = s4;
                 } else {
                   peg$currPos = s3;
                   s3 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           } else {
             peg$currPos = s3;
             s3 = peg$FAILED;
           }
           while (s3 !== peg$FAILED) {
             s2.push(s3);
             s3 = peg$currPos;
             s4 = peg$parse_();
             if (s4 !== peg$FAILED) {
               if (input.charCodeAt(peg$currPos) === 124) {
                 s5 = peg$c67;
                 peg$currPos++;
               } else {
                 s5 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c68); }
               }
               if (s5 !== peg$FAILED) {
                 s6 = peg$parse_();
                 if (s6 !== peg$FAILED) {
                   s7 = peg$parsePathExpr();
                   if (s7 !== peg$FAILED) {
                     s4 = [s4, s5, s6, s7];
                     s3 = s4;
                   } else {
                     peg$currPos = s3;
                     s3 = peg$FAILED;
                   }
                 } else {
                   peg$currPos = s3;
                   s3 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           }
           if (s2 !== peg$FAILED) {
             peg$savedPos = s0;
             s1 = peg$c69(s1, s2);
             s0 = s1;
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parsePathExpr() {
         var s0, s1, s2, s3, s4, s5, s6;

         s0 = peg$currPos;
         s1 = peg$parseFilterExpr();
         if (s1 !== peg$FAILED) {
           s2 = peg$currPos;
           s3 = peg$parse_();
           if (s3 !== peg$FAILED) {
             if (input.substr(peg$currPos, 2) === peg$c4) {
               s4 = peg$c4;
               peg$currPos += 2;
             } else {
               s4 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c5); }
             }
             if (s4 === peg$FAILED) {
               if (input.charCodeAt(peg$currPos) === 47) {
                 s4 = peg$c1;
                 peg$currPos++;
               } else {
                 s4 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c2); }
               }
             }
             if (s4 !== peg$FAILED) {
               s5 = peg$parse_();
               if (s5 !== peg$FAILED) {
                 s6 = peg$parseRelativeLocationPath();
                 if (s6 !== peg$FAILED) {
                   s3 = [s3, s4, s5, s6];
                   s2 = s3;
                 } else {
                   peg$currPos = s2;
                   s2 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s2;
                 s2 = peg$FAILED;
               }
             } else {
               peg$currPos = s2;
               s2 = peg$FAILED;
             }
           } else {
             peg$currPos = s2;
             s2 = peg$FAILED;
           }
           if (s2 === peg$FAILED) {
             s2 = null;
           }
           if (s2 !== peg$FAILED) {
             peg$savedPos = s0;
             s1 = peg$c70(s1, s2);
             s0 = s1;
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }
         if (s0 === peg$FAILED) {
           s0 = peg$currPos;
           s1 = peg$parseLocationPath();
           if (s1 !== peg$FAILED) {
             peg$savedPos = s0;
             s1 = peg$c71(s1);
           }
           s0 = s1;
         }

         return s0;
       }

       function peg$parseFilterExpr() {
         var s0, s1, s2, s3, s4, s5;

         s0 = peg$currPos;
         s1 = peg$parsePrimaryExpr();
         if (s1 !== peg$FAILED) {
           s2 = [];
           s3 = peg$currPos;
           s4 = peg$parse_();
           if (s4 !== peg$FAILED) {
             s5 = peg$parsePredicate();
             if (s5 !== peg$FAILED) {
               s4 = [s4, s5];
               s3 = s4;
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           } else {
             peg$currPos = s3;
             s3 = peg$FAILED;
           }
           while (s3 !== peg$FAILED) {
             s2.push(s3);
             s3 = peg$currPos;
             s4 = peg$parse_();
             if (s4 !== peg$FAILED) {
               s5 = peg$parsePredicate();
               if (s5 !== peg$FAILED) {
                 s4 = [s4, s5];
                 s3 = s4;
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           }
           if (s2 !== peg$FAILED) {
             peg$savedPos = s0;
             s1 = peg$c72(s1, s2);
             s0 = s1;
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parseOrExpr() {
         var s0, s1, s2, s3, s4, s5, s6, s7;

         s0 = peg$currPos;
         s1 = peg$parseAndExpr();
         if (s1 !== peg$FAILED) {
           s2 = [];
           s3 = peg$currPos;
           s4 = peg$parse_();
           if (s4 !== peg$FAILED) {
             if (input.substr(peg$currPos, 2) === peg$c73) {
               s5 = peg$c73;
               peg$currPos += 2;
             } else {
               s5 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c74); }
             }
             if (s5 !== peg$FAILED) {
               s6 = peg$parse_();
               if (s6 !== peg$FAILED) {
                 s7 = peg$parseAndExpr();
                 if (s7 !== peg$FAILED) {
                   s4 = [s4, s5, s6, s7];
                   s3 = s4;
                 } else {
                   peg$currPos = s3;
                   s3 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           } else {
             peg$currPos = s3;
             s3 = peg$FAILED;
           }
           while (s3 !== peg$FAILED) {
             s2.push(s3);
             s3 = peg$currPos;
             s4 = peg$parse_();
             if (s4 !== peg$FAILED) {
               if (input.substr(peg$currPos, 2) === peg$c73) {
                 s5 = peg$c73;
                 peg$currPos += 2;
               } else {
                 s5 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c74); }
               }
               if (s5 !== peg$FAILED) {
                 s6 = peg$parse_();
                 if (s6 !== peg$FAILED) {
                   s7 = peg$parseAndExpr();
                   if (s7 !== peg$FAILED) {
                     s4 = [s4, s5, s6, s7];
                     s3 = s4;
                   } else {
                     peg$currPos = s3;
                     s3 = peg$FAILED;
                   }
                 } else {
                   peg$currPos = s3;
                   s3 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           }
           if (s2 !== peg$FAILED) {
             peg$savedPos = s0;
             s1 = peg$c69(s1, s2);
             s0 = s1;
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parseAndExpr() {
         var s0, s1, s2, s3, s4, s5, s6, s7;

         s0 = peg$currPos;
         s1 = peg$parseEqualityExpr();
         if (s1 !== peg$FAILED) {
           s2 = [];
           s3 = peg$currPos;
           s4 = peg$parse_();
           if (s4 !== peg$FAILED) {
             if (input.substr(peg$currPos, 3) === peg$c75) {
               s5 = peg$c75;
               peg$currPos += 3;
             } else {
               s5 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c76); }
             }
             if (s5 !== peg$FAILED) {
               s6 = peg$parse_();
               if (s6 !== peg$FAILED) {
                 s7 = peg$parseEqualityExpr();
                 if (s7 !== peg$FAILED) {
                   s4 = [s4, s5, s6, s7];
                   s3 = s4;
                 } else {
                   peg$currPos = s3;
                   s3 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           } else {
             peg$currPos = s3;
             s3 = peg$FAILED;
           }
           while (s3 !== peg$FAILED) {
             s2.push(s3);
             s3 = peg$currPos;
             s4 = peg$parse_();
             if (s4 !== peg$FAILED) {
               if (input.substr(peg$currPos, 3) === peg$c75) {
                 s5 = peg$c75;
                 peg$currPos += 3;
               } else {
                 s5 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c76); }
               }
               if (s5 !== peg$FAILED) {
                 s6 = peg$parse_();
                 if (s6 !== peg$FAILED) {
                   s7 = peg$parseEqualityExpr();
                   if (s7 !== peg$FAILED) {
                     s4 = [s4, s5, s6, s7];
                     s3 = s4;
                   } else {
                     peg$currPos = s3;
                     s3 = peg$FAILED;
                   }
                 } else {
                   peg$currPos = s3;
                   s3 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           }
           if (s2 !== peg$FAILED) {
             peg$savedPos = s0;
             s1 = peg$c69(s1, s2);
             s0 = s1;
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parseEqualityExpr() {
         var s0, s1, s2, s3, s4, s5, s6, s7;

         s0 = peg$currPos;
         s1 = peg$parseRelationalExpr();
         if (s1 !== peg$FAILED) {
           s2 = [];
           s3 = peg$currPos;
           s4 = peg$parse_();
           if (s4 !== peg$FAILED) {
             if (input.charCodeAt(peg$currPos) === 61) {
               s5 = peg$c77;
               peg$currPos++;
             } else {
               s5 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c78); }
             }
             if (s5 === peg$FAILED) {
               if (input.substr(peg$currPos, 2) === peg$c79) {
                 s5 = peg$c79;
                 peg$currPos += 2;
               } else {
                 s5 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c80); }
               }
             }
             if (s5 !== peg$FAILED) {
               s6 = peg$parse_();
               if (s6 !== peg$FAILED) {
                 s7 = peg$parseRelationalExpr();
                 if (s7 !== peg$FAILED) {
                   s4 = [s4, s5, s6, s7];
                   s3 = s4;
                 } else {
                   peg$currPos = s3;
                   s3 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           } else {
             peg$currPos = s3;
             s3 = peg$FAILED;
           }
           while (s3 !== peg$FAILED) {
             s2.push(s3);
             s3 = peg$currPos;
             s4 = peg$parse_();
             if (s4 !== peg$FAILED) {
               if (input.charCodeAt(peg$currPos) === 61) {
                 s5 = peg$c77;
                 peg$currPos++;
               } else {
                 s5 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c78); }
               }
               if (s5 === peg$FAILED) {
                 if (input.substr(peg$currPos, 2) === peg$c79) {
                   s5 = peg$c79;
                   peg$currPos += 2;
                 } else {
                   s5 = peg$FAILED;
                   if (peg$silentFails === 0) { peg$fail(peg$c80); }
                 }
               }
               if (s5 !== peg$FAILED) {
                 s6 = peg$parse_();
                 if (s6 !== peg$FAILED) {
                   s7 = peg$parseRelationalExpr();
                   if (s7 !== peg$FAILED) {
                     s4 = [s4, s5, s6, s7];
                     s3 = s4;
                   } else {
                     peg$currPos = s3;
                     s3 = peg$FAILED;
                   }
                 } else {
                   peg$currPos = s3;
                   s3 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           }
           if (s2 !== peg$FAILED) {
             peg$savedPos = s0;
             s1 = peg$c69(s1, s2);
             s0 = s1;
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parseRelationalExpr() {
         var s0, s1, s2, s3, s4, s5, s6, s7;

         s0 = peg$currPos;
         s1 = peg$parseAdditiveExpr();
         if (s1 !== peg$FAILED) {
           s2 = [];
           s3 = peg$currPos;
           s4 = peg$parse_();
           if (s4 !== peg$FAILED) {
             if (input.substr(peg$currPos, 2) === peg$c81) {
               s5 = peg$c81;
               peg$currPos += 2;
             } else {
               s5 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c82); }
             }
             if (s5 === peg$FAILED) {
               if (input.charCodeAt(peg$currPos) === 60) {
                 s5 = peg$c83;
                 peg$currPos++;
               } else {
                 s5 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c84); }
               }
               if (s5 === peg$FAILED) {
                 if (input.substr(peg$currPos, 2) === peg$c85) {
                   s5 = peg$c85;
                   peg$currPos += 2;
                 } else {
                   s5 = peg$FAILED;
                   if (peg$silentFails === 0) { peg$fail(peg$c86); }
                 }
                 if (s5 === peg$FAILED) {
                   if (input.charCodeAt(peg$currPos) === 62) {
                     s5 = peg$c87;
                     peg$currPos++;
                   } else {
                     s5 = peg$FAILED;
                     if (peg$silentFails === 0) { peg$fail(peg$c88); }
                   }
                 }
               }
             }
             if (s5 !== peg$FAILED) {
               s6 = peg$parse_();
               if (s6 !== peg$FAILED) {
                 s7 = peg$parseAdditiveExpr();
                 if (s7 !== peg$FAILED) {
                   s4 = [s4, s5, s6, s7];
                   s3 = s4;
                 } else {
                   peg$currPos = s3;
                   s3 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           } else {
             peg$currPos = s3;
             s3 = peg$FAILED;
           }
           while (s3 !== peg$FAILED) {
             s2.push(s3);
             s3 = peg$currPos;
             s4 = peg$parse_();
             if (s4 !== peg$FAILED) {
               if (input.substr(peg$currPos, 2) === peg$c81) {
                 s5 = peg$c81;
                 peg$currPos += 2;
               } else {
                 s5 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c82); }
               }
               if (s5 === peg$FAILED) {
                 if (input.charCodeAt(peg$currPos) === 60) {
                   s5 = peg$c83;
                   peg$currPos++;
                 } else {
                   s5 = peg$FAILED;
                   if (peg$silentFails === 0) { peg$fail(peg$c84); }
                 }
                 if (s5 === peg$FAILED) {
                   if (input.substr(peg$currPos, 2) === peg$c85) {
                     s5 = peg$c85;
                     peg$currPos += 2;
                   } else {
                     s5 = peg$FAILED;
                     if (peg$silentFails === 0) { peg$fail(peg$c86); }
                   }
                   if (s5 === peg$FAILED) {
                     if (input.charCodeAt(peg$currPos) === 62) {
                       s5 = peg$c87;
                       peg$currPos++;
                     } else {
                       s5 = peg$FAILED;
                       if (peg$silentFails === 0) { peg$fail(peg$c88); }
                     }
                   }
                 }
               }
               if (s5 !== peg$FAILED) {
                 s6 = peg$parse_();
                 if (s6 !== peg$FAILED) {
                   s7 = peg$parseAdditiveExpr();
                   if (s7 !== peg$FAILED) {
                     s4 = [s4, s5, s6, s7];
                     s3 = s4;
                   } else {
                     peg$currPos = s3;
                     s3 = peg$FAILED;
                   }
                 } else {
                   peg$currPos = s3;
                   s3 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           }
           if (s2 !== peg$FAILED) {
             peg$savedPos = s0;
             s1 = peg$c69(s1, s2);
             s0 = s1;
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parseAdditiveExpr() {
         var s0, s1, s2, s3, s4, s5, s6, s7;

         s0 = peg$currPos;
         s1 = peg$parseMultiplicativeExpr();
         if (s1 !== peg$FAILED) {
           s2 = [];
           s3 = peg$currPos;
           s4 = peg$parse_();
           if (s4 !== peg$FAILED) {
             if (input.charCodeAt(peg$currPos) === 43) {
               s5 = peg$c89;
               peg$currPos++;
             } else {
               s5 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c90); }
             }
             if (s5 === peg$FAILED) {
               if (input.charCodeAt(peg$currPos) === 45) {
                 s5 = peg$c91;
                 peg$currPos++;
               } else {
                 s5 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c92); }
               }
             }
             if (s5 !== peg$FAILED) {
               s6 = peg$parse_();
               if (s6 !== peg$FAILED) {
                 s7 = peg$parseMultiplicativeExpr();
                 if (s7 !== peg$FAILED) {
                   s4 = [s4, s5, s6, s7];
                   s3 = s4;
                 } else {
                   peg$currPos = s3;
                   s3 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           } else {
             peg$currPos = s3;
             s3 = peg$FAILED;
           }
           while (s3 !== peg$FAILED) {
             s2.push(s3);
             s3 = peg$currPos;
             s4 = peg$parse_();
             if (s4 !== peg$FAILED) {
               if (input.charCodeAt(peg$currPos) === 43) {
                 s5 = peg$c89;
                 peg$currPos++;
               } else {
                 s5 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c90); }
               }
               if (s5 === peg$FAILED) {
                 if (input.charCodeAt(peg$currPos) === 45) {
                   s5 = peg$c91;
                   peg$currPos++;
                 } else {
                   s5 = peg$FAILED;
                   if (peg$silentFails === 0) { peg$fail(peg$c92); }
                 }
               }
               if (s5 !== peg$FAILED) {
                 s6 = peg$parse_();
                 if (s6 !== peg$FAILED) {
                   s7 = peg$parseMultiplicativeExpr();
                   if (s7 !== peg$FAILED) {
                     s4 = [s4, s5, s6, s7];
                     s3 = s4;
                   } else {
                     peg$currPos = s3;
                     s3 = peg$FAILED;
                   }
                 } else {
                   peg$currPos = s3;
                   s3 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           }
           if (s2 !== peg$FAILED) {
             peg$savedPos = s0;
             s1 = peg$c69(s1, s2);
             s0 = s1;
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parseMultiplicativeExpr() {
         var s0, s1, s2, s3, s4, s5, s6, s7;

         s0 = peg$currPos;
         s1 = peg$parseUnaryExpr();
         if (s1 !== peg$FAILED) {
           s2 = [];
           s3 = peg$currPos;
           s4 = peg$parse_();
           if (s4 !== peg$FAILED) {
             s5 = peg$parseMultiplyOperator();
             if (s5 === peg$FAILED) {
               if (input.substr(peg$currPos, 3) === peg$c93) {
                 s5 = peg$c93;
                 peg$currPos += 3;
               } else {
                 s5 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c94); }
               }
               if (s5 === peg$FAILED) {
                 if (input.substr(peg$currPos, 3) === peg$c95) {
                   s5 = peg$c95;
                   peg$currPos += 3;
                 } else {
                   s5 = peg$FAILED;
                   if (peg$silentFails === 0) { peg$fail(peg$c96); }
                 }
               }
             }
             if (s5 !== peg$FAILED) {
               s6 = peg$parse_();
               if (s6 !== peg$FAILED) {
                 s7 = peg$parseUnaryExpr();
                 if (s7 !== peg$FAILED) {
                   s4 = [s4, s5, s6, s7];
                   s3 = s4;
                 } else {
                   peg$currPos = s3;
                   s3 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           } else {
             peg$currPos = s3;
             s3 = peg$FAILED;
           }
           while (s3 !== peg$FAILED) {
             s2.push(s3);
             s3 = peg$currPos;
             s4 = peg$parse_();
             if (s4 !== peg$FAILED) {
               s5 = peg$parseMultiplyOperator();
               if (s5 === peg$FAILED) {
                 if (input.substr(peg$currPos, 3) === peg$c93) {
                   s5 = peg$c93;
                   peg$currPos += 3;
                 } else {
                   s5 = peg$FAILED;
                   if (peg$silentFails === 0) { peg$fail(peg$c94); }
                 }
                 if (s5 === peg$FAILED) {
                   if (input.substr(peg$currPos, 3) === peg$c95) {
                     s5 = peg$c95;
                     peg$currPos += 3;
                   } else {
                     s5 = peg$FAILED;
                     if (peg$silentFails === 0) { peg$fail(peg$c96); }
                   }
                 }
               }
               if (s5 !== peg$FAILED) {
                 s6 = peg$parse_();
                 if (s6 !== peg$FAILED) {
                   s7 = peg$parseUnaryExpr();
                   if (s7 !== peg$FAILED) {
                     s4 = [s4, s5, s6, s7];
                     s3 = s4;
                   } else {
                     peg$currPos = s3;
                     s3 = peg$FAILED;
                   }
                 } else {
                   peg$currPos = s3;
                   s3 = peg$FAILED;
                 }
               } else {
                 peg$currPos = s3;
                 s3 = peg$FAILED;
               }
             } else {
               peg$currPos = s3;
               s3 = peg$FAILED;
             }
           }
           if (s2 !== peg$FAILED) {
             peg$savedPos = s0;
             s1 = peg$c69(s1, s2);
             s0 = s1;
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parseUnaryExpr() {
         var s0, s1, s2, s3;

         s0 = peg$currPos;
         s1 = peg$parseUnionExpr();
         if (s1 !== peg$FAILED) {
           peg$savedPos = s0;
           s1 = peg$c51(s1);
         }
         s0 = s1;
         if (s0 === peg$FAILED) {
           s0 = peg$currPos;
           if (input.charCodeAt(peg$currPos) === 45) {
             s1 = peg$c91;
             peg$currPos++;
           } else {
             s1 = peg$FAILED;
             if (peg$silentFails === 0) { peg$fail(peg$c92); }
           }
           if (s1 !== peg$FAILED) {
             s2 = peg$parse_();
             if (s2 !== peg$FAILED) {
               s3 = peg$parseUnaryExpr();
               if (s3 !== peg$FAILED) {
                 peg$savedPos = s0;
                 s1 = peg$c97(s3);
                 s0 = s1;
               } else {
                 peg$currPos = s0;
                 s0 = peg$FAILED;
               }
             } else {
               peg$currPos = s0;
               s0 = peg$FAILED;
             }
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         }

         return s0;
       }

       function peg$parseLiteral() {
         var s0, s1, s2, s3;

         s0 = peg$currPos;
         if (input.charCodeAt(peg$currPos) === 34) {
           s1 = peg$c98;
           peg$currPos++;
         } else {
           s1 = peg$FAILED;
           if (peg$silentFails === 0) { peg$fail(peg$c99); }
         }
         if (s1 !== peg$FAILED) {
           s2 = [];
           if (peg$c100.test(input.charAt(peg$currPos))) {
             s3 = input.charAt(peg$currPos);
             peg$currPos++;
           } else {
             s3 = peg$FAILED;
             if (peg$silentFails === 0) { peg$fail(peg$c101); }
           }
           while (s3 !== peg$FAILED) {
             s2.push(s3);
             if (peg$c100.test(input.charAt(peg$currPos))) {
               s3 = input.charAt(peg$currPos);
               peg$currPos++;
             } else {
               s3 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c101); }
             }
           }
           if (s2 !== peg$FAILED) {
             if (input.charCodeAt(peg$currPos) === 34) {
               s3 = peg$c98;
               peg$currPos++;
             } else {
               s3 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c99); }
             }
             if (s3 !== peg$FAILED) {
               peg$savedPos = s0;
               s1 = peg$c102(s2);
               s0 = s1;
             } else {
               peg$currPos = s0;
               s0 = peg$FAILED;
             }
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }
         if (s0 === peg$FAILED) {
           s0 = peg$currPos;
           if (input.charCodeAt(peg$currPos) === 39) {
             s1 = peg$c103;
             peg$currPos++;
           } else {
             s1 = peg$FAILED;
             if (peg$silentFails === 0) { peg$fail(peg$c104); }
           }
           if (s1 !== peg$FAILED) {
             s2 = [];
             if (peg$c105.test(input.charAt(peg$currPos))) {
               s3 = input.charAt(peg$currPos);
               peg$currPos++;
             } else {
               s3 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c106); }
             }
             while (s3 !== peg$FAILED) {
               s2.push(s3);
               if (peg$c105.test(input.charAt(peg$currPos))) {
                 s3 = input.charAt(peg$currPos);
                 peg$currPos++;
               } else {
                 s3 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c106); }
               }
             }
             if (s2 !== peg$FAILED) {
               if (input.charCodeAt(peg$currPos) === 39) {
                 s3 = peg$c103;
                 peg$currPos++;
               } else {
                 s3 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c104); }
               }
               if (s3 !== peg$FAILED) {
                 peg$savedPos = s0;
                 s1 = peg$c102(s2);
                 s0 = s1;
               } else {
                 peg$currPos = s0;
                 s0 = peg$FAILED;
               }
             } else {
               peg$currPos = s0;
               s0 = peg$FAILED;
             }
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         }

         return s0;
       }

       function peg$parseNumber() {
         var s0, s1, s2, s3, s4;

         s0 = peg$currPos;
         s1 = peg$parseDigits();
         if (s1 !== peg$FAILED) {
           s2 = peg$currPos;
           if (input.charCodeAt(peg$currPos) === 46) {
             s3 = peg$c55;
             peg$currPos++;
           } else {
             s3 = peg$FAILED;
             if (peg$silentFails === 0) { peg$fail(peg$c56); }
           }
           if (s3 !== peg$FAILED) {
             s4 = peg$parseDigits();
             if (s4 === peg$FAILED) {
               s4 = null;
             }
             if (s4 !== peg$FAILED) {
               s3 = [s3, s4];
               s2 = s3;
             } else {
               peg$currPos = s2;
               s2 = peg$FAILED;
             }
           } else {
             peg$currPos = s2;
             s2 = peg$FAILED;
           }
           if (s2 === peg$FAILED) {
             s2 = null;
           }
           if (s2 !== peg$FAILED) {
             peg$savedPos = s0;
             s1 = peg$c107(s1, s2);
             s0 = s1;
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }
         if (s0 === peg$FAILED) {
           s0 = peg$currPos;
           if (input.charCodeAt(peg$currPos) === 46) {
             s1 = peg$c55;
             peg$currPos++;
           } else {
             s1 = peg$FAILED;
             if (peg$silentFails === 0) { peg$fail(peg$c56); }
           }
           if (s1 !== peg$FAILED) {
             s2 = peg$parseDigits();
             if (s2 !== peg$FAILED) {
               peg$savedPos = s0;
               s1 = peg$c108(s2);
               s0 = s1;
             } else {
               peg$currPos = s0;
               s0 = peg$FAILED;
             }
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         }

         return s0;
       }

       function peg$parseDigits() {
         var s0, s1, s2;

         s0 = peg$currPos;
         s1 = [];
         if (peg$c109.test(input.charAt(peg$currPos))) {
           s2 = input.charAt(peg$currPos);
           peg$currPos++;
         } else {
           s2 = peg$FAILED;
           if (peg$silentFails === 0) { peg$fail(peg$c110); }
         }
         if (s2 !== peg$FAILED) {
           while (s2 !== peg$FAILED) {
             s1.push(s2);
             if (peg$c109.test(input.charAt(peg$currPos))) {
               s2 = input.charAt(peg$currPos);
               peg$currPos++;
             } else {
               s2 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c110); }
             }
           }
         } else {
           s1 = peg$FAILED;
         }
         if (s1 !== peg$FAILED) {
           peg$savedPos = s0;
           s1 = peg$c111(s1);
         }
         s0 = s1;

         return s0;
       }

       function peg$parseMultiplyOperator() {
         var s0;

         if (input.charCodeAt(peg$currPos) === 42) {
           s0 = peg$c112;
           peg$currPos++;
         } else {
           s0 = peg$FAILED;
           if (peg$silentFails === 0) { peg$fail(peg$c113); }
         }

         return s0;
       }

       function peg$parseFunctionName() {
         var s0, s1, s2;

         s0 = peg$currPos;
         s1 = peg$parseQName();
         if (s1 !== peg$FAILED) {
           peg$savedPos = peg$currPos;
           s2 = peg$c114(s1);
           if (s2) {
             s2 = void 0;
           } else {
             s2 = peg$FAILED;
           }
           if (s2 !== peg$FAILED) {
             peg$savedPos = s0;
             s1 = peg$c115(s1);
             s0 = s1;
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parseVariableReference() {
         var s0, s1, s2;

         s0 = peg$currPos;
         if (input.charCodeAt(peg$currPos) === 36) {
           s1 = peg$c116;
           peg$currPos++;
         } else {
           s1 = peg$FAILED;
           if (peg$silentFails === 0) { peg$fail(peg$c117); }
         }
         if (s1 !== peg$FAILED) {
           s2 = peg$parseQName();
           if (s2 !== peg$FAILED) {
             peg$savedPos = s0;
             s1 = peg$c118(s2);
             s0 = s1;
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parseNameTest() {
         var s0, s1, s2, s3;

         s0 = peg$currPos;
         if (input.charCodeAt(peg$currPos) === 42) {
           s1 = peg$c112;
           peg$currPos++;
         } else {
           s1 = peg$FAILED;
           if (peg$silentFails === 0) { peg$fail(peg$c113); }
         }
         if (s1 !== peg$FAILED) {
           peg$savedPos = s0;
           s1 = peg$c119();
         }
         s0 = s1;
         if (s0 === peg$FAILED) {
           s0 = peg$currPos;
           s1 = peg$parseNCName();
           if (s1 !== peg$FAILED) {
             if (input.charCodeAt(peg$currPos) === 58) {
               s2 = peg$c120;
               peg$currPos++;
             } else {
               s2 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c121); }
             }
             if (s2 !== peg$FAILED) {
               if (input.charCodeAt(peg$currPos) === 42) {
                 s3 = peg$c112;
                 peg$currPos++;
               } else {
                 s3 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c113); }
               }
               if (s3 !== peg$FAILED) {
                 peg$savedPos = s0;
                 s1 = peg$c122(s1);
                 s0 = s1;
               } else {
                 peg$currPos = s0;
                 s0 = peg$FAILED;
               }
             } else {
               peg$currPos = s0;
               s0 = peg$FAILED;
             }
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
           if (s0 === peg$FAILED) {
             s0 = peg$currPos;
             s1 = peg$parseQName();
             if (s1 !== peg$FAILED) {
               peg$savedPos = s0;
               s1 = peg$c123(s1);
             }
             s0 = s1;
           }
         }

         return s0;
       }

       function peg$parseNodeType() {
         var s0;

         if (input.substr(peg$currPos, 7) === peg$c124) {
           s0 = peg$c124;
           peg$currPos += 7;
         } else {
           s0 = peg$FAILED;
           if (peg$silentFails === 0) { peg$fail(peg$c125); }
         }
         if (s0 === peg$FAILED) {
           if (input.substr(peg$currPos, 4) === peg$c126) {
             s0 = peg$c126;
             peg$currPos += 4;
           } else {
             s0 = peg$FAILED;
             if (peg$silentFails === 0) { peg$fail(peg$c127); }
           }
           if (s0 === peg$FAILED) {
             if (input.substr(peg$currPos, 22) === peg$c43) {
               s0 = peg$c43;
               peg$currPos += 22;
             } else {
               s0 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c44); }
             }
             if (s0 === peg$FAILED) {
               if (input.substr(peg$currPos, 4) === peg$c128) {
                 s0 = peg$c128;
                 peg$currPos += 4;
               } else {
                 s0 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c129); }
               }
             }
           }
         }

         return s0;
       }

       function peg$parseS() {
         var s0, s1;

         s0 = [];
         if (peg$c130.test(input.charAt(peg$currPos))) {
           s1 = input.charAt(peg$currPos);
           peg$currPos++;
         } else {
           s1 = peg$FAILED;
           if (peg$silentFails === 0) { peg$fail(peg$c131); }
         }
         if (s1 !== peg$FAILED) {
           while (s1 !== peg$FAILED) {
             s0.push(s1);
             if (peg$c130.test(input.charAt(peg$currPos))) {
               s1 = input.charAt(peg$currPos);
               peg$currPos++;
             } else {
               s1 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c131); }
             }
           }
         } else {
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parse_() {
         var s0;

         s0 = peg$parseS();
         if (s0 === peg$FAILED) {
           s0 = null;
         }

         return s0;
       }

       function peg$parseQName() {
         var s0, s1;

         s0 = peg$currPos;
         s1 = peg$parsePrefixedName();
         if (s1 === peg$FAILED) {
           s1 = peg$parseUnprefixedName();
         }
         if (s1 !== peg$FAILED) {
           peg$savedPos = s0;
           s1 = peg$c132(s1);
         }
         s0 = s1;

         return s0;
       }

       function peg$parsePrefixedName() {
         var s0, s1, s2, s3;

         s0 = peg$currPos;
         s1 = peg$parseNCName();
         if (s1 !== peg$FAILED) {
           if (input.charCodeAt(peg$currPos) === 58) {
             s2 = peg$c120;
             peg$currPos++;
           } else {
             s2 = peg$FAILED;
             if (peg$silentFails === 0) { peg$fail(peg$c121); }
           }
           if (s2 !== peg$FAILED) {
             s3 = peg$parseNCName();
             if (s3 !== peg$FAILED) {
               peg$savedPos = s0;
               s1 = peg$c133(s1, s3);
               s0 = s1;
             } else {
               peg$currPos = s0;
               s0 = peg$FAILED;
             }
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }

       function peg$parseUnprefixedName() {
         var s0, s1;

         s0 = peg$currPos;
         s1 = peg$parseNCName();
         if (s1 !== peg$FAILED) {
           peg$savedPos = s0;
           s1 = peg$c134(s1);
         }
         s0 = s1;

         return s0;
       }

       function peg$parseNCName() {
         var s0;

         s0 = peg$parseName();

         return s0;
       }

       function peg$parseNameStartChar() {
         var s0;

         if (peg$c135.test(input.charAt(peg$currPos))) {
           s0 = input.charAt(peg$currPos);
           peg$currPos++;
         } else {
           s0 = peg$FAILED;
           if (peg$silentFails === 0) { peg$fail(peg$c136); }
         }
         if (s0 === peg$FAILED) {
           if (input.charCodeAt(peg$currPos) === 95) {
             s0 = peg$c137;
             peg$currPos++;
           } else {
             s0 = peg$FAILED;
             if (peg$silentFails === 0) { peg$fail(peg$c138); }
           }
           if (s0 === peg$FAILED) {
             if (peg$c139.test(input.charAt(peg$currPos))) {
               s0 = input.charAt(peg$currPos);
               peg$currPos++;
             } else {
               s0 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c140); }
             }
             if (s0 === peg$FAILED) {
               if (peg$c141.test(input.charAt(peg$currPos))) {
                 s0 = input.charAt(peg$currPos);
                 peg$currPos++;
               } else {
                 s0 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c142); }
               }
               if (s0 === peg$FAILED) {
                 if (peg$c143.test(input.charAt(peg$currPos))) {
                   s0 = input.charAt(peg$currPos);
                   peg$currPos++;
                 } else {
                   s0 = peg$FAILED;
                   if (peg$silentFails === 0) { peg$fail(peg$c144); }
                 }
                 if (s0 === peg$FAILED) {
                   if (peg$c145.test(input.charAt(peg$currPos))) {
                     s0 = input.charAt(peg$currPos);
                     peg$currPos++;
                   } else {
                     s0 = peg$FAILED;
                     if (peg$silentFails === 0) { peg$fail(peg$c146); }
                   }
                   if (s0 === peg$FAILED) {
                     if (peg$c147.test(input.charAt(peg$currPos))) {
                       s0 = input.charAt(peg$currPos);
                       peg$currPos++;
                     } else {
                       s0 = peg$FAILED;
                       if (peg$silentFails === 0) { peg$fail(peg$c148); }
                     }
                     if (s0 === peg$FAILED) {
                       if (peg$c149.test(input.charAt(peg$currPos))) {
                         s0 = input.charAt(peg$currPos);
                         peg$currPos++;
                       } else {
                         s0 = peg$FAILED;
                         if (peg$silentFails === 0) { peg$fail(peg$c150); }
                       }
                       if (s0 === peg$FAILED) {
                         if (peg$c151.test(input.charAt(peg$currPos))) {
                           s0 = input.charAt(peg$currPos);
                           peg$currPos++;
                         } else {
                           s0 = peg$FAILED;
                           if (peg$silentFails === 0) { peg$fail(peg$c152); }
                         }
                         if (s0 === peg$FAILED) {
                           if (peg$c153.test(input.charAt(peg$currPos))) {
                             s0 = input.charAt(peg$currPos);
                             peg$currPos++;
                           } else {
                             s0 = peg$FAILED;
                             if (peg$silentFails === 0) { peg$fail(peg$c154); }
                           }
                           if (s0 === peg$FAILED) {
                             if (peg$c155.test(input.charAt(peg$currPos))) {
                               s0 = input.charAt(peg$currPos);
                               peg$currPos++;
                             } else {
                               s0 = peg$FAILED;
                               if (peg$silentFails === 0) { peg$fail(peg$c156); }
                             }
                             if (s0 === peg$FAILED) {
                               if (peg$c157.test(input.charAt(peg$currPos))) {
                                 s0 = input.charAt(peg$currPos);
                                 peg$currPos++;
                               } else {
                                 s0 = peg$FAILED;
                                 if (peg$silentFails === 0) { peg$fail(peg$c158); }
                               }
                               if (s0 === peg$FAILED) {
                                 if (peg$c159.test(input.charAt(peg$currPos))) {
                                   s0 = input.charAt(peg$currPos);
                                   peg$currPos++;
                                 } else {
                                   s0 = peg$FAILED;
                                   if (peg$silentFails === 0) { peg$fail(peg$c160); }
                                 }
                                 if (s0 === peg$FAILED) {
                                   if (peg$c161.test(input.charAt(peg$currPos))) {
                                     s0 = input.charAt(peg$currPos);
                                     peg$currPos++;
                                   } else {
                                     s0 = peg$FAILED;
                                     if (peg$silentFails === 0) { peg$fail(peg$c162); }
                                   }
                                 }
                               }
                             }
                           }
                         }
                       }
                     }
                   }
                 }
               }
             }
           }
         }

         return s0;
       }

       function peg$parseNameChar() {
         var s0;

         s0 = peg$parseNameStartChar();
         if (s0 === peg$FAILED) {
           if (input.charCodeAt(peg$currPos) === 45) {
             s0 = peg$c91;
             peg$currPos++;
           } else {
             s0 = peg$FAILED;
             if (peg$silentFails === 0) { peg$fail(peg$c92); }
           }
           if (s0 === peg$FAILED) {
             if (input.charCodeAt(peg$currPos) === 46) {
               s0 = peg$c55;
               peg$currPos++;
             } else {
               s0 = peg$FAILED;
               if (peg$silentFails === 0) { peg$fail(peg$c56); }
             }
             if (s0 === peg$FAILED) {
               if (peg$c109.test(input.charAt(peg$currPos))) {
                 s0 = input.charAt(peg$currPos);
                 peg$currPos++;
               } else {
                 s0 = peg$FAILED;
                 if (peg$silentFails === 0) { peg$fail(peg$c110); }
               }
               if (s0 === peg$FAILED) {
                 if (peg$c163.test(input.charAt(peg$currPos))) {
                   s0 = input.charAt(peg$currPos);
                   peg$currPos++;
                 } else {
                   s0 = peg$FAILED;
                   if (peg$silentFails === 0) { peg$fail(peg$c164); }
                 }
                 if (s0 === peg$FAILED) {
                   if (peg$c165.test(input.charAt(peg$currPos))) {
                     s0 = input.charAt(peg$currPos);
                     peg$currPos++;
                   } else {
                     s0 = peg$FAILED;
                     if (peg$silentFails === 0) { peg$fail(peg$c166); }
                   }
                   if (s0 === peg$FAILED) {
                     if (peg$c167.test(input.charAt(peg$currPos))) {
                       s0 = input.charAt(peg$currPos);
                       peg$currPos++;
                     } else {
                       s0 = peg$FAILED;
                       if (peg$silentFails === 0) { peg$fail(peg$c168); }
                     }
                   }
                 }
               }
             }
           }
         }

         return s0;
       }

       function peg$parseName() {
         var s0, s1, s2, s3;

         s0 = peg$currPos;
         s1 = peg$parseNameStartChar();
         if (s1 !== peg$FAILED) {
           s2 = [];
           s3 = peg$parseNameChar();
           while (s3 !== peg$FAILED) {
             s2.push(s3);
             s3 = peg$parseNameChar();
           }
           if (s2 !== peg$FAILED) {
             peg$savedPos = s0;
             s1 = peg$c169(s1, s2);
             s0 = s1;
           } else {
             peg$currPos = s0;
             s0 = peg$FAILED;
           }
         } else {
           peg$currPos = s0;
           s0 = peg$FAILED;
         }

         return s0;
       }


       	var expressionSimplifier = function(left, right, rightTypeIndex, rightPartIndex)
       	{
       		var  i, j
       			,result = {
       				type: '',
       				args: []
       			}
       		;

       		result.args.push(left);
       		for(i = 0; i < right.length; i++)
       		{
       			switch(typeof rightTypeIndex)
       			{
       				case 'string':
       					result.type = rightTypeIndex;
       					break;

       				case 'object':
       					result.type = right[i][rightTypeIndex[0]];
       					for(j=1; j < rightTypeIndex.length; j++)
       					{
       						result.type = result.type[rightTypeIndex[j]];
       					}
       					break;

       				default:
       					result.type = right[i][rightTypeIndex];
       					break;
       			}
       			result.args.push(
       				(typeof rightPartIndex == 'undefined') ? right[i] : right[i][rightPartIndex]
       			);

       			result = {
       				type: '',
       				args:[
       					result
       				]
       			};
       		}

       		return result.args[0];
       	}

       	,predicateExpression = function(expr, axis, predicate, predicateIndex)
       	{
       		var i, predicates = [];

       		if (predicate.length < 1)
       		{
       			return expr;
       		}

       		for (i=0; i < predicate.length; i++)
       		{
       			predicates.push(predicate[i][predicateIndex]);
       		}

       		return {
       			type: 'predicate',
       			args: [
       				axis,
       				expr,
       				predicates
       			]
       		}
       	}

       	// Track all namespace prefixes used in the expression
       	,nsPrefixes = []

       	,trackNsPrefix = function(ns)
       	{
       		var  i
       			,nsPrefixExists = false
       		;

       		if (ns === null) return;

       		// add namespace to the list of namespaces
       		for (i = 0; i < nsPrefixes.length; i++) {
       			if (nsPrefixes[i] === ns) {
       				nsPrefixExists = true;
       				break;
       			}
       		}

       		if (!nsPrefixExists)
       		{
       			nsPrefixes.push(ns);
       		}
       	}

       	,lastQNameParsed
       	,nodeTypeNames = [
       		'comment',
       		'text',
       		'processing-instruction',
       		'node'
       	]
       	,expandSlashAbbrev = function(slash, left, right)
       	{
       		if (slash == '/')
       		{
       			return {
       				type: '/',
       				args: [
       					left,
       					right
       				]
       			};
       		}

       		// slash == '//'
       		return {
       			type: '/',
       			args: [
       				{
       					type: '/',
       					args: [
       						left,
       						{
       							type: 'step',
       							args: [
       								'descendant-or-self',
       								{
       									type: 'nodeType',
       									args: [
       										'node',
       										[]
       									]
       								}
       							]
       						}
       					]
       				},
       				right
       			]
       		};
       	}
       	;


       peg$result = peg$startRuleFunction();

       if (peg$result !== peg$FAILED && peg$currPos === input.length) {
         return peg$result;
       } else {
         if (peg$result !== peg$FAILED && peg$currPos < input.length) {
           peg$fail({ type: "end", description: "end of input" });
         }

         throw peg$buildException(
           null,
           peg$maxFailExpected,
           peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
           peg$maxFailPos < input.length
             ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
             : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
         );
       }
     }

     return {
       SyntaxError: peg$SyntaxError,
       parse:       peg$parse
     };
   })();
   'use strict';

   // export as AMD/CommonJS/Global-friendly module
   (function (root, factory) {
       if (typeof define === 'function' && define.amd) {
           define([], factory);
       } else if (typeof module === 'object' && module.exports) {
           module.exports = factory();
       } else {
           // Browser globals (root is window)
           root.returnExports = factory();
     }
   }(this, function () {
       return XPathJS;
   }));
   },{}],
   "jquery-touchswipe":[function(require,module,exports){
   /*!
    * @fileOverview TouchSwipe - jQuery Plugin
    * @version 1.6.18
    *
    * @author Matt Bryson http://www.github.com/mattbryson
    * @see https://github.com/mattbryson/TouchSwipe-Jquery-Plugin
    * @see http://labs.rampinteractive.co.uk/touchSwipe/
    * @see http://plugins.jquery.com/project/touchSwipe
    * @license
    * Copyright (c) 2010-2015 Matt Bryson
    * Dual licensed under the MIT or GPL Version 2 licenses.
    *
    */
   !function(factory){"function"==typeof define&&define.amd&&define.amd.jQuery?define(["jquery"],factory):factory("undefined"!=typeof module&&module.exports?require("jquery"):jQuery)}(function($){"use strict";function init(options){return!options||void 0!==options.allowPageScroll||void 0===options.swipe&&void 0===options.swipeStatus||(options.allowPageScroll=NONE),void 0!==options.click&&void 0===options.tap&&(options.tap=options.click),options||(options={}),options=$.extend({},$.fn.swipe.defaults,options),this.each(function(){var $this=$(this),plugin=$this.data(PLUGIN_NS);plugin||(plugin=new TouchSwipe(this,options),$this.data(PLUGIN_NS,plugin))})}function TouchSwipe(element,options){function touchStart(jqEvent){if(!(getTouchInProgress()||$(jqEvent.target).closest(options.excludedElements,$element).length>0)){var event=jqEvent.originalEvent?jqEvent.originalEvent:jqEvent;if(!event.pointerType||"mouse"!=event.pointerType||0!=options.fallbackToMouseEvents){var ret,touches=event.touches,evt=touches?touches[0]:event;return phase=PHASE_START,touches?fingerCount=touches.length:options.preventDefaultEvents!==!1&&jqEvent.preventDefault(),distance=0,direction=null,currentDirection=null,pinchDirection=null,duration=0,startTouchesDistance=0,endTouchesDistance=0,pinchZoom=1,pinchDistance=0,maximumsMap=createMaximumsData(),cancelMultiFingerRelease(),createFingerData(0,evt),!touches||fingerCount===options.fingers||options.fingers===ALL_FINGERS||hasPinches()?(startTime=getTimeStamp(),2==fingerCount&&(createFingerData(1,touches[1]),startTouchesDistance=endTouchesDistance=calculateTouchesDistance(fingerData[0].start,fingerData[1].start)),(options.swipeStatus||options.pinchStatus)&&(ret=triggerHandler(event,phase))):ret=!1,ret===!1?(phase=PHASE_CANCEL,triggerHandler(event,phase),ret):(options.hold&&(holdTimeout=setTimeout($.proxy(function(){$element.trigger("hold",[event.target]),options.hold&&(ret=options.hold.call($element,event,event.target))},this),options.longTapThreshold)),setTouchInProgress(!0),null)}}}function touchMove(jqEvent){var event=jqEvent.originalEvent?jqEvent.originalEvent:jqEvent;if(phase!==PHASE_END&&phase!==PHASE_CANCEL&&!inMultiFingerRelease()){var ret,touches=event.touches,evt=touches?touches[0]:event,currentFinger=updateFingerData(evt);if(endTime=getTimeStamp(),touches&&(fingerCount=touches.length),options.hold&&clearTimeout(holdTimeout),phase=PHASE_MOVE,2==fingerCount&&(0==startTouchesDistance?(createFingerData(1,touches[1]),startTouchesDistance=endTouchesDistance=calculateTouchesDistance(fingerData[0].start,fingerData[1].start)):(updateFingerData(touches[1]),endTouchesDistance=calculateTouchesDistance(fingerData[0].end,fingerData[1].end),pinchDirection=calculatePinchDirection(fingerData[0].end,fingerData[1].end)),pinchZoom=calculatePinchZoom(startTouchesDistance,endTouchesDistance),pinchDistance=Math.abs(startTouchesDistance-endTouchesDistance)),fingerCount===options.fingers||options.fingers===ALL_FINGERS||!touches||hasPinches()){if(direction=calculateDirection(currentFinger.start,currentFinger.end),currentDirection=calculateDirection(currentFinger.last,currentFinger.end),validateDefaultEvent(jqEvent,currentDirection),distance=calculateDistance(currentFinger.start,currentFinger.end),duration=calculateDuration(),setMaxDistance(direction,distance),ret=triggerHandler(event,phase),!options.triggerOnTouchEnd||options.triggerOnTouchLeave){var inBounds=!0;if(options.triggerOnTouchLeave){var bounds=getbounds(this);inBounds=isInBounds(currentFinger.end,bounds)}!options.triggerOnTouchEnd&&inBounds?phase=getNextPhase(PHASE_MOVE):options.triggerOnTouchLeave&&!inBounds&&(phase=getNextPhase(PHASE_END)),phase!=PHASE_CANCEL&&phase!=PHASE_END||triggerHandler(event,phase)}}else phase=PHASE_CANCEL,triggerHandler(event,phase);ret===!1&&(phase=PHASE_CANCEL,triggerHandler(event,phase))}}function touchEnd(jqEvent){var event=jqEvent.originalEvent?jqEvent.originalEvent:jqEvent,touches=event.touches;if(touches){if(touches.length&&!inMultiFingerRelease())return startMultiFingerRelease(event),!0;if(touches.length&&inMultiFingerRelease())return!0}return inMultiFingerRelease()&&(fingerCount=fingerCountAtRelease),endTime=getTimeStamp(),duration=calculateDuration(),didSwipeBackToCancel()||!validateSwipeDistance()?(phase=PHASE_CANCEL,triggerHandler(event,phase)):options.triggerOnTouchEnd||options.triggerOnTouchEnd===!1&&phase===PHASE_MOVE?(options.preventDefaultEvents!==!1&&jqEvent.preventDefault(),phase=PHASE_END,triggerHandler(event,phase)):!options.triggerOnTouchEnd&&hasTap()?(phase=PHASE_END,triggerHandlerForGesture(event,phase,TAP)):phase===PHASE_MOVE&&(phase=PHASE_CANCEL,triggerHandler(event,phase)),setTouchInProgress(!1),null}function touchCancel(){fingerCount=0,endTime=0,startTime=0,startTouchesDistance=0,endTouchesDistance=0,pinchZoom=1,cancelMultiFingerRelease(),setTouchInProgress(!1)}function touchLeave(jqEvent){var event=jqEvent.originalEvent?jqEvent.originalEvent:jqEvent;options.triggerOnTouchLeave&&(phase=getNextPhase(PHASE_END),triggerHandler(event,phase))}function removeListeners(){$element.unbind(START_EV,touchStart),$element.unbind(CANCEL_EV,touchCancel),$element.unbind(MOVE_EV,touchMove),$element.unbind(END_EV,touchEnd),LEAVE_EV&&$element.unbind(LEAVE_EV,touchLeave),setTouchInProgress(!1)}function getNextPhase(currentPhase){var nextPhase=currentPhase,validTime=validateSwipeTime(),validDistance=validateSwipeDistance(),didCancel=didSwipeBackToCancel();return!validTime||didCancel?nextPhase=PHASE_CANCEL:!validDistance||currentPhase!=PHASE_MOVE||options.triggerOnTouchEnd&&!options.triggerOnTouchLeave?!validDistance&&currentPhase==PHASE_END&&options.triggerOnTouchLeave&&(nextPhase=PHASE_CANCEL):nextPhase=PHASE_END,nextPhase}function triggerHandler(event,phase){var ret,touches=event.touches;return(didSwipe()||hasSwipes())&&(ret=triggerHandlerForGesture(event,phase,SWIPE)),(didPinch()||hasPinches())&&ret!==!1&&(ret=triggerHandlerForGesture(event,phase,PINCH)),didDoubleTap()&&ret!==!1?ret=triggerHandlerForGesture(event,phase,DOUBLE_TAP):didLongTap()&&ret!==!1?ret=triggerHandlerForGesture(event,phase,LONG_TAP):didTap()&&ret!==!1&&(ret=triggerHandlerForGesture(event,phase,TAP)),phase===PHASE_CANCEL&&touchCancel(event),phase===PHASE_END&&(touches?touches.length||touchCancel(event):touchCancel(event)),ret}function triggerHandlerForGesture(event,phase,gesture){var ret;if(gesture==SWIPE){if($element.trigger("swipeStatus",[phase,direction||null,distance||0,duration||0,fingerCount,fingerData,currentDirection]),options.swipeStatus&&(ret=options.swipeStatus.call($element,event,phase,direction||null,distance||0,duration||0,fingerCount,fingerData,currentDirection),ret===!1))return!1;if(phase==PHASE_END&&validateSwipe()){if(clearTimeout(singleTapTimeout),clearTimeout(holdTimeout),$element.trigger("swipe",[direction,distance,duration,fingerCount,fingerData,currentDirection]),options.swipe&&(ret=options.swipe.call($element,event,direction,distance,duration,fingerCount,fingerData,currentDirection),ret===!1))return!1;switch(direction){case LEFT:$element.trigger("swipeLeft",[direction,distance,duration,fingerCount,fingerData,currentDirection]),options.swipeLeft&&(ret=options.swipeLeft.call($element,event,direction,distance,duration,fingerCount,fingerData,currentDirection));break;case RIGHT:$element.trigger("swipeRight",[direction,distance,duration,fingerCount,fingerData,currentDirection]),options.swipeRight&&(ret=options.swipeRight.call($element,event,direction,distance,duration,fingerCount,fingerData,currentDirection));break;case UP:$element.trigger("swipeUp",[direction,distance,duration,fingerCount,fingerData,currentDirection]),options.swipeUp&&(ret=options.swipeUp.call($element,event,direction,distance,duration,fingerCount,fingerData,currentDirection));break;case DOWN:$element.trigger("swipeDown",[direction,distance,duration,fingerCount,fingerData,currentDirection]),options.swipeDown&&(ret=options.swipeDown.call($element,event,direction,distance,duration,fingerCount,fingerData,currentDirection))}}}if(gesture==PINCH){if($element.trigger("pinchStatus",[phase,pinchDirection||null,pinchDistance||0,duration||0,fingerCount,pinchZoom,fingerData]),options.pinchStatus&&(ret=options.pinchStatus.call($element,event,phase,pinchDirection||null,pinchDistance||0,duration||0,fingerCount,pinchZoom,fingerData),ret===!1))return!1;if(phase==PHASE_END&&validatePinch())switch(pinchDirection){case IN:$element.trigger("pinchIn",[pinchDirection||null,pinchDistance||0,duration||0,fingerCount,pinchZoom,fingerData]),options.pinchIn&&(ret=options.pinchIn.call($element,event,pinchDirection||null,pinchDistance||0,duration||0,fingerCount,pinchZoom,fingerData));break;case OUT:$element.trigger("pinchOut",[pinchDirection||null,pinchDistance||0,duration||0,fingerCount,pinchZoom,fingerData]),options.pinchOut&&(ret=options.pinchOut.call($element,event,pinchDirection||null,pinchDistance||0,duration||0,fingerCount,pinchZoom,fingerData))}}return gesture==TAP?phase!==PHASE_CANCEL&&phase!==PHASE_END||(clearTimeout(singleTapTimeout),clearTimeout(holdTimeout),hasDoubleTap()&&!inDoubleTap()?(doubleTapStartTime=getTimeStamp(),singleTapTimeout=setTimeout($.proxy(function(){doubleTapStartTime=null,$element.trigger("tap",[event.target]),options.tap&&(ret=options.tap.call($element,event,event.target))},this),options.doubleTapThreshold)):(doubleTapStartTime=null,$element.trigger("tap",[event.target]),options.tap&&(ret=options.tap.call($element,event,event.target)))):gesture==DOUBLE_TAP?phase!==PHASE_CANCEL&&phase!==PHASE_END||(clearTimeout(singleTapTimeout),clearTimeout(holdTimeout),doubleTapStartTime=null,$element.trigger("doubletap",[event.target]),options.doubleTap&&(ret=options.doubleTap.call($element,event,event.target))):gesture==LONG_TAP&&(phase!==PHASE_CANCEL&&phase!==PHASE_END||(clearTimeout(singleTapTimeout),doubleTapStartTime=null,$element.trigger("longtap",[event.target]),options.longTap&&(ret=options.longTap.call($element,event,event.target)))),ret}function validateSwipeDistance(){var valid=!0;return null!==options.threshold&&(valid=distance>=options.threshold),valid}function didSwipeBackToCancel(){var cancelled=!1;return null!==options.cancelThreshold&&null!==direction&&(cancelled=getMaxDistance(direction)-distance>=options.cancelThreshold),cancelled}function validatePinchDistance(){return null!==options.pinchThreshold?pinchDistance>=options.pinchThreshold:!0}function validateSwipeTime(){var result;return result=options.maxTimeThreshold?!(duration>=options.maxTimeThreshold):!0}function validateDefaultEvent(jqEvent,direction){if(options.preventDefaultEvents!==!1)if(options.allowPageScroll===NONE)jqEvent.preventDefault();else{var auto=options.allowPageScroll===AUTO;switch(direction){case LEFT:(options.swipeLeft&&auto||!auto&&options.allowPageScroll!=HORIZONTAL)&&jqEvent.preventDefault();break;case RIGHT:(options.swipeRight&&auto||!auto&&options.allowPageScroll!=HORIZONTAL)&&jqEvent.preventDefault();break;case UP:(options.swipeUp&&auto||!auto&&options.allowPageScroll!=VERTICAL)&&jqEvent.preventDefault();break;case DOWN:(options.swipeDown&&auto||!auto&&options.allowPageScroll!=VERTICAL)&&jqEvent.preventDefault();break;case NONE:}}}function validatePinch(){var hasCorrectFingerCount=validateFingers(),hasEndPoint=validateEndPoint(),hasCorrectDistance=validatePinchDistance();return hasCorrectFingerCount&&hasEndPoint&&hasCorrectDistance}function hasPinches(){return!!(options.pinchStatus||options.pinchIn||options.pinchOut)}function didPinch(){return!(!validatePinch()||!hasPinches())}function validateSwipe(){var hasValidTime=validateSwipeTime(),hasValidDistance=validateSwipeDistance(),hasCorrectFingerCount=validateFingers(),hasEndPoint=validateEndPoint(),didCancel=didSwipeBackToCancel(),valid=!didCancel&&hasEndPoint&&hasCorrectFingerCount&&hasValidDistance&&hasValidTime;return valid}function hasSwipes(){return!!(options.swipe||options.swipeStatus||options.swipeLeft||options.swipeRight||options.swipeUp||options.swipeDown)}function didSwipe(){return!(!validateSwipe()||!hasSwipes())}function validateFingers(){return fingerCount===options.fingers||options.fingers===ALL_FINGERS||!SUPPORTS_TOUCH}function validateEndPoint(){return 0!==fingerData[0].end.x}function hasTap(){return!!options.tap}function hasDoubleTap(){return!!options.doubleTap}function hasLongTap(){return!!options.longTap}function validateDoubleTap(){if(null==doubleTapStartTime)return!1;var now=getTimeStamp();return hasDoubleTap()&&now-doubleTapStartTime<=options.doubleTapThreshold}function inDoubleTap(){return validateDoubleTap()}function validateTap(){return(1===fingerCount||!SUPPORTS_TOUCH)&&(isNaN(distance)||distance<options.threshold)}function validateLongTap(){return duration>options.longTapThreshold&&DOUBLE_TAP_THRESHOLD>distance}function didTap(){return!(!validateTap()||!hasTap())}function didDoubleTap(){return!(!validateDoubleTap()||!hasDoubleTap())}function didLongTap(){return!(!validateLongTap()||!hasLongTap())}function startMultiFingerRelease(event){previousTouchEndTime=getTimeStamp(),fingerCountAtRelease=event.touches.length+1}function cancelMultiFingerRelease(){previousTouchEndTime=0,fingerCountAtRelease=0}function inMultiFingerRelease(){var withinThreshold=!1;if(previousTouchEndTime){var diff=getTimeStamp()-previousTouchEndTime;diff<=options.fingerReleaseThreshold&&(withinThreshold=!0)}return withinThreshold}function getTouchInProgress(){return!($element.data(PLUGIN_NS+"_intouch")!==!0)}function setTouchInProgress(val){$element&&(val===!0?($element.bind(MOVE_EV,touchMove),$element.bind(END_EV,touchEnd),LEAVE_EV&&$element.bind(LEAVE_EV,touchLeave)):($element.unbind(MOVE_EV,touchMove,!1),$element.unbind(END_EV,touchEnd,!1),LEAVE_EV&&$element.unbind(LEAVE_EV,touchLeave,!1)),$element.data(PLUGIN_NS+"_intouch",val===!0))}function createFingerData(id,evt){var f={start:{x:0,y:0},last:{x:0,y:0},end:{x:0,y:0}};return f.start.x=f.last.x=f.end.x=evt.pageX||evt.clientX,f.start.y=f.last.y=f.end.y=evt.pageY||evt.clientY,fingerData[id]=f,f}function updateFingerData(evt){var id=void 0!==evt.identifier?evt.identifier:0,f=getFingerData(id);return null===f&&(f=createFingerData(id,evt)),f.last.x=f.end.x,f.last.y=f.end.y,f.end.x=evt.pageX||evt.clientX,f.end.y=evt.pageY||evt.clientY,f}function getFingerData(id){return fingerData[id]||null}function setMaxDistance(direction,distance){direction!=NONE&&(distance=Math.max(distance,getMaxDistance(direction)),maximumsMap[direction].distance=distance)}function getMaxDistance(direction){return maximumsMap[direction]?maximumsMap[direction].distance:void 0}function createMaximumsData(){var maxData={};return maxData[LEFT]=createMaximumVO(LEFT),maxData[RIGHT]=createMaximumVO(RIGHT),maxData[UP]=createMaximumVO(UP),maxData[DOWN]=createMaximumVO(DOWN),maxData}function createMaximumVO(dir){return{direction:dir,distance:0}}function calculateDuration(){return endTime-startTime}function calculateTouchesDistance(startPoint,endPoint){var diffX=Math.abs(startPoint.x-endPoint.x),diffY=Math.abs(startPoint.y-endPoint.y);return Math.round(Math.sqrt(diffX*diffX+diffY*diffY))}function calculatePinchZoom(startDistance,endDistance){var percent=endDistance/startDistance*1;return percent.toFixed(2)}function calculatePinchDirection(){return 1>pinchZoom?OUT:IN}function calculateDistance(startPoint,endPoint){return Math.round(Math.sqrt(Math.pow(endPoint.x-startPoint.x,2)+Math.pow(endPoint.y-startPoint.y,2)))}function calculateAngle(startPoint,endPoint){var x=startPoint.x-endPoint.x,y=endPoint.y-startPoint.y,r=Math.atan2(y,x),angle=Math.round(180*r/Math.PI);return 0>angle&&(angle=360-Math.abs(angle)),angle}function calculateDirection(startPoint,endPoint){if(comparePoints(startPoint,endPoint))return NONE;var angle=calculateAngle(startPoint,endPoint);return 45>=angle&&angle>=0?LEFT:360>=angle&&angle>=315?LEFT:angle>=135&&225>=angle?RIGHT:angle>45&&135>angle?DOWN:UP}function getTimeStamp(){var now=new Date;return now.getTime()}function getbounds(el){el=$(el);var offset=el.offset(),bounds={left:offset.left,right:offset.left+el.outerWidth(),top:offset.top,bottom:offset.top+el.outerHeight()};return bounds}function isInBounds(point,bounds){return point.x>bounds.left&&point.x<bounds.right&&point.y>bounds.top&&point.y<bounds.bottom}function comparePoints(pointA,pointB){return pointA.x==pointB.x&&pointA.y==pointB.y}var options=$.extend({},options),useTouchEvents=SUPPORTS_TOUCH||SUPPORTS_POINTER||!options.fallbackToMouseEvents,START_EV=useTouchEvents?SUPPORTS_POINTER?SUPPORTS_POINTER_IE10?"MSPointerDown":"pointerdown":"touchstart":"mousedown",MOVE_EV=useTouchEvents?SUPPORTS_POINTER?SUPPORTS_POINTER_IE10?"MSPointerMove":"pointermove":"touchmove":"mousemove",END_EV=useTouchEvents?SUPPORTS_POINTER?SUPPORTS_POINTER_IE10?"MSPointerUp":"pointerup":"touchend":"mouseup",LEAVE_EV=useTouchEvents?SUPPORTS_POINTER?"mouseleave":null:"mouseleave",CANCEL_EV=SUPPORTS_POINTER?SUPPORTS_POINTER_IE10?"MSPointerCancel":"pointercancel":"touchcancel",distance=0,direction=null,currentDirection=null,duration=0,startTouchesDistance=0,endTouchesDistance=0,pinchZoom=1,pinchDistance=0,pinchDirection=0,maximumsMap=null,$element=$(element),phase="start",fingerCount=0,fingerData={},startTime=0,endTime=0,previousTouchEndTime=0,fingerCountAtRelease=0,doubleTapStartTime=0,singleTapTimeout=null,holdTimeout=null;try{$element.bind(START_EV,touchStart),$element.bind(CANCEL_EV,touchCancel)}catch(e){$.error("events not supported "+START_EV+","+CANCEL_EV+" on jQuery.swipe")}this.enable=function(){return this.disable(),$element.bind(START_EV,touchStart),$element.bind(CANCEL_EV,touchCancel),$element},this.disable=function(){return removeListeners(),$element},this.destroy=function(){removeListeners(),$element.data(PLUGIN_NS,null),$element=null},this.option=function(property,value){if("object"==typeof property)options=$.extend(options,property);else if(void 0!==options[property]){if(void 0===value)return options[property];options[property]=value}else{if(!property)return options;$.error("Option "+property+" does not exist on jQuery.swipe.options")}return null}}var VERSION="1.6.18",LEFT="left",RIGHT="right",UP="up",DOWN="down",IN="in",OUT="out",NONE="none",AUTO="auto",SWIPE="swipe",PINCH="pinch",TAP="tap",DOUBLE_TAP="doubletap",LONG_TAP="longtap",HORIZONTAL="horizontal",VERTICAL="vertical",ALL_FINGERS="all",DOUBLE_TAP_THRESHOLD=10,PHASE_START="start",PHASE_MOVE="move",PHASE_END="end",PHASE_CANCEL="cancel",SUPPORTS_TOUCH="ontouchstart"in window,SUPPORTS_POINTER_IE10=window.navigator.msPointerEnabled&&!window.navigator.pointerEnabled&&!SUPPORTS_TOUCH,SUPPORTS_POINTER=(window.navigator.pointerEnabled||window.navigator.msPointerEnabled)&&!SUPPORTS_TOUCH,PLUGIN_NS="TouchSwipe",defaults={fingers:1,threshold:75,cancelThreshold:null,pinchThreshold:20,maxTimeThreshold:null,fingerReleaseThreshold:250,longTapThreshold:500,doubleTapThreshold:200,swipe:null,swipeLeft:null,swipeRight:null,swipeUp:null,swipeDown:null,swipeStatus:null,pinchIn:null,pinchOut:null,pinchStatus:null,click:null,tap:null,doubleTap:null,longTap:null,hold:null,triggerOnTouchEnd:!0,triggerOnTouchLeave:!1,allowPageScroll:"auto",fallbackToMouseEvents:!0,excludedElements:".noSwipe",preventDefaultEvents:!0};$.fn.swipe=function(method){var $this=$(this),plugin=$this.data(PLUGIN_NS);if(plugin&&"string"==typeof method){if(plugin[method])return plugin[method].apply(plugin,Array.prototype.slice.call(arguments,1));$.error("Method "+method+" does not exist on jQuery.swipe")}else if(plugin&&"object"==typeof method)plugin.option.apply(plugin,arguments);else if(!(plugin||"object"!=typeof method&&method))return init.apply(this,arguments);return $this},$.fn.swipe.version=VERSION,$.fn.swipe.defaults=defaults,$.fn.swipe.phases={PHASE_START:PHASE_START,PHASE_MOVE:PHASE_MOVE,PHASE_END:PHASE_END,PHASE_CANCEL:PHASE_CANCEL},$.fn.swipe.directions={LEFT:LEFT,RIGHT:RIGHT,UP:UP,DOWN:DOWN,IN:IN,OUT:OUT},$.fn.swipe.pageScroll={NONE:NONE,HORIZONTAL:HORIZONTAL,VERTICAL:VERTICAL,AUTO:AUTO},$.fn.swipe.fingers={ONE:1,TWO:2,THREE:3,FOUR:4,FIVE:5,ALL:ALL_FINGERS}});
   },{"jquery":"jquery"}],
   "leaflet":[function(require,module,exports){
   /*
    Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com
    (c) 2010-2013, Vladimir Agafonkin
    (c) 2010-2011, CloudMade
   */
   !function(t,e,i){var n=t.L,o={};o.version="0.7.7","object"==typeof module&&"object"==typeof module.exports?module.exports=o:"function"==typeof define&&define.amd&&define(o),o.noConflict=function(){return t.L=n,this},t.L=o,o.Util={extend:function(t){var e,i,n,o,s=Array.prototype.slice.call(arguments,1);for(i=0,n=s.length;n>i;i++){o=s[i]||{};for(e in o)o.hasOwnProperty(e)&&(t[e]=o[e])}return t},bind:function(t,e){var i=arguments.length>2?Array.prototype.slice.call(arguments,2):null;return function(){return t.apply(e,i||arguments)}},stamp:function(){var t=0,e="_leaflet_id";return function(i){return i[e]=i[e]||++t,i[e]}}(),invokeEach:function(t,e,i){var n,o;if("object"==typeof t){o=Array.prototype.slice.call(arguments,3);for(n in t)e.apply(i,[n,t[n]].concat(o));return!0}return!1},limitExecByInterval:function(t,e,i){var n,o;return function s(){var a=arguments;return n?void(o=!0):(n=!0,setTimeout(function(){n=!1,o&&(s.apply(i,a),o=!1)},e),void t.apply(i,a))}},falseFn:function(){return!1},formatNum:function(t,e){var i=Math.pow(10,e||5);return Math.round(t*i)/i},trim:function(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")},splitWords:function(t){return o.Util.trim(t).split(/\s+/)},setOptions:function(t,e){return t.options=o.extend({},t.options,e),t.options},getParamString:function(t,e,i){var n=[];for(var o in t)n.push(encodeURIComponent(i?o.toUpperCase():o)+"="+encodeURIComponent(t[o]));return(e&&-1!==e.indexOf("?")?"&":"?")+n.join("&")},template:function(t,e){return t.replace(/\{ *([\w_]+) *\}/g,function(t,n){var o=e[n];if(o===i)throw new Error("No value provided for variable "+t);return"function"==typeof o&&(o=o(e)),o})},isArray:Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)},emptyImageUrl:"data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="},function(){function e(e){var i,n,o=["webkit","moz","o","ms"];for(i=0;i<o.length&&!n;i++)n=t[o[i]+e];return n}function i(e){var i=+new Date,o=Math.max(0,16-(i-n));return n=i+o,t.setTimeout(e,o)}var n=0,s=t.requestAnimationFrame||e("RequestAnimationFrame")||i,a=t.cancelAnimationFrame||e("CancelAnimationFrame")||e("CancelRequestAnimationFrame")||function(e){t.clearTimeout(e)};o.Util.requestAnimFrame=function(e,n,a,r){return e=o.bind(e,n),a&&s===i?void e():s.call(t,e,r)},o.Util.cancelAnimFrame=function(e){e&&a.call(t,e)}}(),o.extend=o.Util.extend,o.bind=o.Util.bind,o.stamp=o.Util.stamp,o.setOptions=o.Util.setOptions,o.Class=function(){},o.Class.extend=function(t){var e=function(){this.initialize&&this.initialize.apply(this,arguments),this._initHooks&&this.callInitHooks()},i=function(){};i.prototype=this.prototype;var n=new i;n.constructor=e,e.prototype=n;for(var s in this)this.hasOwnProperty(s)&&"prototype"!==s&&(e[s]=this[s]);t.statics&&(o.extend(e,t.statics),delete t.statics),t.includes&&(o.Util.extend.apply(null,[n].concat(t.includes)),delete t.includes),t.options&&n.options&&(t.options=o.extend({},n.options,t.options)),o.extend(n,t),n._initHooks=[];var a=this;return e.__super__=a.prototype,n.callInitHooks=function(){if(!this._initHooksCalled){a.prototype.callInitHooks&&a.prototype.callInitHooks.call(this),this._initHooksCalled=!0;for(var t=0,e=n._initHooks.length;e>t;t++)n._initHooks[t].call(this)}},e},o.Class.include=function(t){o.extend(this.prototype,t)},o.Class.mergeOptions=function(t){o.extend(this.prototype.options,t)},o.Class.addInitHook=function(t){var e=Array.prototype.slice.call(arguments,1),i="function"==typeof t?t:function(){this[t].apply(this,e)};this.prototype._initHooks=this.prototype._initHooks||[],this.prototype._initHooks.push(i)};var s="_leaflet_events";o.Mixin={},o.Mixin.Events={addEventListener:function(t,e,i){if(o.Util.invokeEach(t,this.addEventListener,this,e,i))return this;var n,a,r,h,l,u,c,d=this[s]=this[s]||{},p=i&&i!==this&&o.stamp(i);for(t=o.Util.splitWords(t),n=0,a=t.length;a>n;n++)r={action:e,context:i||this},h=t[n],p?(l=h+"_idx",u=l+"_len",c=d[l]=d[l]||{},c[p]||(c[p]=[],d[u]=(d[u]||0)+1),c[p].push(r)):(d[h]=d[h]||[],d[h].push(r));return this},hasEventListeners:function(t){var e=this[s];return!!e&&(t in e&&e[t].length>0||t+"_idx"in e&&e[t+"_idx_len"]>0)},removeEventListener:function(t,e,i){if(!this[s])return this;if(!t)return this.clearAllEventListeners();if(o.Util.invokeEach(t,this.removeEventListener,this,e,i))return this;var n,a,r,h,l,u,c,d,p,_=this[s],m=i&&i!==this&&o.stamp(i);for(t=o.Util.splitWords(t),n=0,a=t.length;a>n;n++)if(r=t[n],u=r+"_idx",c=u+"_len",d=_[u],e){if(h=m&&d?d[m]:_[r]){for(l=h.length-1;l>=0;l--)h[l].action!==e||i&&h[l].context!==i||(p=h.splice(l,1),p[0].action=o.Util.falseFn);i&&d&&0===h.length&&(delete d[m],_[c]--)}}else delete _[r],delete _[u],delete _[c];return this},clearAllEventListeners:function(){return delete this[s],this},fireEvent:function(t,e){if(!this.hasEventListeners(t))return this;var i,n,a,r,h,l=o.Util.extend({},e,{type:t,target:this}),u=this[s];if(u[t])for(i=u[t].slice(),n=0,a=i.length;a>n;n++)i[n].action.call(i[n].context,l);r=u[t+"_idx"];for(h in r)if(i=r[h].slice())for(n=0,a=i.length;a>n;n++)i[n].action.call(i[n].context,l);return this},addOneTimeEventListener:function(t,e,i){if(o.Util.invokeEach(t,this.addOneTimeEventListener,this,e,i))return this;var n=o.bind(function(){this.removeEventListener(t,e,i).removeEventListener(t,n,i)},this);return this.addEventListener(t,e,i).addEventListener(t,n,i)}},o.Mixin.Events.on=o.Mixin.Events.addEventListener,o.Mixin.Events.off=o.Mixin.Events.removeEventListener,o.Mixin.Events.once=o.Mixin.Events.addOneTimeEventListener,o.Mixin.Events.fire=o.Mixin.Events.fireEvent,function(){var n="ActiveXObject"in t,s=n&&!e.addEventListener,a=navigator.userAgent.toLowerCase(),r=-1!==a.indexOf("webkit"),h=-1!==a.indexOf("chrome"),l=-1!==a.indexOf("phantom"),u=-1!==a.indexOf("android"),c=-1!==a.search("android [23]"),d=-1!==a.indexOf("gecko"),p=typeof orientation!=i+"",_=!t.PointerEvent&&t.MSPointerEvent,m=t.PointerEvent&&t.navigator.pointerEnabled||_,f="devicePixelRatio"in t&&t.devicePixelRatio>1||"matchMedia"in t&&t.matchMedia("(min-resolution:144dpi)")&&t.matchMedia("(min-resolution:144dpi)").matches,g=e.documentElement,v=n&&"transition"in g.style,y="WebKitCSSMatrix"in t&&"m11"in new t.WebKitCSSMatrix&&!c,P="MozPerspective"in g.style,L="OTransition"in g.style,x=!t.L_DISABLE_3D&&(v||y||P||L)&&!l,w=!t.L_NO_TOUCH&&!l&&(m||"ontouchstart"in t||t.DocumentTouch&&e instanceof t.DocumentTouch);o.Browser={ie:n,ielt9:s,webkit:r,gecko:d&&!r&&!t.opera&&!n,android:u,android23:c,chrome:h,ie3d:v,webkit3d:y,gecko3d:P,opera3d:L,any3d:x,mobile:p,mobileWebkit:p&&r,mobileWebkit3d:p&&y,mobileOpera:p&&t.opera,touch:w,msPointer:_,pointer:m,retina:f}}(),o.Point=function(t,e,i){this.x=i?Math.round(t):t,this.y=i?Math.round(e):e},o.Point.prototype={clone:function(){return new o.Point(this.x,this.y)},add:function(t){return this.clone()._add(o.point(t))},_add:function(t){return this.x+=t.x,this.y+=t.y,this},subtract:function(t){return this.clone()._subtract(o.point(t))},_subtract:function(t){return this.x-=t.x,this.y-=t.y,this},divideBy:function(t){return this.clone()._divideBy(t)},_divideBy:function(t){return this.x/=t,this.y/=t,this},multiplyBy:function(t){return this.clone()._multiplyBy(t)},_multiplyBy:function(t){return this.x*=t,this.y*=t,this},round:function(){return this.clone()._round()},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},floor:function(){return this.clone()._floor()},_floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},distanceTo:function(t){t=o.point(t);var e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)},equals:function(t){return t=o.point(t),t.x===this.x&&t.y===this.y},contains:function(t){return t=o.point(t),Math.abs(t.x)<=Math.abs(this.x)&&Math.abs(t.y)<=Math.abs(this.y)},toString:function(){return"Point("+o.Util.formatNum(this.x)+", "+o.Util.formatNum(this.y)+")"}},o.point=function(t,e,n){return t instanceof o.Point?t:o.Util.isArray(t)?new o.Point(t[0],t[1]):t===i||null===t?t:new o.Point(t,e,n)},o.Bounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;o>n;n++)this.extend(i[n])},o.Bounds.prototype={extend:function(t){return t=o.point(t),this.min||this.max?(this.min.x=Math.min(t.x,this.min.x),this.max.x=Math.max(t.x,this.max.x),this.min.y=Math.min(t.y,this.min.y),this.max.y=Math.max(t.y,this.max.y)):(this.min=t.clone(),this.max=t.clone()),this},getCenter:function(t){return new o.Point((this.min.x+this.max.x)/2,(this.min.y+this.max.y)/2,t)},getBottomLeft:function(){return new o.Point(this.min.x,this.max.y)},getTopRight:function(){return new o.Point(this.max.x,this.min.y)},getSize:function(){return this.max.subtract(this.min)},contains:function(t){var e,i;return t="number"==typeof t[0]||t instanceof o.Point?o.point(t):o.bounds(t),t instanceof o.Bounds?(e=t.min,i=t.max):e=i=t,e.x>=this.min.x&&i.x<=this.max.x&&e.y>=this.min.y&&i.y<=this.max.y},intersects:function(t){t=o.bounds(t);var e=this.min,i=this.max,n=t.min,s=t.max,a=s.x>=e.x&&n.x<=i.x,r=s.y>=e.y&&n.y<=i.y;return a&&r},isValid:function(){return!(!this.min||!this.max)}},o.bounds=function(t,e){return!t||t instanceof o.Bounds?t:new o.Bounds(t,e)},o.Transformation=function(t,e,i,n){this._a=t,this._b=e,this._c=i,this._d=n},o.Transformation.prototype={transform:function(t,e){return this._transform(t.clone(),e)},_transform:function(t,e){return e=e||1,t.x=e*(this._a*t.x+this._b),t.y=e*(this._c*t.y+this._d),t},untransform:function(t,e){return e=e||1,new o.Point((t.x/e-this._b)/this._a,(t.y/e-this._d)/this._c)}},o.DomUtil={get:function(t){return"string"==typeof t?e.getElementById(t):t},getStyle:function(t,i){var n=t.style[i];if(!n&&t.currentStyle&&(n=t.currentStyle[i]),(!n||"auto"===n)&&e.defaultView){var o=e.defaultView.getComputedStyle(t,null);n=o?o[i]:null}return"auto"===n?null:n},getViewportOffset:function(t){var i,n=0,s=0,a=t,r=e.body,h=e.documentElement;do{if(n+=a.offsetTop||0,s+=a.offsetLeft||0,n+=parseInt(o.DomUtil.getStyle(a,"borderTopWidth"),10)||0,s+=parseInt(o.DomUtil.getStyle(a,"borderLeftWidth"),10)||0,i=o.DomUtil.getStyle(a,"position"),a.offsetParent===r&&"absolute"===i)break;if("fixed"===i){n+=r.scrollTop||h.scrollTop||0,s+=r.scrollLeft||h.scrollLeft||0;break}if("relative"===i&&!a.offsetLeft){var l=o.DomUtil.getStyle(a,"width"),u=o.DomUtil.getStyle(a,"max-width"),c=a.getBoundingClientRect();("none"!==l||"none"!==u)&&(s+=c.left+a.clientLeft),n+=c.top+(r.scrollTop||h.scrollTop||0);break}a=a.offsetParent}while(a);a=t;do{if(a===r)break;n-=a.scrollTop||0,s-=a.scrollLeft||0,a=a.parentNode}while(a);return new o.Point(s,n)},documentIsLtr:function(){return o.DomUtil._docIsLtrCached||(o.DomUtil._docIsLtrCached=!0,o.DomUtil._docIsLtr="ltr"===o.DomUtil.getStyle(e.body,"direction")),o.DomUtil._docIsLtr},create:function(t,i,n){var o=e.createElement(t);return o.className=i,n&&n.appendChild(o),o},hasClass:function(t,e){if(t.classList!==i)return t.classList.contains(e);var n=o.DomUtil._getClass(t);return n.length>0&&new RegExp("(^|\\s)"+e+"(\\s|$)").test(n)},addClass:function(t,e){if(t.classList!==i)for(var n=o.Util.splitWords(e),s=0,a=n.length;a>s;s++)t.classList.add(n[s]);else if(!o.DomUtil.hasClass(t,e)){var r=o.DomUtil._getClass(t);o.DomUtil._setClass(t,(r?r+" ":"")+e)}},removeClass:function(t,e){t.classList!==i?t.classList.remove(e):o.DomUtil._setClass(t,o.Util.trim((" "+o.DomUtil._getClass(t)+" ").replace(" "+e+" "," ")))},_setClass:function(t,e){t.className.baseVal===i?t.className=e:t.className.baseVal=e},_getClass:function(t){return t.className.baseVal===i?t.className:t.className.baseVal},setOpacity:function(t,e){if("opacity"in t.style)t.style.opacity=e;else if("filter"in t.style){var i=!1,n="DXImageTransform.Microsoft.Alpha";try{i=t.filters.item(n)}catch(o){if(1===e)return}e=Math.round(100*e),i?(i.Enabled=100!==e,i.Opacity=e):t.style.filter+=" progid:"+n+"(opacity="+e+")"}},testProp:function(t){for(var i=e.documentElement.style,n=0;n<t.length;n++)if(t[n]in i)return t[n];return!1},getTranslateString:function(t){var e=o.Browser.webkit3d,i="translate"+(e?"3d":"")+"(",n=(e?",0":"")+")";return i+t.x+"px,"+t.y+"px"+n},getScaleString:function(t,e){var i=o.DomUtil.getTranslateString(e.add(e.multiplyBy(-1*t))),n=" scale("+t+") ";return i+n},setPosition:function(t,e,i){t._leaflet_pos=e,!i&&o.Browser.any3d?t.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(e):(t.style.left=e.x+"px",t.style.top=e.y+"px")},getPosition:function(t){return t._leaflet_pos}},o.DomUtil.TRANSFORM=o.DomUtil.testProp(["transform","WebkitTransform","OTransform","MozTransform","msTransform"]),o.DomUtil.TRANSITION=o.DomUtil.testProp(["webkitTransition","transition","OTransition","MozTransition","msTransition"]),o.DomUtil.TRANSITION_END="webkitTransition"===o.DomUtil.TRANSITION||"OTransition"===o.DomUtil.TRANSITION?o.DomUtil.TRANSITION+"End":"transitionend",function(){if("onselectstart"in e)o.extend(o.DomUtil,{disableTextSelection:function(){o.DomEvent.on(t,"selectstart",o.DomEvent.preventDefault)},enableTextSelection:function(){o.DomEvent.off(t,"selectstart",o.DomEvent.preventDefault)}});else{var i=o.DomUtil.testProp(["userSelect","WebkitUserSelect","OUserSelect","MozUserSelect","msUserSelect"]);o.extend(o.DomUtil,{disableTextSelection:function(){if(i){var t=e.documentElement.style;this._userSelect=t[i],t[i]="none"}},enableTextSelection:function(){i&&(e.documentElement.style[i]=this._userSelect,delete this._userSelect)}})}o.extend(o.DomUtil,{disableImageDrag:function(){o.DomEvent.on(t,"dragstart",o.DomEvent.preventDefault)},enableImageDrag:function(){o.DomEvent.off(t,"dragstart",o.DomEvent.preventDefault)}})}(),o.LatLng=function(t,e,n){if(t=parseFloat(t),e=parseFloat(e),isNaN(t)||isNaN(e))throw new Error("Invalid LatLng object: ("+t+", "+e+")");this.lat=t,this.lng=e,n!==i&&(this.alt=parseFloat(n))},o.extend(o.LatLng,{DEG_TO_RAD:Math.PI/180,RAD_TO_DEG:180/Math.PI,MAX_MARGIN:1e-9}),o.LatLng.prototype={equals:function(t){if(!t)return!1;t=o.latLng(t);var e=Math.max(Math.abs(this.lat-t.lat),Math.abs(this.lng-t.lng));return e<=o.LatLng.MAX_MARGIN},toString:function(t){return"LatLng("+o.Util.formatNum(this.lat,t)+", "+o.Util.formatNum(this.lng,t)+")"},distanceTo:function(t){t=o.latLng(t);var e=6378137,i=o.LatLng.DEG_TO_RAD,n=(t.lat-this.lat)*i,s=(t.lng-this.lng)*i,a=this.lat*i,r=t.lat*i,h=Math.sin(n/2),l=Math.sin(s/2),u=h*h+l*l*Math.cos(a)*Math.cos(r);return 2*e*Math.atan2(Math.sqrt(u),Math.sqrt(1-u))},wrap:function(t,e){var i=this.lng;return t=t||-180,e=e||180,i=(i+e)%(e-t)+(t>i||i===e?e:t),new o.LatLng(this.lat,i)}},o.latLng=function(t,e){return t instanceof o.LatLng?t:o.Util.isArray(t)?"number"==typeof t[0]||"string"==typeof t[0]?new o.LatLng(t[0],t[1],t[2]):null:t===i||null===t?t:"object"==typeof t&&"lat"in t?new o.LatLng(t.lat,"lng"in t?t.lng:t.lon):e===i?null:new o.LatLng(t,e)},o.LatLngBounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;o>n;n++)this.extend(i[n])},o.LatLngBounds.prototype={extend:function(t){if(!t)return this;var e=o.latLng(t);return t=null!==e?e:o.latLngBounds(t),t instanceof o.LatLng?this._southWest||this._northEast?(this._southWest.lat=Math.min(t.lat,this._southWest.lat),this._southWest.lng=Math.min(t.lng,this._southWest.lng),this._northEast.lat=Math.max(t.lat,this._northEast.lat),this._northEast.lng=Math.max(t.lng,this._northEast.lng)):(this._southWest=new o.LatLng(t.lat,t.lng),this._northEast=new o.LatLng(t.lat,t.lng)):t instanceof o.LatLngBounds&&(this.extend(t._southWest),this.extend(t._northEast)),this},pad:function(t){var e=this._southWest,i=this._northEast,n=Math.abs(e.lat-i.lat)*t,s=Math.abs(e.lng-i.lng)*t;return new o.LatLngBounds(new o.LatLng(e.lat-n,e.lng-s),new o.LatLng(i.lat+n,i.lng+s))},getCenter:function(){return new o.LatLng((this._southWest.lat+this._northEast.lat)/2,(this._southWest.lng+this._northEast.lng)/2)},getSouthWest:function(){return this._southWest},getNorthEast:function(){return this._northEast},getNorthWest:function(){return new o.LatLng(this.getNorth(),this.getWest())},getSouthEast:function(){return new o.LatLng(this.getSouth(),this.getEast())},getWest:function(){return this._southWest.lng},getSouth:function(){return this._southWest.lat},getEast:function(){return this._northEast.lng},getNorth:function(){return this._northEast.lat},contains:function(t){t="number"==typeof t[0]||t instanceof o.LatLng?o.latLng(t):o.latLngBounds(t);var e,i,n=this._southWest,s=this._northEast;return t instanceof o.LatLngBounds?(e=t.getSouthWest(),i=t.getNorthEast()):e=i=t,e.lat>=n.lat&&i.lat<=s.lat&&e.lng>=n.lng&&i.lng<=s.lng},intersects:function(t){t=o.latLngBounds(t);var e=this._southWest,i=this._northEast,n=t.getSouthWest(),s=t.getNorthEast(),a=s.lat>=e.lat&&n.lat<=i.lat,r=s.lng>=e.lng&&n.lng<=i.lng;return a&&r},toBBoxString:function(){return[this.getWest(),this.getSouth(),this.getEast(),this.getNorth()].join(",")},equals:function(t){return t?(t=o.latLngBounds(t),this._southWest.equals(t.getSouthWest())&&this._northEast.equals(t.getNorthEast())):!1},isValid:function(){return!(!this._southWest||!this._northEast)}},o.latLngBounds=function(t,e){return!t||t instanceof o.LatLngBounds?t:new o.LatLngBounds(t,e)},o.Projection={},o.Projection.SphericalMercator={MAX_LATITUDE:85.0511287798,project:function(t){var e=o.LatLng.DEG_TO_RAD,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=t.lng*e,a=n*e;return a=Math.log(Math.tan(Math.PI/4+a/2)),new o.Point(s,a)},unproject:function(t){var e=o.LatLng.RAD_TO_DEG,i=t.x*e,n=(2*Math.atan(Math.exp(t.y))-Math.PI/2)*e;return new o.LatLng(n,i)}},o.Projection.LonLat={project:function(t){return new o.Point(t.lng,t.lat)},unproject:function(t){return new o.LatLng(t.y,t.x)}},o.CRS={latLngToPoint:function(t,e){var i=this.projection.project(t),n=this.scale(e);return this.transformation._transform(i,n)},pointToLatLng:function(t,e){var i=this.scale(e),n=this.transformation.untransform(t,i);return this.projection.unproject(n)},project:function(t){return this.projection.project(t)},scale:function(t){return 256*Math.pow(2,t)},getSize:function(t){var e=this.scale(t);return o.point(e,e)}},o.CRS.Simple=o.extend({},o.CRS,{projection:o.Projection.LonLat,transformation:new o.Transformation(1,0,-1,0),scale:function(t){return Math.pow(2,t)}}),o.CRS.EPSG3857=o.extend({},o.CRS,{code:"EPSG:3857",projection:o.Projection.SphericalMercator,transformation:new o.Transformation(.5/Math.PI,.5,-.5/Math.PI,.5),project:function(t){var e=this.projection.project(t),i=6378137;return e.multiplyBy(i)}}),o.CRS.EPSG900913=o.extend({},o.CRS.EPSG3857,{code:"EPSG:900913"}),o.CRS.EPSG4326=o.extend({},o.CRS,{code:"EPSG:4326",projection:o.Projection.LonLat,transformation:new o.Transformation(1/360,.5,-1/360,.5)}),o.Map=o.Class.extend({includes:o.Mixin.Events,options:{crs:o.CRS.EPSG3857,fadeAnimation:o.DomUtil.TRANSITION&&!o.Browser.android23,trackResize:!0,markerZoomAnimation:o.DomUtil.TRANSITION&&o.Browser.any3d},initialize:function(t,e){e=o.setOptions(this,e),this._initContainer(t),this._initLayout(),this._onResize=o.bind(this._onResize,this),this._initEvents(),e.maxBounds&&this.setMaxBounds(e.maxBounds),e.center&&e.zoom!==i&&this.setView(o.latLng(e.center),e.zoom,{reset:!0}),this._handlers=[],this._layers={},this._zoomBoundLayers={},this._tileLayersNum=0,this.callInitHooks(),this._addLayers(e.layers)},setView:function(t,e){return e=e===i?this.getZoom():e,this._resetView(o.latLng(t),this._limitZoom(e)),this},setZoom:function(t,e){return this._loaded?this.setView(this.getCenter(),t,{zoom:e}):(this._zoom=this._limitZoom(t),this)},zoomIn:function(t,e){return this.setZoom(this._zoom+(t||1),e)},zoomOut:function(t,e){return this.setZoom(this._zoom-(t||1),e)},setZoomAround:function(t,e,i){var n=this.getZoomScale(e),s=this.getSize().divideBy(2),a=t instanceof o.Point?t:this.latLngToContainerPoint(t),r=a.subtract(s).multiplyBy(1-1/n),h=this.containerPointToLatLng(s.add(r));return this.setView(h,e,{zoom:i})},fitBounds:function(t,e){e=e||{},t=t.getBounds?t.getBounds():o.latLngBounds(t);var i=o.point(e.paddingTopLeft||e.padding||[0,0]),n=o.point(e.paddingBottomRight||e.padding||[0,0]),s=this.getBoundsZoom(t,!1,i.add(n));s=e.maxZoom?Math.min(e.maxZoom,s):s;var a=n.subtract(i).divideBy(2),r=this.project(t.getSouthWest(),s),h=this.project(t.getNorthEast(),s),l=this.unproject(r.add(h).divideBy(2).add(a),s);return this.setView(l,s,e)},fitWorld:function(t){return this.fitBounds([[-90,-180],[90,180]],t)},panTo:function(t,e){return this.setView(t,this._zoom,{pan:e})},panBy:function(t){return this.fire("movestart"),this._rawPanBy(o.point(t)),this.fire("move"),this.fire("moveend")},setMaxBounds:function(t){return t=o.latLngBounds(t),this.options.maxBounds=t,t?(this._loaded&&this._panInsideMaxBounds(),this.on("moveend",this._panInsideMaxBounds,this)):this.off("moveend",this._panInsideMaxBounds,this)},panInsideBounds:function(t,e){var i=this.getCenter(),n=this._limitCenter(i,this._zoom,t);return i.equals(n)?this:this.panTo(n,e)},addLayer:function(t){var e=o.stamp(t);return this._layers[e]?this:(this._layers[e]=t,!t.options||isNaN(t.options.maxZoom)&&isNaN(t.options.minZoom)||(this._zoomBoundLayers[e]=t,this._updateZoomLevels()),this.options.zoomAnimation&&o.TileLayer&&t instanceof o.TileLayer&&(this._tileLayersNum++,this._tileLayersToLoad++,t.on("load",this._onTileLayerLoad,this)),this._loaded&&this._layerAdd(t),this)},removeLayer:function(t){var e=o.stamp(t);return this._layers[e]?(this._loaded&&t.onRemove(this),delete this._layers[e],this._loaded&&this.fire("layerremove",{layer:t}),this._zoomBoundLayers[e]&&(delete this._zoomBoundLayers[e],this._updateZoomLevels()),this.options.zoomAnimation&&o.TileLayer&&t instanceof o.TileLayer&&(this._tileLayersNum--,this._tileLayersToLoad--,t.off("load",this._onTileLayerLoad,this)),this):this},hasLayer:function(t){return t?o.stamp(t)in this._layers:!1},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},invalidateSize:function(t){if(!this._loaded)return this;t=o.extend({animate:!1,pan:!0},t===!0?{animate:!0}:t);var e=this.getSize();this._sizeChanged=!0,this._initialCenter=null;var i=this.getSize(),n=e.divideBy(2).round(),s=i.divideBy(2).round(),a=n.subtract(s);return a.x||a.y?(t.animate&&t.pan?this.panBy(a):(t.pan&&this._rawPanBy(a),this.fire("move"),t.debounceMoveend?(clearTimeout(this._sizeTimer),this._sizeTimer=setTimeout(o.bind(this.fire,this,"moveend"),200)):this.fire("moveend")),this.fire("resize",{oldSize:e,newSize:i})):this},addHandler:function(t,e){if(!e)return this;var i=this[t]=new e(this);return this._handlers.push(i),this.options[t]&&i.enable(),this},remove:function(){this._loaded&&this.fire("unload"),this._initEvents("off");try{delete this._container._leaflet}catch(t){this._container._leaflet=i}return this._clearPanes(),this._clearControlPos&&this._clearControlPos(),this._clearHandlers(),this},getCenter:function(){return this._checkIfLoaded(),this._initialCenter&&!this._moved()?this._initialCenter:this.layerPointToLatLng(this._getCenterLayerPoint())},getZoom:function(){return this._zoom},getBounds:function(){var t=this.getPixelBounds(),e=this.unproject(t.getBottomLeft()),i=this.unproject(t.getTopRight());return new o.LatLngBounds(e,i)},getMinZoom:function(){return this.options.minZoom===i?this._layersMinZoom===i?0:this._layersMinZoom:this.options.minZoom},getMaxZoom:function(){return this.options.maxZoom===i?this._layersMaxZoom===i?1/0:this._layersMaxZoom:this.options.maxZoom},getBoundsZoom:function(t,e,i){t=o.latLngBounds(t);var n,s=this.getMinZoom()-(e?1:0),a=this.getMaxZoom(),r=this.getSize(),h=t.getNorthWest(),l=t.getSouthEast(),u=!0;i=o.point(i||[0,0]);do s++,n=this.project(l,s).subtract(this.project(h,s)).add(i),u=e?n.x<r.x||n.y<r.y:r.contains(n);while(u&&a>=s);return u&&e?null:e?s:s-1},getSize:function(){return(!this._size||this._sizeChanged)&&(this._size=new o.Point(this._container.clientWidth,this._container.clientHeight),this._sizeChanged=!1),this._size.clone()},getPixelBounds:function(){var t=this._getTopLeftPoint();return new o.Bounds(t,t.add(this.getSize()))},getPixelOrigin:function(){return this._checkIfLoaded(),this._initialTopLeftPoint},getPanes:function(){return this._panes},getContainer:function(){return this._container},getZoomScale:function(t){var e=this.options.crs;return e.scale(t)/e.scale(this._zoom)},getScaleZoom:function(t){return this._zoom+Math.log(t)/Math.LN2},project:function(t,e){return e=e===i?this._zoom:e,this.options.crs.latLngToPoint(o.latLng(t),e)},unproject:function(t,e){return e=e===i?this._zoom:e,this.options.crs.pointToLatLng(o.point(t),e)},layerPointToLatLng:function(t){var e=o.point(t).add(this.getPixelOrigin());return this.unproject(e)},latLngToLayerPoint:function(t){var e=this.project(o.latLng(t))._round();return e._subtract(this.getPixelOrigin())},containerPointToLayerPoint:function(t){return o.point(t).subtract(this._getMapPanePos())},layerPointToContainerPoint:function(t){return o.point(t).add(this._getMapPanePos())},containerPointToLatLng:function(t){var e=this.containerPointToLayerPoint(o.point(t));return this.layerPointToLatLng(e)},latLngToContainerPoint:function(t){return this.layerPointToContainerPoint(this.latLngToLayerPoint(o.latLng(t)))},mouseEventToContainerPoint:function(t){return o.DomEvent.getMousePosition(t,this._container)},mouseEventToLayerPoint:function(t){return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))},mouseEventToLatLng:function(t){return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))},_initContainer:function(t){var e=this._container=o.DomUtil.get(t);if(!e)throw new Error("Map container not found.");if(e._leaflet)throw new Error("Map container is already initialized.");e._leaflet=!0},_initLayout:function(){var t=this._container;o.DomUtil.addClass(t,"leaflet-container"+(o.Browser.touch?" leaflet-touch":"")+(o.Browser.retina?" leaflet-retina":"")+(o.Browser.ielt9?" leaflet-oldie":"")+(this.options.fadeAnimation?" leaflet-fade-anim":""));var e=o.DomUtil.getStyle(t,"position");"absolute"!==e&&"relative"!==e&&"fixed"!==e&&(t.style.position="relative"),this._initPanes(),this._initControlPos&&this._initControlPos()},_initPanes:function(){var t=this._panes={};this._mapPane=t.mapPane=this._createPane("leaflet-map-pane",this._container),this._tilePane=t.tilePane=this._createPane("leaflet-tile-pane",this._mapPane),t.objectsPane=this._createPane("leaflet-objects-pane",this._mapPane),t.shadowPane=this._createPane("leaflet-shadow-pane"),t.overlayPane=this._createPane("leaflet-overlay-pane"),t.markerPane=this._createPane("leaflet-marker-pane"),t.popupPane=this._createPane("leaflet-popup-pane");var e=" leaflet-zoom-hide";this.options.markerZoomAnimation||(o.DomUtil.addClass(t.markerPane,e),o.DomUtil.addClass(t.shadowPane,e),o.DomUtil.addClass(t.popupPane,e))},_createPane:function(t,e){return o.DomUtil.create("div",t,e||this._panes.objectsPane)},_clearPanes:function(){this._container.removeChild(this._mapPane)},_addLayers:function(t){t=t?o.Util.isArray(t)?t:[t]:[];for(var e=0,i=t.length;i>e;e++)this.addLayer(t[e])},_resetView:function(t,e,i,n){var s=this._zoom!==e;n||(this.fire("movestart"),s&&this.fire("zoomstart")),this._zoom=e,this._initialCenter=t,this._initialTopLeftPoint=this._getNewTopLeftPoint(t),i?this._initialTopLeftPoint._add(this._getMapPanePos()):o.DomUtil.setPosition(this._mapPane,new o.Point(0,0)),this._tileLayersToLoad=this._tileLayersNum;var a=!this._loaded;this._loaded=!0,this.fire("viewreset",{hard:!i}),a&&(this.fire("load"),this.eachLayer(this._layerAdd,this)),this.fire("move"),(s||n)&&this.fire("zoomend"),this.fire("moveend",{hard:!i})},_rawPanBy:function(t){o.DomUtil.setPosition(this._mapPane,this._getMapPanePos().subtract(t))},_getZoomSpan:function(){return this.getMaxZoom()-this.getMinZoom()},_updateZoomLevels:function(){var t,e=1/0,n=-(1/0),o=this._getZoomSpan();for(t in this._zoomBoundLayers){var s=this._zoomBoundLayers[t];isNaN(s.options.minZoom)||(e=Math.min(e,s.options.minZoom)),isNaN(s.options.maxZoom)||(n=Math.max(n,s.options.maxZoom))}t===i?this._layersMaxZoom=this._layersMinZoom=i:(this._layersMaxZoom=n,this._layersMinZoom=e),o!==this._getZoomSpan()&&this.fire("zoomlevelschange")},_panInsideMaxBounds:function(){this.panInsideBounds(this.options.maxBounds)},_checkIfLoaded:function(){if(!this._loaded)throw new Error("Set map center and zoom first.")},_initEvents:function(e){if(o.DomEvent){e=e||"on",o.DomEvent[e](this._container,"click",this._onMouseClick,this);var i,n,s=["dblclick","mousedown","mouseup","mouseenter","mouseleave","mousemove","contextmenu"];for(i=0,n=s.length;n>i;i++)o.DomEvent[e](this._container,s[i],this._fireMouseEvent,this);this.options.trackResize&&o.DomEvent[e](t,"resize",this._onResize,this)}},_onResize:function(){o.Util.cancelAnimFrame(this._resizeRequest),this._resizeRequest=o.Util.requestAnimFrame(function(){this.invalidateSize({debounceMoveend:!0})},this,!1,this._container)},_onMouseClick:function(t){!this._loaded||!t._simulated&&(this.dragging&&this.dragging.moved()||this.boxZoom&&this.boxZoom.moved())||o.DomEvent._skipped(t)||(this.fire("preclick"),this._fireMouseEvent(t))},_fireMouseEvent:function(t){if(this._loaded&&!o.DomEvent._skipped(t)){var e=t.type;if(e="mouseenter"===e?"mouseover":"mouseleave"===e?"mouseout":e,this.hasEventListeners(e)){"contextmenu"===e&&o.DomEvent.preventDefault(t);var i=this.mouseEventToContainerPoint(t),n=this.containerPointToLayerPoint(i),s=this.layerPointToLatLng(n);this.fire(e,{latlng:s,layerPoint:n,containerPoint:i,originalEvent:t})}}},_onTileLayerLoad:function(){this._tileLayersToLoad--,this._tileLayersNum&&!this._tileLayersToLoad&&this.fire("tilelayersload")},_clearHandlers:function(){for(var t=0,e=this._handlers.length;e>t;t++)this._handlers[t].disable()},whenReady:function(t,e){return this._loaded?t.call(e||this,this):this.on("load",t,e),this},_layerAdd:function(t){t.onAdd(this),this.fire("layeradd",{layer:t})},_getMapPanePos:function(){return o.DomUtil.getPosition(this._mapPane)},_moved:function(){var t=this._getMapPanePos();return t&&!t.equals([0,0])},_getTopLeftPoint:function(){return this.getPixelOrigin().subtract(this._getMapPanePos())},_getNewTopLeftPoint:function(t,e){var i=this.getSize()._divideBy(2);return this.project(t,e)._subtract(i)._round()},_latLngToNewLayerPoint:function(t,e,i){var n=this._getNewTopLeftPoint(i,e).add(this._getMapPanePos());return this.project(t,e)._subtract(n)},_getCenterLayerPoint:function(){return this.containerPointToLayerPoint(this.getSize()._divideBy(2))},_getCenterOffset:function(t){return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())},_limitCenter:function(t,e,i){if(!i)return t;var n=this.project(t,e),s=this.getSize().divideBy(2),a=new o.Bounds(n.subtract(s),n.add(s)),r=this._getBoundsOffset(a,i,e);return this.unproject(n.add(r),e)},_limitOffset:function(t,e){if(!e)return t;var i=this.getPixelBounds(),n=new o.Bounds(i.min.add(t),i.max.add(t));return t.add(this._getBoundsOffset(n,e))},_getBoundsOffset:function(t,e,i){var n=this.project(e.getNorthWest(),i).subtract(t.min),s=this.project(e.getSouthEast(),i).subtract(t.max),a=this._rebound(n.x,-s.x),r=this._rebound(n.y,-s.y);return new o.Point(a,r)},_rebound:function(t,e){return t+e>0?Math.round(t-e)/2:Math.max(0,Math.ceil(t))-Math.max(0,Math.floor(e))},_limitZoom:function(t){var e=this.getMinZoom(),i=this.getMaxZoom();return Math.max(e,Math.min(i,t))}}),o.map=function(t,e){return new o.Map(t,e)},o.Projection.Mercator={MAX_LATITUDE:85.0840591556,R_MINOR:6356752.314245179,R_MAJOR:6378137,project:function(t){var e=o.LatLng.DEG_TO_RAD,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=this.R_MAJOR,a=this.R_MINOR,r=t.lng*e*s,h=n*e,l=a/s,u=Math.sqrt(1-l*l),c=u*Math.sin(h);c=Math.pow((1-c)/(1+c),.5*u);var d=Math.tan(.5*(.5*Math.PI-h))/c;return h=-s*Math.log(d),new o.Point(r,h)},unproject:function(t){for(var e,i=o.LatLng.RAD_TO_DEG,n=this.R_MAJOR,s=this.R_MINOR,a=t.x*i/n,r=s/n,h=Math.sqrt(1-r*r),l=Math.exp(-t.y/n),u=Math.PI/2-2*Math.atan(l),c=15,d=1e-7,p=c,_=.1;Math.abs(_)>d&&--p>0;)e=h*Math.sin(u),_=Math.PI/2-2*Math.atan(l*Math.pow((1-e)/(1+e),.5*h))-u,u+=_;return new o.LatLng(u*i,a)}},o.CRS.EPSG3395=o.extend({},o.CRS,{code:"EPSG:3395",projection:o.Projection.Mercator,
   transformation:function(){var t=o.Projection.Mercator,e=t.R_MAJOR,i=.5/(Math.PI*e);return new o.Transformation(i,.5,-i,.5)}()}),o.TileLayer=o.Class.extend({includes:o.Mixin.Events,options:{minZoom:0,maxZoom:18,tileSize:256,subdomains:"abc",errorTileUrl:"",attribution:"",zoomOffset:0,opacity:1,unloadInvisibleTiles:o.Browser.mobile,updateWhenIdle:o.Browser.mobile},initialize:function(t,e){e=o.setOptions(this,e),e.detectRetina&&o.Browser.retina&&e.maxZoom>0&&(e.tileSize=Math.floor(e.tileSize/2),e.zoomOffset++,e.minZoom>0&&e.minZoom--,this.options.maxZoom--),e.bounds&&(e.bounds=o.latLngBounds(e.bounds)),this._url=t;var i=this.options.subdomains;"string"==typeof i&&(this.options.subdomains=i.split(""))},onAdd:function(t){this._map=t,this._animated=t._zoomAnimated,this._initContainer(),t.on({viewreset:this._reset,moveend:this._update},this),this._animated&&t.on({zoomanim:this._animateZoom,zoomend:this._endZoomAnim},this),this.options.updateWhenIdle||(this._limitedUpdate=o.Util.limitExecByInterval(this._update,150,this),t.on("move",this._limitedUpdate,this)),this._reset(),this._update()},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){this._container.parentNode.removeChild(this._container),t.off({viewreset:this._reset,moveend:this._update},this),this._animated&&t.off({zoomanim:this._animateZoom,zoomend:this._endZoomAnim},this),this.options.updateWhenIdle||t.off("move",this._limitedUpdate,this),this._container=null,this._map=null},bringToFront:function(){var t=this._map._panes.tilePane;return this._container&&(t.appendChild(this._container),this._setAutoZIndex(t,Math.max)),this},bringToBack:function(){var t=this._map._panes.tilePane;return this._container&&(t.insertBefore(this._container,t.firstChild),this._setAutoZIndex(t,Math.min)),this},getAttribution:function(){return this.options.attribution},getContainer:function(){return this._container},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},setZIndex:function(t){return this.options.zIndex=t,this._updateZIndex(),this},setUrl:function(t,e){return this._url=t,e||this.redraw(),this},redraw:function(){return this._map&&(this._reset({hard:!0}),this._update()),this},_updateZIndex:function(){this._container&&this.options.zIndex!==i&&(this._container.style.zIndex=this.options.zIndex)},_setAutoZIndex:function(t,e){var i,n,o,s=t.children,a=-e(1/0,-(1/0));for(n=0,o=s.length;o>n;n++)s[n]!==this._container&&(i=parseInt(s[n].style.zIndex,10),isNaN(i)||(a=e(a,i)));this.options.zIndex=this._container.style.zIndex=(isFinite(a)?a:0)+e(1,-1)},_updateOpacity:function(){var t,e=this._tiles;if(o.Browser.ielt9)for(t in e)o.DomUtil.setOpacity(e[t],this.options.opacity);else o.DomUtil.setOpacity(this._container,this.options.opacity)},_initContainer:function(){var t=this._map._panes.tilePane;if(!this._container){if(this._container=o.DomUtil.create("div","leaflet-layer"),this._updateZIndex(),this._animated){var e="leaflet-tile-container";this._bgBuffer=o.DomUtil.create("div",e,this._container),this._tileContainer=o.DomUtil.create("div",e,this._container)}else this._tileContainer=this._container;t.appendChild(this._container),this.options.opacity<1&&this._updateOpacity()}},_reset:function(t){for(var e in this._tiles)this.fire("tileunload",{tile:this._tiles[e]});this._tiles={},this._tilesToLoad=0,this.options.reuseTiles&&(this._unusedTiles=[]),this._tileContainer.innerHTML="",this._animated&&t&&t.hard&&this._clearBgBuffer(),this._initContainer()},_getTileSize:function(){var t=this._map,e=t.getZoom()+this.options.zoomOffset,i=this.options.maxNativeZoom,n=this.options.tileSize;return i&&e>i&&(n=Math.round(t.getZoomScale(e)/t.getZoomScale(i)*n)),n},_update:function(){if(this._map){var t=this._map,e=t.getPixelBounds(),i=t.getZoom(),n=this._getTileSize();if(!(i>this.options.maxZoom||i<this.options.minZoom)){var s=o.bounds(e.min.divideBy(n)._floor(),e.max.divideBy(n)._floor());this._addTilesFromCenterOut(s),(this.options.unloadInvisibleTiles||this.options.reuseTiles)&&this._removeOtherTiles(s)}}},_addTilesFromCenterOut:function(t){var i,n,s,a=[],r=t.getCenter();for(i=t.min.y;i<=t.max.y;i++)for(n=t.min.x;n<=t.max.x;n++)s=new o.Point(n,i),this._tileShouldBeLoaded(s)&&a.push(s);var h=a.length;if(0!==h){a.sort(function(t,e){return t.distanceTo(r)-e.distanceTo(r)});var l=e.createDocumentFragment();for(this._tilesToLoad||this.fire("loading"),this._tilesToLoad+=h,n=0;h>n;n++)this._addTile(a[n],l);this._tileContainer.appendChild(l)}},_tileShouldBeLoaded:function(t){if(t.x+":"+t.y in this._tiles)return!1;var e=this.options;if(!e.continuousWorld){var i=this._getWrapTileNum();if(e.noWrap&&(t.x<0||t.x>=i.x)||t.y<0||t.y>=i.y)return!1}if(e.bounds){var n=this._getTileSize(),o=t.multiplyBy(n),s=o.add([n,n]),a=this._map.unproject(o),r=this._map.unproject(s);if(e.continuousWorld||e.noWrap||(a=a.wrap(),r=r.wrap()),!e.bounds.intersects([a,r]))return!1}return!0},_removeOtherTiles:function(t){var e,i,n,o;for(o in this._tiles)e=o.split(":"),i=parseInt(e[0],10),n=parseInt(e[1],10),(i<t.min.x||i>t.max.x||n<t.min.y||n>t.max.y)&&this._removeTile(o)},_removeTile:function(t){var e=this._tiles[t];this.fire("tileunload",{tile:e,url:e.src}),this.options.reuseTiles?(o.DomUtil.removeClass(e,"leaflet-tile-loaded"),this._unusedTiles.push(e)):e.parentNode===this._tileContainer&&this._tileContainer.removeChild(e),o.Browser.android||(e.onload=null,e.src=o.Util.emptyImageUrl),delete this._tiles[t]},_addTile:function(t,e){var i=this._getTilePos(t),n=this._getTile();o.DomUtil.setPosition(n,i,o.Browser.chrome),this._tiles[t.x+":"+t.y]=n,this._loadTile(n,t),n.parentNode!==this._tileContainer&&e.appendChild(n)},_getZoomForUrl:function(){var t=this.options,e=this._map.getZoom();return t.zoomReverse&&(e=t.maxZoom-e),e+=t.zoomOffset,t.maxNativeZoom?Math.min(e,t.maxNativeZoom):e},_getTilePos:function(t){var e=this._map.getPixelOrigin(),i=this._getTileSize();return t.multiplyBy(i).subtract(e)},getTileUrl:function(t){return o.Util.template(this._url,o.extend({s:this._getSubdomain(t),z:t.z,x:t.x,y:t.y},this.options))},_getWrapTileNum:function(){var t=this._map.options.crs,e=t.getSize(this._map.getZoom());return e.divideBy(this._getTileSize())._floor()},_adjustTilePoint:function(t){var e=this._getWrapTileNum();this.options.continuousWorld||this.options.noWrap||(t.x=(t.x%e.x+e.x)%e.x),this.options.tms&&(t.y=e.y-t.y-1),t.z=this._getZoomForUrl()},_getSubdomain:function(t){var e=Math.abs(t.x+t.y)%this.options.subdomains.length;return this.options.subdomains[e]},_getTile:function(){if(this.options.reuseTiles&&this._unusedTiles.length>0){var t=this._unusedTiles.pop();return this._resetTile(t),t}return this._createTile()},_resetTile:function(){},_createTile:function(){var t=o.DomUtil.create("img","leaflet-tile");return t.style.width=t.style.height=this._getTileSize()+"px",t.galleryimg="no",t.onselectstart=t.onmousemove=o.Util.falseFn,o.Browser.ielt9&&this.options.opacity!==i&&o.DomUtil.setOpacity(t,this.options.opacity),o.Browser.mobileWebkit3d&&(t.style.WebkitBackfaceVisibility="hidden"),t},_loadTile:function(t,e){t._layer=this,t.onload=this._tileOnLoad,t.onerror=this._tileOnError,this._adjustTilePoint(e),t.src=this.getTileUrl(e),this.fire("tileloadstart",{tile:t,url:t.src})},_tileLoaded:function(){this._tilesToLoad--,this._animated&&o.DomUtil.addClass(this._tileContainer,"leaflet-zoom-animated"),this._tilesToLoad||(this.fire("load"),this._animated&&(clearTimeout(this._clearBgBufferTimer),this._clearBgBufferTimer=setTimeout(o.bind(this._clearBgBuffer,this),500)))},_tileOnLoad:function(){var t=this._layer;this.src!==o.Util.emptyImageUrl&&(o.DomUtil.addClass(this,"leaflet-tile-loaded"),t.fire("tileload",{tile:this,url:this.src})),t._tileLoaded()},_tileOnError:function(){var t=this._layer;t.fire("tileerror",{tile:this,url:this.src});var e=t.options.errorTileUrl;e&&(this.src=e),t._tileLoaded()}}),o.tileLayer=function(t,e){return new o.TileLayer(t,e)},o.TileLayer.WMS=o.TileLayer.extend({defaultWmsParams:{service:"WMS",request:"GetMap",version:"1.1.1",layers:"",styles:"",format:"image/jpeg",transparent:!1},initialize:function(t,e){this._url=t;var i=o.extend({},this.defaultWmsParams),n=e.tileSize||this.options.tileSize;e.detectRetina&&o.Browser.retina?i.width=i.height=2*n:i.width=i.height=n;for(var s in e)this.options.hasOwnProperty(s)||"crs"===s||(i[s]=e[s]);this.wmsParams=i,o.setOptions(this,e)},onAdd:function(t){this._crs=this.options.crs||t.options.crs,this._wmsVersion=parseFloat(this.wmsParams.version);var e=this._wmsVersion>=1.3?"crs":"srs";this.wmsParams[e]=this._crs.code,o.TileLayer.prototype.onAdd.call(this,t)},getTileUrl:function(t){var e=this._map,i=this.options.tileSize,n=t.multiplyBy(i),s=n.add([i,i]),a=this._crs.project(e.unproject(n,t.z)),r=this._crs.project(e.unproject(s,t.z)),h=this._wmsVersion>=1.3&&this._crs===o.CRS.EPSG4326?[r.y,a.x,a.y,r.x].join(","):[a.x,r.y,r.x,a.y].join(","),l=o.Util.template(this._url,{s:this._getSubdomain(t)});return l+o.Util.getParamString(this.wmsParams,l,!0)+"&BBOX="+h},setParams:function(t,e){return o.extend(this.wmsParams,t),e||this.redraw(),this}}),o.tileLayer.wms=function(t,e){return new o.TileLayer.WMS(t,e)},o.TileLayer.Canvas=o.TileLayer.extend({options:{async:!1},initialize:function(t){o.setOptions(this,t)},redraw:function(){this._map&&(this._reset({hard:!0}),this._update());for(var t in this._tiles)this._redrawTile(this._tiles[t]);return this},_redrawTile:function(t){this.drawTile(t,t._tilePoint,this._map._zoom)},_createTile:function(){var t=o.DomUtil.create("canvas","leaflet-tile");return t.width=t.height=this.options.tileSize,t.onselectstart=t.onmousemove=o.Util.falseFn,t},_loadTile:function(t,e){t._layer=this,t._tilePoint=e,this._redrawTile(t),this.options.async||this.tileDrawn(t)},drawTile:function(){},tileDrawn:function(t){this._tileOnLoad.call(t)}}),o.tileLayer.canvas=function(t){return new o.TileLayer.Canvas(t)},o.ImageOverlay=o.Class.extend({includes:o.Mixin.Events,options:{opacity:1},initialize:function(t,e,i){this._url=t,this._bounds=o.latLngBounds(e),o.setOptions(this,i)},onAdd:function(t){this._map=t,this._image||this._initImage(),t._panes.overlayPane.appendChild(this._image),t.on("viewreset",this._reset,this),t.options.zoomAnimation&&o.Browser.any3d&&t.on("zoomanim",this._animateZoom,this),this._reset()},onRemove:function(t){t.getPanes().overlayPane.removeChild(this._image),t.off("viewreset",this._reset,this),t.options.zoomAnimation&&t.off("zoomanim",this._animateZoom,this)},addTo:function(t){return t.addLayer(this),this},setOpacity:function(t){return this.options.opacity=t,this._updateOpacity(),this},bringToFront:function(){return this._image&&this._map._panes.overlayPane.appendChild(this._image),this},bringToBack:function(){var t=this._map._panes.overlayPane;return this._image&&t.insertBefore(this._image,t.firstChild),this},setUrl:function(t){this._url=t,this._image.src=this._url},getAttribution:function(){return this.options.attribution},_initImage:function(){this._image=o.DomUtil.create("img","leaflet-image-layer"),this._map.options.zoomAnimation&&o.Browser.any3d?o.DomUtil.addClass(this._image,"leaflet-zoom-animated"):o.DomUtil.addClass(this._image,"leaflet-zoom-hide"),this._updateOpacity(),o.extend(this._image,{galleryimg:"no",onselectstart:o.Util.falseFn,onmousemove:o.Util.falseFn,onload:o.bind(this._onImageLoad,this),src:this._url})},_animateZoom:function(t){var e=this._map,i=this._image,n=e.getZoomScale(t.zoom),s=this._bounds.getNorthWest(),a=this._bounds.getSouthEast(),r=e._latLngToNewLayerPoint(s,t.zoom,t.center),h=e._latLngToNewLayerPoint(a,t.zoom,t.center)._subtract(r),l=r._add(h._multiplyBy(.5*(1-1/n)));i.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(l)+" scale("+n+") "},_reset:function(){var t=this._image,e=this._map.latLngToLayerPoint(this._bounds.getNorthWest()),i=this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(e);o.DomUtil.setPosition(t,e),t.style.width=i.x+"px",t.style.height=i.y+"px"},_onImageLoad:function(){this.fire("load")},_updateOpacity:function(){o.DomUtil.setOpacity(this._image,this.options.opacity)}}),o.imageOverlay=function(t,e,i){return new o.ImageOverlay(t,e,i)},o.Icon=o.Class.extend({options:{className:""},initialize:function(t){o.setOptions(this,t)},createIcon:function(t){return this._createIcon("icon",t)},createShadow:function(t){return this._createIcon("shadow",t)},_createIcon:function(t,e){var i=this._getIconUrl(t);if(!i){if("icon"===t)throw new Error("iconUrl not set in Icon options (see the docs).");return null}var n;return n=e&&"IMG"===e.tagName?this._createImg(i,e):this._createImg(i),this._setIconStyles(n,t),n},_setIconStyles:function(t,e){var i,n=this.options,s=o.point(n[e+"Size"]);i="shadow"===e?o.point(n.shadowAnchor||n.iconAnchor):o.point(n.iconAnchor),!i&&s&&(i=s.divideBy(2,!0)),t.className="leaflet-marker-"+e+" "+n.className,i&&(t.style.marginLeft=-i.x+"px",t.style.marginTop=-i.y+"px"),s&&(t.style.width=s.x+"px",t.style.height=s.y+"px")},_createImg:function(t,i){return i=i||e.createElement("img"),i.src=t,i},_getIconUrl:function(t){return o.Browser.retina&&this.options[t+"RetinaUrl"]?this.options[t+"RetinaUrl"]:this.options[t+"Url"]}}),o.icon=function(t){return new o.Icon(t)},o.Icon.Default=o.Icon.extend({options:{iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]},_getIconUrl:function(t){var e=t+"Url";if(this.options[e])return this.options[e];o.Browser.retina&&"icon"===t&&(t+="-2x");var i=o.Icon.Default.imagePath;if(!i)throw new Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");return i+"/marker-"+t+".png"}}),o.Icon.Default.imagePath=function(){var t,i,n,o,s,a=e.getElementsByTagName("script"),r=/[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;for(t=0,i=a.length;i>t;t++)if(n=a[t].src,o=n.match(r))return s=n.split(r)[0],(s?s+"/":"")+"images"}(),o.Marker=o.Class.extend({includes:o.Mixin.Events,options:{icon:new o.Icon.Default,title:"",alt:"",clickable:!0,draggable:!1,keyboard:!0,zIndexOffset:0,opacity:1,riseOnHover:!1,riseOffset:250},initialize:function(t,e){o.setOptions(this,e),this._latlng=o.latLng(t)},onAdd:function(t){this._map=t,t.on("viewreset",this.update,this),this._initIcon(),this.update(),this.fire("add"),t.options.zoomAnimation&&t.options.markerZoomAnimation&&t.on("zoomanim",this._animateZoom,this)},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){this.dragging&&this.dragging.disable(),this._removeIcon(),this._removeShadow(),this.fire("remove"),t.off({viewreset:this.update,zoomanim:this._animateZoom},this),this._map=null},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=o.latLng(t),this.update(),this.fire("move",{latlng:this._latlng})},setZIndexOffset:function(t){return this.options.zIndexOffset=t,this.update(),this},setIcon:function(t){return this.options.icon=t,this._map&&(this._initIcon(),this.update()),this._popup&&this.bindPopup(this._popup),this},update:function(){return this._icon&&this._setPos(this._map.latLngToLayerPoint(this._latlng).round()),this},_initIcon:function(){var t=this.options,e=this._map,i=e.options.zoomAnimation&&e.options.markerZoomAnimation,n=i?"leaflet-zoom-animated":"leaflet-zoom-hide",s=t.icon.createIcon(this._icon),a=!1;s!==this._icon&&(this._icon&&this._removeIcon(),a=!0,t.title&&(s.title=t.title),t.alt&&(s.alt=t.alt)),o.DomUtil.addClass(s,n),t.keyboard&&(s.tabIndex="0"),this._icon=s,this._initInteraction(),t.riseOnHover&&o.DomEvent.on(s,"mouseover",this._bringToFront,this).on(s,"mouseout",this._resetZIndex,this);var r=t.icon.createShadow(this._shadow),h=!1;r!==this._shadow&&(this._removeShadow(),h=!0),r&&o.DomUtil.addClass(r,n),this._shadow=r,t.opacity<1&&this._updateOpacity();var l=this._map._panes;a&&l.markerPane.appendChild(this._icon),r&&h&&l.shadowPane.appendChild(this._shadow)},_removeIcon:function(){this.options.riseOnHover&&o.DomEvent.off(this._icon,"mouseover",this._bringToFront).off(this._icon,"mouseout",this._resetZIndex),this._map._panes.markerPane.removeChild(this._icon),this._icon=null},_removeShadow:function(){this._shadow&&this._map._panes.shadowPane.removeChild(this._shadow),this._shadow=null},_setPos:function(t){o.DomUtil.setPosition(this._icon,t),this._shadow&&o.DomUtil.setPosition(this._shadow,t),this._zIndex=t.y+this.options.zIndexOffset,this._resetZIndex()},_updateZIndex:function(t){this._icon.style.zIndex=this._zIndex+t},_animateZoom:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center).round();this._setPos(e)},_initInteraction:function(){if(this.options.clickable){var t=this._icon,e=["dblclick","mousedown","mouseover","mouseout","contextmenu"];o.DomUtil.addClass(t,"leaflet-clickable"),o.DomEvent.on(t,"click",this._onMouseClick,this),o.DomEvent.on(t,"keypress",this._onKeyPress,this);for(var i=0;i<e.length;i++)o.DomEvent.on(t,e[i],this._fireMouseEvent,this);o.Handler.MarkerDrag&&(this.dragging=new o.Handler.MarkerDrag(this),this.options.draggable&&this.dragging.enable())}},_onMouseClick:function(t){var e=this.dragging&&this.dragging.moved();(this.hasEventListeners(t.type)||e)&&o.DomEvent.stopPropagation(t),e||(this.dragging&&this.dragging._enabled||!this._map.dragging||!this._map.dragging.moved())&&this.fire(t.type,{originalEvent:t,latlng:this._latlng})},_onKeyPress:function(t){13===t.keyCode&&this.fire("click",{originalEvent:t,latlng:this._latlng})},_fireMouseEvent:function(t){this.fire(t.type,{originalEvent:t,latlng:this._latlng}),"contextmenu"===t.type&&this.hasEventListeners(t.type)&&o.DomEvent.preventDefault(t),"mousedown"!==t.type?o.DomEvent.stopPropagation(t):o.DomEvent.preventDefault(t)},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},_updateOpacity:function(){o.DomUtil.setOpacity(this._icon,this.options.opacity),this._shadow&&o.DomUtil.setOpacity(this._shadow,this.options.opacity)},_bringToFront:function(){this._updateZIndex(this.options.riseOffset)},_resetZIndex:function(){this._updateZIndex(0)}}),o.marker=function(t,e){return new o.Marker(t,e)},o.DivIcon=o.Icon.extend({options:{iconSize:[12,12],className:"leaflet-div-icon",html:!1},createIcon:function(t){var i=t&&"DIV"===t.tagName?t:e.createElement("div"),n=this.options;return n.html!==!1?i.innerHTML=n.html:i.innerHTML="",n.bgPos&&(i.style.backgroundPosition=-n.bgPos.x+"px "+-n.bgPos.y+"px"),this._setIconStyles(i,"icon"),i},createShadow:function(){return null}}),o.divIcon=function(t){return new o.DivIcon(t)},o.Map.mergeOptions({closePopupOnClick:!0}),o.Popup=o.Class.extend({includes:o.Mixin.Events,options:{minWidth:50,maxWidth:300,autoPan:!0,closeButton:!0,offset:[0,7],autoPanPadding:[5,5],keepInView:!1,className:"",zoomAnimation:!0},initialize:function(t,e){o.setOptions(this,t),this._source=e,this._animated=o.Browser.any3d&&this.options.zoomAnimation,this._isOpen=!1},onAdd:function(t){this._map=t,this._container||this._initLayout();var e=t.options.fadeAnimation;e&&o.DomUtil.setOpacity(this._container,0),t._panes.popupPane.appendChild(this._container),t.on(this._getEvents(),this),this.update(),e&&o.DomUtil.setOpacity(this._container,1),this.fire("open"),t.fire("popupopen",{popup:this}),this._source&&this._source.fire("popupopen",{popup:this})},addTo:function(t){return t.addLayer(this),this},openOn:function(t){return t.openPopup(this),this},onRemove:function(t){t._panes.popupPane.removeChild(this._container),o.Util.falseFn(this._container.offsetWidth),t.off(this._getEvents(),this),t.options.fadeAnimation&&o.DomUtil.setOpacity(this._container,0),this._map=null,this.fire("close"),t.fire("popupclose",{popup:this}),this._source&&this._source.fire("popupclose",{popup:this})},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=o.latLng(t),this._map&&(this._updatePosition(),this._adjustPan()),this},getContent:function(){return this._content},setContent:function(t){return this._content=t,this.update(),this},update:function(){this._map&&(this._container.style.visibility="hidden",this._updateContent(),this._updateLayout(),this._updatePosition(),this._container.style.visibility="",this._adjustPan())},_getEvents:function(){var t={viewreset:this._updatePosition};return this._animated&&(t.zoomanim=this._zoomAnimation),("closeOnClick"in this.options?this.options.closeOnClick:this._map.options.closePopupOnClick)&&(t.preclick=this._close),this.options.keepInView&&(t.moveend=this._adjustPan),t},_close:function(){this._map&&this._map.closePopup(this)},_initLayout:function(){var t,e="leaflet-popup",i=e+" "+this.options.className+" leaflet-zoom-"+(this._animated?"animated":"hide"),n=this._container=o.DomUtil.create("div",i);this.options.closeButton&&(t=this._closeButton=o.DomUtil.create("a",e+"-close-button",n),t.href="#close",t.innerHTML="&#215;",o.DomEvent.disableClickPropagation(t),o.DomEvent.on(t,"click",this._onCloseButtonClick,this));var s=this._wrapper=o.DomUtil.create("div",e+"-content-wrapper",n);o.DomEvent.disableClickPropagation(s),this._contentNode=o.DomUtil.create("div",e+"-content",s),o.DomEvent.disableScrollPropagation(this._contentNode),o.DomEvent.on(s,"contextmenu",o.DomEvent.stopPropagation),this._tipContainer=o.DomUtil.create("div",e+"-tip-container",n),this._tip=o.DomUtil.create("div",e+"-tip",this._tipContainer)},_updateContent:function(){if(this._content){if("string"==typeof this._content)this._contentNode.innerHTML=this._content;else{for(;this._contentNode.hasChildNodes();)this._contentNode.removeChild(this._contentNode.firstChild);this._contentNode.appendChild(this._content)}this.fire("contentupdate")}},_updateLayout:function(){var t=this._contentNode,e=t.style;e.width="",e.whiteSpace="nowrap";var i=t.offsetWidth;i=Math.min(i,this.options.maxWidth),i=Math.max(i,this.options.minWidth),e.width=i+1+"px",e.whiteSpace="",e.height="";var n=t.offsetHeight,s=this.options.maxHeight,a="leaflet-popup-scrolled";s&&n>s?(e.height=s+"px",o.DomUtil.addClass(t,a)):o.DomUtil.removeClass(t,a),this._containerWidth=this._container.offsetWidth},_updatePosition:function(){if(this._map){var t=this._map.latLngToLayerPoint(this._latlng),e=this._animated,i=o.point(this.options.offset);e&&o.DomUtil.setPosition(this._container,t),this._containerBottom=-i.y-(e?0:t.y),this._containerLeft=-Math.round(this._containerWidth/2)+i.x+(e?0:t.x),this._container.style.bottom=this._containerBottom+"px",this._container.style.left=this._containerLeft+"px"}},_zoomAnimation:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center);o.DomUtil.setPosition(this._container,e)},_adjustPan:function(){if(this.options.autoPan){var t=this._map,e=this._container.offsetHeight,i=this._containerWidth,n=new o.Point(this._containerLeft,-e-this._containerBottom);this._animated&&n._add(o.DomUtil.getPosition(this._container));var s=t.layerPointToContainerPoint(n),a=o.point(this.options.autoPanPadding),r=o.point(this.options.autoPanPaddingTopLeft||a),h=o.point(this.options.autoPanPaddingBottomRight||a),l=t.getSize(),u=0,c=0;s.x+i+h.x>l.x&&(u=s.x+i-l.x+h.x),s.x-u-r.x<0&&(u=s.x-r.x),s.y+e+h.y>l.y&&(c=s.y+e-l.y+h.y),s.y-c-r.y<0&&(c=s.y-r.y),(u||c)&&t.fire("autopanstart").panBy([u,c])}},_onCloseButtonClick:function(t){this._close(),o.DomEvent.stop(t)}}),o.popup=function(t,e){return new o.Popup(t,e)},o.Map.include({openPopup:function(t,e,i){if(this.closePopup(),!(t instanceof o.Popup)){var n=t;t=new o.Popup(i).setLatLng(e).setContent(n)}return t._isOpen=!0,this._popup=t,this.addLayer(t)},closePopup:function(t){return t&&t!==this._popup||(t=this._popup,this._popup=null),t&&(this.removeLayer(t),t._isOpen=!1),this}}),o.Marker.include({openPopup:function(){return this._popup&&this._map&&!this._map.hasLayer(this._popup)&&(this._popup.setLatLng(this._latlng),this._map.openPopup(this._popup)),this},closePopup:function(){return this._popup&&this._popup._close(),this},togglePopup:function(){return this._popup&&(this._popup._isOpen?this.closePopup():this.openPopup()),this},bindPopup:function(t,e){var i=o.point(this.options.icon.options.popupAnchor||[0,0]);return i=i.add(o.Popup.prototype.options.offset),e&&e.offset&&(i=i.add(e.offset)),e=o.extend({offset:i},e),this._popupHandlersAdded||(this.on("click",this.togglePopup,this).on("remove",this.closePopup,this).on("move",this._movePopup,this),this._popupHandlersAdded=!0),t instanceof o.Popup?(o.setOptions(t,e),this._popup=t,t._source=this):this._popup=new o.Popup(e,this).setContent(t),this},setPopupContent:function(t){return this._popup&&this._popup.setContent(t),this},unbindPopup:function(){return this._popup&&(this._popup=null,this.off("click",this.togglePopup,this).off("remove",this.closePopup,this).off("move",this._movePopup,this),this._popupHandlersAdded=!1),this},getPopup:function(){return this._popup},_movePopup:function(t){this._popup.setLatLng(t.latlng)}}),o.LayerGroup=o.Class.extend({initialize:function(t){this._layers={};var e,i;if(t)for(e=0,i=t.length;i>e;e++)this.addLayer(t[e])},addLayer:function(t){var e=this.getLayerId(t);return this._layers[e]=t,this._map&&this._map.addLayer(t),this},removeLayer:function(t){var e=t in this._layers?t:this.getLayerId(t);return this._map&&this._layers[e]&&this._map.removeLayer(this._layers[e]),delete this._layers[e],this},hasLayer:function(t){return t?t in this._layers||this.getLayerId(t)in this._layers:!1},clearLayers:function(){return this.eachLayer(this.removeLayer,this),this},invoke:function(t){var e,i,n=Array.prototype.slice.call(arguments,1);for(e in this._layers)i=this._layers[e],i[t]&&i[t].apply(i,n);return this},onAdd:function(t){this._map=t,this.eachLayer(t.addLayer,t)},onRemove:function(t){this.eachLayer(t.removeLayer,t),this._map=null},addTo:function(t){return t.addLayer(this),this},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},getLayer:function(t){return this._layers[t]},getLayers:function(){var t=[];for(var e in this._layers)t.push(this._layers[e]);return t},setZIndex:function(t){return this.invoke("setZIndex",t)},getLayerId:function(t){return o.stamp(t)}}),o.layerGroup=function(t){return new o.LayerGroup(t)},o.FeatureGroup=o.LayerGroup.extend({includes:o.Mixin.Events,statics:{EVENTS:"click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"},addLayer:function(t){return this.hasLayer(t)?this:("on"in t&&t.on(o.FeatureGroup.EVENTS,this._propagateEvent,this),o.LayerGroup.prototype.addLayer.call(this,t),this._popupContent&&t.bindPopup&&t.bindPopup(this._popupContent,this._popupOptions),this.fire("layeradd",{layer:t}))},removeLayer:function(t){return this.hasLayer(t)?(t in this._layers&&(t=this._layers[t]),"off"in t&&t.off(o.FeatureGroup.EVENTS,this._propagateEvent,this),o.LayerGroup.prototype.removeLayer.call(this,t),this._popupContent&&this.invoke("unbindPopup"),this.fire("layerremove",{layer:t})):this},bindPopup:function(t,e){return this._popupContent=t,this._popupOptions=e,this.invoke("bindPopup",t,e)},openPopup:function(t){for(var e in this._layers){this._layers[e].openPopup(t);break}return this},setStyle:function(t){return this.invoke("setStyle",t)},bringToFront:function(){return this.invoke("bringToFront")},bringToBack:function(){return this.invoke("bringToBack")},getBounds:function(){var t=new o.LatLngBounds;return this.eachLayer(function(e){t.extend(e instanceof o.Marker?e.getLatLng():e.getBounds())}),t},_propagateEvent:function(t){t=o.extend({layer:t.target,target:this},t),this.fire(t.type,t)}}),o.featureGroup=function(t){return new o.FeatureGroup(t)},o.Path=o.Class.extend({includes:[o.Mixin.Events],statics:{CLIP_PADDING:function(){var e=o.Browser.mobile?1280:2e3,i=(e/Math.max(t.outerWidth,t.outerHeight)-1)/2;return Math.max(0,Math.min(.5,i))}()},options:{stroke:!0,color:"#0033ff",dashArray:null,lineCap:null,lineJoin:null,weight:5,opacity:.5,fill:!1,fillColor:null,fillOpacity:.2,clickable:!0},initialize:function(t){o.setOptions(this,t)},onAdd:function(t){this._map=t,this._container||(this._initElements(),this._initEvents()),this.projectLatlngs(),this._updatePath(),this._container&&this._map._pathRoot.appendChild(this._container),this.fire("add"),t.on({viewreset:this.projectLatlngs,moveend:this._updatePath},this)},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){t._pathRoot.removeChild(this._container),this.fire("remove"),this._map=null,o.Browser.vml&&(this._container=null,this._stroke=null,this._fill=null),t.off({viewreset:this.projectLatlngs,moveend:this._updatePath},this)},projectLatlngs:function(){},setStyle:function(t){return o.setOptions(this,t),this._container&&this._updateStyle(),this},redraw:function(){return this._map&&(this.projectLatlngs(),this._updatePath()),this}}),o.Map.include({_updatePathViewport:function(){var t=o.Path.CLIP_PADDING,e=this.getSize(),i=o.DomUtil.getPosition(this._mapPane),n=i.multiplyBy(-1)._subtract(e.multiplyBy(t)._round()),s=n.add(e.multiplyBy(1+2*t)._round());this._pathViewport=new o.Bounds(n,s)}}),o.Path.SVG_NS="http://www.w3.org/2000/svg",o.Browser.svg=!(!e.createElementNS||!e.createElementNS(o.Path.SVG_NS,"svg").createSVGRect),o.Path=o.Path.extend({statics:{SVG:o.Browser.svg},bringToFront:function(){var t=this._map._pathRoot,e=this._container;return e&&t.lastChild!==e&&t.appendChild(e),this},bringToBack:function(){var t=this._map._pathRoot,e=this._container,i=t.firstChild;return e&&i!==e&&t.insertBefore(e,i),this},getPathString:function(){},_createElement:function(t){return e.createElementNS(o.Path.SVG_NS,t)},_initElements:function(){this._map._initPathRoot(),this._initPath(),this._initStyle()},_initPath:function(){this._container=this._createElement("g"),this._path=this._createElement("path"),this.options.className&&o.DomUtil.addClass(this._path,this.options.className),this._container.appendChild(this._path)},_initStyle:function(){this.options.stroke&&(this._path.setAttribute("stroke-linejoin","round"),this._path.setAttribute("stroke-linecap","round")),this.options.fill&&this._path.setAttribute("fill-rule","evenodd"),this.options.pointerEvents&&this._path.setAttribute("pointer-events",this.options.pointerEvents),this.options.clickable||this.options.pointerEvents||this._path.setAttribute("pointer-events","none"),this._updateStyle()},_updateStyle:function(){this.options.stroke?(this._path.setAttribute("stroke",this.options.color),this._path.setAttribute("stroke-opacity",this.options.opacity),this._path.setAttribute("stroke-width",this.options.weight),this.options.dashArray?this._path.setAttribute("stroke-dasharray",this.options.dashArray):this._path.removeAttribute("stroke-dasharray"),this.options.lineCap&&this._path.setAttribute("stroke-linecap",this.options.lineCap),this.options.lineJoin&&this._path.setAttribute("stroke-linejoin",this.options.lineJoin)):this._path.setAttribute("stroke","none"),this.options.fill?(this._path.setAttribute("fill",this.options.fillColor||this.options.color),this._path.setAttribute("fill-opacity",this.options.fillOpacity)):this._path.setAttribute("fill","none")},_updatePath:function(){var t=this.getPathString();t||(t="M0 0"),this._path.setAttribute("d",t)},_initEvents:function(){if(this.options.clickable){(o.Browser.svg||!o.Browser.vml)&&o.DomUtil.addClass(this._path,"leaflet-clickable"),o.DomEvent.on(this._container,"click",this._onMouseClick,this);for(var t=["dblclick","mousedown","mouseover","mouseout","mousemove","contextmenu"],e=0;e<t.length;e++)o.DomEvent.on(this._container,t[e],this._fireMouseEvent,this)}},_onMouseClick:function(t){this._map.dragging&&this._map.dragging.moved()||this._fireMouseEvent(t)},_fireMouseEvent:function(t){if(this._map&&this.hasEventListeners(t.type)){var e=this._map,i=e.mouseEventToContainerPoint(t),n=e.containerPointToLayerPoint(i),s=e.layerPointToLatLng(n);this.fire(t.type,{latlng:s,layerPoint:n,containerPoint:i,originalEvent:t}),"contextmenu"===t.type&&o.DomEvent.preventDefault(t),"mousemove"!==t.type&&o.DomEvent.stopPropagation(t)}}}),o.Map.include({_initPathRoot:function(){this._pathRoot||(this._pathRoot=o.Path.prototype._createElement("svg"),this._panes.overlayPane.appendChild(this._pathRoot),this.options.zoomAnimation&&o.Browser.any3d?(o.DomUtil.addClass(this._pathRoot,"leaflet-zoom-animated"),
   this.on({zoomanim:this._animatePathZoom,zoomend:this._endPathZoom})):o.DomUtil.addClass(this._pathRoot,"leaflet-zoom-hide"),this.on("moveend",this._updateSvgViewport),this._updateSvgViewport())},_animatePathZoom:function(t){var e=this.getZoomScale(t.zoom),i=this._getCenterOffset(t.center)._multiplyBy(-e)._add(this._pathViewport.min);this._pathRoot.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(i)+" scale("+e+") ",this._pathZooming=!0},_endPathZoom:function(){this._pathZooming=!1},_updateSvgViewport:function(){if(!this._pathZooming){this._updatePathViewport();var t=this._pathViewport,e=t.min,i=t.max,n=i.x-e.x,s=i.y-e.y,a=this._pathRoot,r=this._panes.overlayPane;o.Browser.mobileWebkit&&r.removeChild(a),o.DomUtil.setPosition(a,e),a.setAttribute("width",n),a.setAttribute("height",s),a.setAttribute("viewBox",[e.x,e.y,n,s].join(" ")),o.Browser.mobileWebkit&&r.appendChild(a)}}}),o.Path.include({bindPopup:function(t,e){return t instanceof o.Popup?this._popup=t:((!this._popup||e)&&(this._popup=new o.Popup(e,this)),this._popup.setContent(t)),this._popupHandlersAdded||(this.on("click",this._openPopup,this).on("remove",this.closePopup,this),this._popupHandlersAdded=!0),this},unbindPopup:function(){return this._popup&&(this._popup=null,this.off("click",this._openPopup).off("remove",this.closePopup),this._popupHandlersAdded=!1),this},openPopup:function(t){return this._popup&&(t=t||this._latlng||this._latlngs[Math.floor(this._latlngs.length/2)],this._openPopup({latlng:t})),this},closePopup:function(){return this._popup&&this._popup._close(),this},_openPopup:function(t){this._popup.setLatLng(t.latlng),this._map.openPopup(this._popup)}}),o.Browser.vml=!o.Browser.svg&&function(){try{var t=e.createElement("div");t.innerHTML='<v:shape adj="1"/>';var i=t.firstChild;return i.style.behavior="url(#default#VML)",i&&"object"==typeof i.adj}catch(n){return!1}}(),o.Path=o.Browser.svg||!o.Browser.vml?o.Path:o.Path.extend({statics:{VML:!0,CLIP_PADDING:.02},_createElement:function(){try{return e.namespaces.add("lvml","urn:schemas-microsoft-com:vml"),function(t){return e.createElement("<lvml:"+t+' class="lvml">')}}catch(t){return function(t){return e.createElement("<"+t+' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')}}}(),_initPath:function(){var t=this._container=this._createElement("shape");o.DomUtil.addClass(t,"leaflet-vml-shape"+(this.options.className?" "+this.options.className:"")),this.options.clickable&&o.DomUtil.addClass(t,"leaflet-clickable"),t.coordsize="1 1",this._path=this._createElement("path"),t.appendChild(this._path),this._map._pathRoot.appendChild(t)},_initStyle:function(){this._updateStyle()},_updateStyle:function(){var t=this._stroke,e=this._fill,i=this.options,n=this._container;n.stroked=i.stroke,n.filled=i.fill,i.stroke?(t||(t=this._stroke=this._createElement("stroke"),t.endcap="round",n.appendChild(t)),t.weight=i.weight+"px",t.color=i.color,t.opacity=i.opacity,i.dashArray?t.dashStyle=o.Util.isArray(i.dashArray)?i.dashArray.join(" "):i.dashArray.replace(/( *, *)/g," "):t.dashStyle="",i.lineCap&&(t.endcap=i.lineCap.replace("butt","flat")),i.lineJoin&&(t.joinstyle=i.lineJoin)):t&&(n.removeChild(t),this._stroke=null),i.fill?(e||(e=this._fill=this._createElement("fill"),n.appendChild(e)),e.color=i.fillColor||i.color,e.opacity=i.fillOpacity):e&&(n.removeChild(e),this._fill=null)},_updatePath:function(){var t=this._container.style;t.display="none",this._path.v=this.getPathString()+" ",t.display=""}}),o.Map.include(o.Browser.svg||!o.Browser.vml?{}:{_initPathRoot:function(){if(!this._pathRoot){var t=this._pathRoot=e.createElement("div");t.className="leaflet-vml-container",this._panes.overlayPane.appendChild(t),this.on("moveend",this._updatePathViewport),this._updatePathViewport()}}}),o.Browser.canvas=function(){return!!e.createElement("canvas").getContext}(),o.Path=o.Path.SVG&&!t.L_PREFER_CANVAS||!o.Browser.canvas?o.Path:o.Path.extend({statics:{CANVAS:!0,SVG:!1},redraw:function(){return this._map&&(this.projectLatlngs(),this._requestUpdate()),this},setStyle:function(t){return o.setOptions(this,t),this._map&&(this._updateStyle(),this._requestUpdate()),this},onRemove:function(t){t.off("viewreset",this.projectLatlngs,this).off("moveend",this._updatePath,this),this.options.clickable&&(this._map.off("click",this._onClick,this),this._map.off("mousemove",this._onMouseMove,this)),this._requestUpdate(),this.fire("remove"),this._map=null},_requestUpdate:function(){this._map&&!o.Path._updateRequest&&(o.Path._updateRequest=o.Util.requestAnimFrame(this._fireMapMoveEnd,this._map))},_fireMapMoveEnd:function(){o.Path._updateRequest=null,this.fire("moveend")},_initElements:function(){this._map._initPathRoot(),this._ctx=this._map._canvasCtx},_updateStyle:function(){var t=this.options;t.stroke&&(this._ctx.lineWidth=t.weight,this._ctx.strokeStyle=t.color),t.fill&&(this._ctx.fillStyle=t.fillColor||t.color),t.lineCap&&(this._ctx.lineCap=t.lineCap),t.lineJoin&&(this._ctx.lineJoin=t.lineJoin)},_drawPath:function(){var t,e,i,n,s,a;for(this._ctx.beginPath(),t=0,i=this._parts.length;i>t;t++){for(e=0,n=this._parts[t].length;n>e;e++)s=this._parts[t][e],a=(0===e?"move":"line")+"To",this._ctx[a](s.x,s.y);this instanceof o.Polygon&&this._ctx.closePath()}},_checkIfEmpty:function(){return!this._parts.length},_updatePath:function(){if(!this._checkIfEmpty()){var t=this._ctx,e=this.options;this._drawPath(),t.save(),this._updateStyle(),e.fill&&(t.globalAlpha=e.fillOpacity,t.fill(e.fillRule||"evenodd")),e.stroke&&(t.globalAlpha=e.opacity,t.stroke()),t.restore()}},_initEvents:function(){this.options.clickable&&(this._map.on("mousemove",this._onMouseMove,this),this._map.on("click dblclick contextmenu",this._fireMouseEvent,this))},_fireMouseEvent:function(t){this._containsPoint(t.layerPoint)&&this.fire(t.type,t)},_onMouseMove:function(t){this._map&&!this._map._animatingZoom&&(this._containsPoint(t.layerPoint)?(this._ctx.canvas.style.cursor="pointer",this._mouseInside=!0,this.fire("mouseover",t)):this._mouseInside&&(this._ctx.canvas.style.cursor="",this._mouseInside=!1,this.fire("mouseout",t)))}}),o.Map.include(o.Path.SVG&&!t.L_PREFER_CANVAS||!o.Browser.canvas?{}:{_initPathRoot:function(){var t,i=this._pathRoot;i||(i=this._pathRoot=e.createElement("canvas"),i.style.position="absolute",t=this._canvasCtx=i.getContext("2d"),t.lineCap="round",t.lineJoin="round",this._panes.overlayPane.appendChild(i),this.options.zoomAnimation&&(this._pathRoot.className="leaflet-zoom-animated",this.on("zoomanim",this._animatePathZoom),this.on("zoomend",this._endPathZoom)),this.on("moveend",this._updateCanvasViewport),this._updateCanvasViewport())},_updateCanvasViewport:function(){if(!this._pathZooming){this._updatePathViewport();var t=this._pathViewport,e=t.min,i=t.max.subtract(e),n=this._pathRoot;o.DomUtil.setPosition(n,e),n.width=i.x,n.height=i.y,n.getContext("2d").translate(-e.x,-e.y)}}}),o.LineUtil={simplify:function(t,e){if(!e||!t.length)return t.slice();var i=e*e;return t=this._reducePoints(t,i),t=this._simplifyDP(t,i)},pointToSegmentDistance:function(t,e,i){return Math.sqrt(this._sqClosestPointOnSegment(t,e,i,!0))},closestPointOnSegment:function(t,e,i){return this._sqClosestPointOnSegment(t,e,i)},_simplifyDP:function(t,e){var n=t.length,o=typeof Uint8Array!=i+""?Uint8Array:Array,s=new o(n);s[0]=s[n-1]=1,this._simplifyDPStep(t,s,e,0,n-1);var a,r=[];for(a=0;n>a;a++)s[a]&&r.push(t[a]);return r},_simplifyDPStep:function(t,e,i,n,o){var s,a,r,h=0;for(a=n+1;o-1>=a;a++)r=this._sqClosestPointOnSegment(t[a],t[n],t[o],!0),r>h&&(s=a,h=r);h>i&&(e[s]=1,this._simplifyDPStep(t,e,i,n,s),this._simplifyDPStep(t,e,i,s,o))},_reducePoints:function(t,e){for(var i=[t[0]],n=1,o=0,s=t.length;s>n;n++)this._sqDist(t[n],t[o])>e&&(i.push(t[n]),o=n);return s-1>o&&i.push(t[s-1]),i},clipSegment:function(t,e,i,n){var o,s,a,r=n?this._lastCode:this._getBitCode(t,i),h=this._getBitCode(e,i);for(this._lastCode=h;;){if(!(r|h))return[t,e];if(r&h)return!1;o=r||h,s=this._getEdgeIntersection(t,e,o,i),a=this._getBitCode(s,i),o===r?(t=s,r=a):(e=s,h=a)}},_getEdgeIntersection:function(t,e,i,n){var s=e.x-t.x,a=e.y-t.y,r=n.min,h=n.max;return 8&i?new o.Point(t.x+s*(h.y-t.y)/a,h.y):4&i?new o.Point(t.x+s*(r.y-t.y)/a,r.y):2&i?new o.Point(h.x,t.y+a*(h.x-t.x)/s):1&i?new o.Point(r.x,t.y+a*(r.x-t.x)/s):void 0},_getBitCode:function(t,e){var i=0;return t.x<e.min.x?i|=1:t.x>e.max.x&&(i|=2),t.y<e.min.y?i|=4:t.y>e.max.y&&(i|=8),i},_sqDist:function(t,e){var i=e.x-t.x,n=e.y-t.y;return i*i+n*n},_sqClosestPointOnSegment:function(t,e,i,n){var s,a=e.x,r=e.y,h=i.x-a,l=i.y-r,u=h*h+l*l;return u>0&&(s=((t.x-a)*h+(t.y-r)*l)/u,s>1?(a=i.x,r=i.y):s>0&&(a+=h*s,r+=l*s)),h=t.x-a,l=t.y-r,n?h*h+l*l:new o.Point(a,r)}},o.Polyline=o.Path.extend({initialize:function(t,e){o.Path.prototype.initialize.call(this,e),this._latlngs=this._convertLatLngs(t)},options:{smoothFactor:1,noClip:!1},projectLatlngs:function(){this._originalPoints=[];for(var t=0,e=this._latlngs.length;e>t;t++)this._originalPoints[t]=this._map.latLngToLayerPoint(this._latlngs[t])},getPathString:function(){for(var t=0,e=this._parts.length,i="";e>t;t++)i+=this._getPathPartStr(this._parts[t]);return i},getLatLngs:function(){return this._latlngs},setLatLngs:function(t){return this._latlngs=this._convertLatLngs(t),this.redraw()},addLatLng:function(t){return this._latlngs.push(o.latLng(t)),this.redraw()},spliceLatLngs:function(){var t=[].splice.apply(this._latlngs,arguments);return this._convertLatLngs(this._latlngs,!0),this.redraw(),t},closestLayerPoint:function(t){for(var e,i,n=1/0,s=this._parts,a=null,r=0,h=s.length;h>r;r++)for(var l=s[r],u=1,c=l.length;c>u;u++){e=l[u-1],i=l[u];var d=o.LineUtil._sqClosestPointOnSegment(t,e,i,!0);n>d&&(n=d,a=o.LineUtil._sqClosestPointOnSegment(t,e,i))}return a&&(a.distance=Math.sqrt(n)),a},getBounds:function(){return new o.LatLngBounds(this.getLatLngs())},_convertLatLngs:function(t,e){var i,n,s=e?t:[];for(i=0,n=t.length;n>i;i++){if(o.Util.isArray(t[i])&&"number"!=typeof t[i][0])return;s[i]=o.latLng(t[i])}return s},_initEvents:function(){o.Path.prototype._initEvents.call(this)},_getPathPartStr:function(t){for(var e,i=o.Path.VML,n=0,s=t.length,a="";s>n;n++)e=t[n],i&&e._round(),a+=(n?"L":"M")+e.x+" "+e.y;return a},_clipPoints:function(){var t,e,i,n=this._originalPoints,s=n.length;if(this.options.noClip)return void(this._parts=[n]);this._parts=[];var a=this._parts,r=this._map._pathViewport,h=o.LineUtil;for(t=0,e=0;s-1>t;t++)i=h.clipSegment(n[t],n[t+1],r,t),i&&(a[e]=a[e]||[],a[e].push(i[0]),(i[1]!==n[t+1]||t===s-2)&&(a[e].push(i[1]),e++))},_simplifyPoints:function(){for(var t=this._parts,e=o.LineUtil,i=0,n=t.length;n>i;i++)t[i]=e.simplify(t[i],this.options.smoothFactor)},_updatePath:function(){this._map&&(this._clipPoints(),this._simplifyPoints(),o.Path.prototype._updatePath.call(this))}}),o.polyline=function(t,e){return new o.Polyline(t,e)},o.PolyUtil={},o.PolyUtil.clipPolygon=function(t,e){var i,n,s,a,r,h,l,u,c,d=[1,4,2,8],p=o.LineUtil;for(n=0,l=t.length;l>n;n++)t[n]._code=p._getBitCode(t[n],e);for(a=0;4>a;a++){for(u=d[a],i=[],n=0,l=t.length,s=l-1;l>n;s=n++)r=t[n],h=t[s],r._code&u?h._code&u||(c=p._getEdgeIntersection(h,r,u,e),c._code=p._getBitCode(c,e),i.push(c)):(h._code&u&&(c=p._getEdgeIntersection(h,r,u,e),c._code=p._getBitCode(c,e),i.push(c)),i.push(r));t=i}return t},o.Polygon=o.Polyline.extend({options:{fill:!0},initialize:function(t,e){o.Polyline.prototype.initialize.call(this,t,e),this._initWithHoles(t)},_initWithHoles:function(t){var e,i,n;if(t&&o.Util.isArray(t[0])&&"number"!=typeof t[0][0])for(this._latlngs=this._convertLatLngs(t[0]),this._holes=t.slice(1),e=0,i=this._holes.length;i>e;e++)n=this._holes[e]=this._convertLatLngs(this._holes[e]),n[0].equals(n[n.length-1])&&n.pop();t=this._latlngs,t.length>=2&&t[0].equals(t[t.length-1])&&t.pop()},projectLatlngs:function(){if(o.Polyline.prototype.projectLatlngs.call(this),this._holePoints=[],this._holes){var t,e,i,n;for(t=0,i=this._holes.length;i>t;t++)for(this._holePoints[t]=[],e=0,n=this._holes[t].length;n>e;e++)this._holePoints[t][e]=this._map.latLngToLayerPoint(this._holes[t][e])}},setLatLngs:function(t){return t&&o.Util.isArray(t[0])&&"number"!=typeof t[0][0]?(this._initWithHoles(t),this.redraw()):o.Polyline.prototype.setLatLngs.call(this,t)},_clipPoints:function(){var t=this._originalPoints,e=[];if(this._parts=[t].concat(this._holePoints),!this.options.noClip){for(var i=0,n=this._parts.length;n>i;i++){var s=o.PolyUtil.clipPolygon(this._parts[i],this._map._pathViewport);s.length&&e.push(s)}this._parts=e}},_getPathPartStr:function(t){var e=o.Polyline.prototype._getPathPartStr.call(this,t);return e+(o.Browser.svg?"z":"x")}}),o.polygon=function(t,e){return new o.Polygon(t,e)},function(){function t(t){return o.FeatureGroup.extend({initialize:function(t,e){this._layers={},this._options=e,this.setLatLngs(t)},setLatLngs:function(e){var i=0,n=e.length;for(this.eachLayer(function(t){n>i?t.setLatLngs(e[i++]):this.removeLayer(t)},this);n>i;)this.addLayer(new t(e[i++],this._options));return this},getLatLngs:function(){var t=[];return this.eachLayer(function(e){t.push(e.getLatLngs())}),t}})}o.MultiPolyline=t(o.Polyline),o.MultiPolygon=t(o.Polygon),o.multiPolyline=function(t,e){return new o.MultiPolyline(t,e)},o.multiPolygon=function(t,e){return new o.MultiPolygon(t,e)}}(),o.Rectangle=o.Polygon.extend({initialize:function(t,e){o.Polygon.prototype.initialize.call(this,this._boundsToLatLngs(t),e)},setBounds:function(t){this.setLatLngs(this._boundsToLatLngs(t))},_boundsToLatLngs:function(t){return t=o.latLngBounds(t),[t.getSouthWest(),t.getNorthWest(),t.getNorthEast(),t.getSouthEast()]}}),o.rectangle=function(t,e){return new o.Rectangle(t,e)},o.Circle=o.Path.extend({initialize:function(t,e,i){o.Path.prototype.initialize.call(this,i),this._latlng=o.latLng(t),this._mRadius=e},options:{fill:!0},setLatLng:function(t){return this._latlng=o.latLng(t),this.redraw()},setRadius:function(t){return this._mRadius=t,this.redraw()},projectLatlngs:function(){var t=this._getLngRadius(),e=this._latlng,i=this._map.latLngToLayerPoint([e.lat,e.lng-t]);this._point=this._map.latLngToLayerPoint(e),this._radius=Math.max(this._point.x-i.x,1)},getBounds:function(){var t=this._getLngRadius(),e=this._mRadius/40075017*360,i=this._latlng;return new o.LatLngBounds([i.lat-e,i.lng-t],[i.lat+e,i.lng+t])},getLatLng:function(){return this._latlng},getPathString:function(){var t=this._point,e=this._radius;return this._checkIfEmpty()?"":o.Browser.svg?"M"+t.x+","+(t.y-e)+"A"+e+","+e+",0,1,1,"+(t.x-.1)+","+(t.y-e)+" z":(t._round(),e=Math.round(e),"AL "+t.x+","+t.y+" "+e+","+e+" 0,23592600")},getRadius:function(){return this._mRadius},_getLatRadius:function(){return this._mRadius/40075017*360},_getLngRadius:function(){return this._getLatRadius()/Math.cos(o.LatLng.DEG_TO_RAD*this._latlng.lat)},_checkIfEmpty:function(){if(!this._map)return!1;var t=this._map._pathViewport,e=this._radius,i=this._point;return i.x-e>t.max.x||i.y-e>t.max.y||i.x+e<t.min.x||i.y+e<t.min.y}}),o.circle=function(t,e,i){return new o.Circle(t,e,i)},o.CircleMarker=o.Circle.extend({options:{radius:10,weight:2},initialize:function(t,e){o.Circle.prototype.initialize.call(this,t,null,e),this._radius=this.options.radius},projectLatlngs:function(){this._point=this._map.latLngToLayerPoint(this._latlng)},_updateStyle:function(){o.Circle.prototype._updateStyle.call(this),this.setRadius(this.options.radius)},setLatLng:function(t){return o.Circle.prototype.setLatLng.call(this,t),this._popup&&this._popup._isOpen&&this._popup.setLatLng(t),this},setRadius:function(t){return this.options.radius=this._radius=t,this.redraw()},getRadius:function(){return this._radius}}),o.circleMarker=function(t,e){return new o.CircleMarker(t,e)},o.Polyline.include(o.Path.CANVAS?{_containsPoint:function(t,e){var i,n,s,a,r,h,l,u=this.options.weight/2;for(o.Browser.touch&&(u+=10),i=0,a=this._parts.length;a>i;i++)for(l=this._parts[i],n=0,r=l.length,s=r-1;r>n;s=n++)if((e||0!==n)&&(h=o.LineUtil.pointToSegmentDistance(t,l[s],l[n]),u>=h))return!0;return!1}}:{}),o.Polygon.include(o.Path.CANVAS?{_containsPoint:function(t){var e,i,n,s,a,r,h,l,u=!1;if(o.Polyline.prototype._containsPoint.call(this,t,!0))return!0;for(s=0,h=this._parts.length;h>s;s++)for(e=this._parts[s],a=0,l=e.length,r=l-1;l>a;r=a++)i=e[a],n=e[r],i.y>t.y!=n.y>t.y&&t.x<(n.x-i.x)*(t.y-i.y)/(n.y-i.y)+i.x&&(u=!u);return u}}:{}),o.Circle.include(o.Path.CANVAS?{_drawPath:function(){var t=this._point;this._ctx.beginPath(),this._ctx.arc(t.x,t.y,this._radius,0,2*Math.PI,!1)},_containsPoint:function(t){var e=this._point,i=this.options.stroke?this.options.weight/2:0;return t.distanceTo(e)<=this._radius+i}}:{}),o.CircleMarker.include(o.Path.CANVAS?{_updateStyle:function(){o.Path.prototype._updateStyle.call(this)}}:{}),o.GeoJSON=o.FeatureGroup.extend({initialize:function(t,e){o.setOptions(this,e),this._layers={},t&&this.addData(t)},addData:function(t){var e,i,n,s=o.Util.isArray(t)?t:t.features;if(s){for(e=0,i=s.length;i>e;e++)n=s[e],(n.geometries||n.geometry||n.features||n.coordinates)&&this.addData(s[e]);return this}var a=this.options;if(!a.filter||a.filter(t)){var r=o.GeoJSON.geometryToLayer(t,a.pointToLayer,a.coordsToLatLng,a);return r.feature=o.GeoJSON.asFeature(t),r.defaultOptions=r.options,this.resetStyle(r),a.onEachFeature&&a.onEachFeature(t,r),this.addLayer(r)}},resetStyle:function(t){var e=this.options.style;e&&(o.Util.extend(t.options,t.defaultOptions),this._setLayerStyle(t,e))},setStyle:function(t){this.eachLayer(function(e){this._setLayerStyle(e,t)},this)},_setLayerStyle:function(t,e){"function"==typeof e&&(e=e(t.feature)),t.setStyle&&t.setStyle(e)}}),o.extend(o.GeoJSON,{geometryToLayer:function(t,e,i,n){var s,a,r,h,l="Feature"===t.type?t.geometry:t,u=l.coordinates,c=[];switch(i=i||this.coordsToLatLng,l.type){case"Point":return s=i(u),e?e(t,s):new o.Marker(s);case"MultiPoint":for(r=0,h=u.length;h>r;r++)s=i(u[r]),c.push(e?e(t,s):new o.Marker(s));return new o.FeatureGroup(c);case"LineString":return a=this.coordsToLatLngs(u,0,i),new o.Polyline(a,n);case"Polygon":if(2===u.length&&!u[1].length)throw new Error("Invalid GeoJSON object.");return a=this.coordsToLatLngs(u,1,i),new o.Polygon(a,n);case"MultiLineString":return a=this.coordsToLatLngs(u,1,i),new o.MultiPolyline(a,n);case"MultiPolygon":return a=this.coordsToLatLngs(u,2,i),new o.MultiPolygon(a,n);case"GeometryCollection":for(r=0,h=l.geometries.length;h>r;r++)c.push(this.geometryToLayer({geometry:l.geometries[r],type:"Feature",properties:t.properties},e,i,n));return new o.FeatureGroup(c);default:throw new Error("Invalid GeoJSON object.")}},coordsToLatLng:function(t){return new o.LatLng(t[1],t[0],t[2])},coordsToLatLngs:function(t,e,i){var n,o,s,a=[];for(o=0,s=t.length;s>o;o++)n=e?this.coordsToLatLngs(t[o],e-1,i):(i||this.coordsToLatLng)(t[o]),a.push(n);return a},latLngToCoords:function(t){var e=[t.lng,t.lat];return t.alt!==i&&e.push(t.alt),e},latLngsToCoords:function(t){for(var e=[],i=0,n=t.length;n>i;i++)e.push(o.GeoJSON.latLngToCoords(t[i]));return e},getFeature:function(t,e){return t.feature?o.extend({},t.feature,{geometry:e}):o.GeoJSON.asFeature(e)},asFeature:function(t){return"Feature"===t.type?t:{type:"Feature",properties:{},geometry:t}}});var a={toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"Point",coordinates:o.GeoJSON.latLngToCoords(this.getLatLng())})}};o.Marker.include(a),o.Circle.include(a),o.CircleMarker.include(a),o.Polyline.include({toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"LineString",coordinates:o.GeoJSON.latLngsToCoords(this.getLatLngs())})}}),o.Polygon.include({toGeoJSON:function(){var t,e,i,n=[o.GeoJSON.latLngsToCoords(this.getLatLngs())];if(n[0].push(n[0][0]),this._holes)for(t=0,e=this._holes.length;e>t;t++)i=o.GeoJSON.latLngsToCoords(this._holes[t]),i.push(i[0]),n.push(i);return o.GeoJSON.getFeature(this,{type:"Polygon",coordinates:n})}}),function(){function t(t){return function(){var e=[];return this.eachLayer(function(t){e.push(t.toGeoJSON().geometry.coordinates)}),o.GeoJSON.getFeature(this,{type:t,coordinates:e})}}o.MultiPolyline.include({toGeoJSON:t("MultiLineString")}),o.MultiPolygon.include({toGeoJSON:t("MultiPolygon")}),o.LayerGroup.include({toGeoJSON:function(){var e,i=this.feature&&this.feature.geometry,n=[];if(i&&"MultiPoint"===i.type)return t("MultiPoint").call(this);var s=i&&"GeometryCollection"===i.type;return this.eachLayer(function(t){t.toGeoJSON&&(e=t.toGeoJSON(),n.push(s?e.geometry:o.GeoJSON.asFeature(e)))}),s?o.GeoJSON.getFeature(this,{geometries:n,type:"GeometryCollection"}):{type:"FeatureCollection",features:n}}})}(),o.geoJson=function(t,e){return new o.GeoJSON(t,e)},o.DomEvent={addListener:function(t,e,i,n){var s,a,r,h=o.stamp(i),l="_leaflet_"+e+h;return t[l]?this:(s=function(e){return i.call(n||t,e||o.DomEvent._getEvent())},o.Browser.pointer&&0===e.indexOf("touch")?this.addPointerListener(t,e,s,h):(o.Browser.touch&&"dblclick"===e&&this.addDoubleTapListener&&this.addDoubleTapListener(t,s,h),"addEventListener"in t?"mousewheel"===e?(t.addEventListener("DOMMouseScroll",s,!1),t.addEventListener(e,s,!1)):"mouseenter"===e||"mouseleave"===e?(a=s,r="mouseenter"===e?"mouseover":"mouseout",s=function(e){return o.DomEvent._checkMouse(t,e)?a(e):void 0},t.addEventListener(r,s,!1)):"click"===e&&o.Browser.android?(a=s,s=function(t){return o.DomEvent._filterClick(t,a)},t.addEventListener(e,s,!1)):t.addEventListener(e,s,!1):"attachEvent"in t&&t.attachEvent("on"+e,s),t[l]=s,this))},removeListener:function(t,e,i){var n=o.stamp(i),s="_leaflet_"+e+n,a=t[s];return a?(o.Browser.pointer&&0===e.indexOf("touch")?this.removePointerListener(t,e,n):o.Browser.touch&&"dblclick"===e&&this.removeDoubleTapListener?this.removeDoubleTapListener(t,n):"removeEventListener"in t?"mousewheel"===e?(t.removeEventListener("DOMMouseScroll",a,!1),t.removeEventListener(e,a,!1)):"mouseenter"===e||"mouseleave"===e?t.removeEventListener("mouseenter"===e?"mouseover":"mouseout",a,!1):t.removeEventListener(e,a,!1):"detachEvent"in t&&t.detachEvent("on"+e,a),t[s]=null,this):this},stopPropagation:function(t){return t.stopPropagation?t.stopPropagation():t.cancelBubble=!0,o.DomEvent._skipped(t),this},disableScrollPropagation:function(t){var e=o.DomEvent.stopPropagation;return o.DomEvent.on(t,"mousewheel",e).on(t,"MozMousePixelScroll",e)},disableClickPropagation:function(t){for(var e=o.DomEvent.stopPropagation,i=o.Draggable.START.length-1;i>=0;i--)o.DomEvent.on(t,o.Draggable.START[i],e);return o.DomEvent.on(t,"click",o.DomEvent._fakeStop).on(t,"dblclick",e)},preventDefault:function(t){return t.preventDefault?t.preventDefault():t.returnValue=!1,this},stop:function(t){return o.DomEvent.preventDefault(t).stopPropagation(t)},getMousePosition:function(t,e){if(!e)return new o.Point(t.clientX,t.clientY);var i=e.getBoundingClientRect();return new o.Point(t.clientX-i.left-e.clientLeft,t.clientY-i.top-e.clientTop)},getWheelDelta:function(t){var e=0;return t.wheelDelta&&(e=t.wheelDelta/120),t.detail&&(e=-t.detail/3),e},_skipEvents:{},_fakeStop:function(t){o.DomEvent._skipEvents[t.type]=!0},_skipped:function(t){var e=this._skipEvents[t.type];return this._skipEvents[t.type]=!1,e},_checkMouse:function(t,e){var i=e.relatedTarget;if(!i)return!0;try{for(;i&&i!==t;)i=i.parentNode}catch(n){return!1}return i!==t},_getEvent:function(){var e=t.event;if(!e)for(var i=arguments.callee.caller;i&&(e=i.arguments[0],!e||t.Event!==e.constructor);)i=i.caller;return e},_filterClick:function(t,e){var i=t.timeStamp||t.originalEvent.timeStamp,n=o.DomEvent._lastClick&&i-o.DomEvent._lastClick;return n&&n>100&&500>n||t.target._simulatedClick&&!t._simulated?void o.DomEvent.stop(t):(o.DomEvent._lastClick=i,e(t))}},o.DomEvent.on=o.DomEvent.addListener,o.DomEvent.off=o.DomEvent.removeListener,o.Draggable=o.Class.extend({includes:o.Mixin.Events,statics:{START:o.Browser.touch?["touchstart","mousedown"]:["mousedown"],END:{mousedown:"mouseup",touchstart:"touchend",pointerdown:"touchend",MSPointerDown:"touchend"},MOVE:{mousedown:"mousemove",touchstart:"touchmove",pointerdown:"touchmove",MSPointerDown:"touchmove"}},initialize:function(t,e){this._element=t,this._dragStartTarget=e||t},enable:function(){if(!this._enabled){for(var t=o.Draggable.START.length-1;t>=0;t--)o.DomEvent.on(this._dragStartTarget,o.Draggable.START[t],this._onDown,this);this._enabled=!0}},disable:function(){if(this._enabled){for(var t=o.Draggable.START.length-1;t>=0;t--)o.DomEvent.off(this._dragStartTarget,o.Draggable.START[t],this._onDown,this);this._enabled=!1,this._moved=!1}},_onDown:function(t){if(this._moved=!1,!t.shiftKey&&(1===t.which||1===t.button||t.touches)&&(o.DomEvent.stopPropagation(t),!o.Draggable._disabled&&(o.DomUtil.disableImageDrag(),o.DomUtil.disableTextSelection(),!this._moving))){var i=t.touches?t.touches[0]:t;this._startPoint=new o.Point(i.clientX,i.clientY),this._startPos=this._newPos=o.DomUtil.getPosition(this._element),o.DomEvent.on(e,o.Draggable.MOVE[t.type],this._onMove,this).on(e,o.Draggable.END[t.type],this._onUp,this)}},_onMove:function(t){if(t.touches&&t.touches.length>1)return void(this._moved=!0);var i=t.touches&&1===t.touches.length?t.touches[0]:t,n=new o.Point(i.clientX,i.clientY),s=n.subtract(this._startPoint);(s.x||s.y)&&(o.Browser.touch&&Math.abs(s.x)+Math.abs(s.y)<3||(o.DomEvent.preventDefault(t),this._moved||(this.fire("dragstart"),this._moved=!0,this._startPos=o.DomUtil.getPosition(this._element).subtract(s),o.DomUtil.addClass(e.body,"leaflet-dragging"),this._lastTarget=t.target||t.srcElement,o.DomUtil.addClass(this._lastTarget,"leaflet-drag-target")),this._newPos=this._startPos.add(s),this._moving=!0,o.Util.cancelAnimFrame(this._animRequest),this._animRequest=o.Util.requestAnimFrame(this._updatePosition,this,!0,this._dragStartTarget)))},_updatePosition:function(){this.fire("predrag"),o.DomUtil.setPosition(this._element,this._newPos),this.fire("drag")},_onUp:function(){o.DomUtil.removeClass(e.body,"leaflet-dragging"),this._lastTarget&&(o.DomUtil.removeClass(this._lastTarget,"leaflet-drag-target"),this._lastTarget=null);for(var t in o.Draggable.MOVE)o.DomEvent.off(e,o.Draggable.MOVE[t],this._onMove).off(e,o.Draggable.END[t],this._onUp);o.DomUtil.enableImageDrag(),o.DomUtil.enableTextSelection(),this._moved&&this._moving&&(o.Util.cancelAnimFrame(this._animRequest),this.fire("dragend",{distance:this._newPos.distanceTo(this._startPos)})),this._moving=!1}}),o.Handler=o.Class.extend({initialize:function(t){this._map=t},enable:function(){this._enabled||(this._enabled=!0,this.addHooks())},disable:function(){this._enabled&&(this._enabled=!1,this.removeHooks())},enabled:function(){return!!this._enabled}}),o.Map.mergeOptions({dragging:!0,inertia:!o.Browser.android23,inertiaDeceleration:3400,inertiaMaxSpeed:1/0,inertiaThreshold:o.Browser.touch?32:18,easeLinearity:.25,worldCopyJump:!1}),o.Map.Drag=o.Handler.extend({addHooks:function(){if(!this._draggable){var t=this._map;this._draggable=new o.Draggable(t._mapPane,t._container),this._draggable.on({dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this),t.options.worldCopyJump&&(this._draggable.on("predrag",this._onPreDrag,this),t.on("viewreset",this._onViewReset,this),t.whenReady(this._onViewReset,this))}this._draggable.enable()},removeHooks:function(){this._draggable.disable()},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){var t=this._map;t._panAnim&&t._panAnim.stop(),t.fire("movestart").fire("dragstart"),t.options.inertia&&(this._positions=[],this._times=[])},_onDrag:function(){if(this._map.options.inertia){var t=this._lastTime=+new Date,e=this._lastPos=this._draggable._newPos;this._positions.push(e),this._times.push(t),t-this._times[0]>200&&(this._positions.shift(),this._times.shift())}this._map.fire("move").fire("drag")},_onViewReset:function(){var t=this._map.getSize()._divideBy(2),e=this._map.latLngToLayerPoint([0,0]);this._initialWorldOffset=e.subtract(t).x,this._worldWidth=this._map.project([0,180]).x},_onPreDrag:function(){var t=this._worldWidth,e=Math.round(t/2),i=this._initialWorldOffset,n=this._draggable._newPos.x,o=(n-e+i)%t+e-i,s=(n+e+i)%t-e-i,a=Math.abs(o+i)<Math.abs(s+i)?o:s;this._draggable._newPos.x=a},_onDragEnd:function(t){var e=this._map,i=e.options,n=+new Date-this._lastTime,s=!i.inertia||n>i.inertiaThreshold||!this._positions[0];if(e.fire("dragend",t),s)e.fire("moveend");else{var a=this._lastPos.subtract(this._positions[0]),r=(this._lastTime+n-this._times[0])/1e3,h=i.easeLinearity,l=a.multiplyBy(h/r),u=l.distanceTo([0,0]),c=Math.min(i.inertiaMaxSpeed,u),d=l.multiplyBy(c/u),p=c/(i.inertiaDeceleration*h),_=d.multiplyBy(-p/2).round();_.x&&_.y?(_=e._limitOffset(_,e.options.maxBounds),o.Util.requestAnimFrame(function(){e.panBy(_,{duration:p,easeLinearity:h,noMoveStart:!0})})):e.fire("moveend")}}}),o.Map.addInitHook("addHandler","dragging",o.Map.Drag),o.Map.mergeOptions({doubleClickZoom:!0}),o.Map.DoubleClickZoom=o.Handler.extend({addHooks:function(){this._map.on("dblclick",this._onDoubleClick,this)},removeHooks:function(){this._map.off("dblclick",this._onDoubleClick,this)},_onDoubleClick:function(t){var e=this._map,i=e.getZoom()+(t.originalEvent.shiftKey?-1:1);"center"===e.options.doubleClickZoom?e.setZoom(i):e.setZoomAround(t.containerPoint,i)}}),o.Map.addInitHook("addHandler","doubleClickZoom",o.Map.DoubleClickZoom),o.Map.mergeOptions({scrollWheelZoom:!0}),o.Map.ScrollWheelZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"mousewheel",this._onWheelScroll,this),o.DomEvent.on(this._map._container,"MozMousePixelScroll",o.DomEvent.preventDefault),this._delta=0},removeHooks:function(){o.DomEvent.off(this._map._container,"mousewheel",this._onWheelScroll),o.DomEvent.off(this._map._container,"MozMousePixelScroll",o.DomEvent.preventDefault)},_onWheelScroll:function(t){var e=o.DomEvent.getWheelDelta(t);this._delta+=e,this._lastMousePos=this._map.mouseEventToContainerPoint(t),this._startTime||(this._startTime=+new Date);var i=Math.max(40-(+new Date-this._startTime),0);clearTimeout(this._timer),this._timer=setTimeout(o.bind(this._performZoom,this),i),o.DomEvent.preventDefault(t),o.DomEvent.stopPropagation(t)},_performZoom:function(){var t=this._map,e=this._delta,i=t.getZoom();e=e>0?Math.ceil(e):Math.floor(e),e=Math.max(Math.min(e,4),-4),e=t._limitZoom(i+e)-i,this._delta=0,this._startTime=null,e&&("center"===t.options.scrollWheelZoom?t.setZoom(i+e):t.setZoomAround(this._lastMousePos,i+e))}}),o.Map.addInitHook("addHandler","scrollWheelZoom",o.Map.ScrollWheelZoom),o.extend(o.DomEvent,{_touchstart:o.Browser.msPointer?"MSPointerDown":o.Browser.pointer?"pointerdown":"touchstart",_touchend:o.Browser.msPointer?"MSPointerUp":o.Browser.pointer?"pointerup":"touchend",addDoubleTapListener:function(t,i,n){function s(t){var e;if(o.Browser.pointer?(_.push(t.pointerId),e=_.length):e=t.touches.length,!(e>1)){var i=Date.now(),n=i-(r||i);h=t.touches?t.touches[0]:t,l=n>0&&u>=n,r=i}}function a(t){if(o.Browser.pointer){var e=_.indexOf(t.pointerId);if(-1===e)return;_.splice(e,1)}if(l){if(o.Browser.pointer){var n,s={};for(var a in h)n=h[a],"function"==typeof n?s[a]=n.bind(h):s[a]=n;h=s}h.type="dblclick",i(h),r=null}}var r,h,l=!1,u=250,c="_leaflet_",d=this._touchstart,p=this._touchend,_=[];t[c+d+n]=s,t[c+p+n]=a;var m=o.Browser.pointer?e.documentElement:t;return t.addEventListener(d,s,!1),m.addEventListener(p,a,!1),o.Browser.pointer&&m.addEventListener(o.DomEvent.POINTER_CANCEL,a,!1),this},removeDoubleTapListener:function(t,i){var n="_leaflet_";return t.removeEventListener(this._touchstart,t[n+this._touchstart+i],!1),(o.Browser.pointer?e.documentElement:t).removeEventListener(this._touchend,t[n+this._touchend+i],!1),o.Browser.pointer&&e.documentElement.removeEventListener(o.DomEvent.POINTER_CANCEL,t[n+this._touchend+i],!1),this}}),o.extend(o.DomEvent,{POINTER_DOWN:o.Browser.msPointer?"MSPointerDown":"pointerdown",POINTER_MOVE:o.Browser.msPointer?"MSPointerMove":"pointermove",POINTER_UP:o.Browser.msPointer?"MSPointerUp":"pointerup",POINTER_CANCEL:o.Browser.msPointer?"MSPointerCancel":"pointercancel",_pointers:[],_pointerDocumentListener:!1,addPointerListener:function(t,e,i,n){switch(e){case"touchstart":return this.addPointerListenerStart(t,e,i,n);
   case"touchend":return this.addPointerListenerEnd(t,e,i,n);case"touchmove":return this.addPointerListenerMove(t,e,i,n);default:throw"Unknown touch event type"}},addPointerListenerStart:function(t,i,n,s){var a="_leaflet_",r=this._pointers,h=function(t){"mouse"!==t.pointerType&&t.pointerType!==t.MSPOINTER_TYPE_MOUSE&&o.DomEvent.preventDefault(t);for(var e=!1,i=0;i<r.length;i++)if(r[i].pointerId===t.pointerId){e=!0;break}e||r.push(t),t.touches=r.slice(),t.changedTouches=[t],n(t)};if(t[a+"touchstart"+s]=h,t.addEventListener(this.POINTER_DOWN,h,!1),!this._pointerDocumentListener){var l=function(t){for(var e=0;e<r.length;e++)if(r[e].pointerId===t.pointerId){r.splice(e,1);break}};e.documentElement.addEventListener(this.POINTER_UP,l,!1),e.documentElement.addEventListener(this.POINTER_CANCEL,l,!1),this._pointerDocumentListener=!0}return this},addPointerListenerMove:function(t,e,i,n){function o(t){if(t.pointerType!==t.MSPOINTER_TYPE_MOUSE&&"mouse"!==t.pointerType||0!==t.buttons){for(var e=0;e<a.length;e++)if(a[e].pointerId===t.pointerId){a[e]=t;break}t.touches=a.slice(),t.changedTouches=[t],i(t)}}var s="_leaflet_",a=this._pointers;return t[s+"touchmove"+n]=o,t.addEventListener(this.POINTER_MOVE,o,!1),this},addPointerListenerEnd:function(t,e,i,n){var o="_leaflet_",s=this._pointers,a=function(t){for(var e=0;e<s.length;e++)if(s[e].pointerId===t.pointerId){s.splice(e,1);break}t.touches=s.slice(),t.changedTouches=[t],i(t)};return t[o+"touchend"+n]=a,t.addEventListener(this.POINTER_UP,a,!1),t.addEventListener(this.POINTER_CANCEL,a,!1),this},removePointerListener:function(t,e,i){var n="_leaflet_",o=t[n+e+i];switch(e){case"touchstart":t.removeEventListener(this.POINTER_DOWN,o,!1);break;case"touchmove":t.removeEventListener(this.POINTER_MOVE,o,!1);break;case"touchend":t.removeEventListener(this.POINTER_UP,o,!1),t.removeEventListener(this.POINTER_CANCEL,o,!1)}return this}}),o.Map.mergeOptions({touchZoom:o.Browser.touch&&!o.Browser.android23,bounceAtZoomLimits:!0}),o.Map.TouchZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onTouchStart,this)},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onTouchStart,this)},_onTouchStart:function(t){var i=this._map;if(t.touches&&2===t.touches.length&&!i._animatingZoom&&!this._zooming){var n=i.mouseEventToLayerPoint(t.touches[0]),s=i.mouseEventToLayerPoint(t.touches[1]),a=i._getCenterLayerPoint();this._startCenter=n.add(s)._divideBy(2),this._startDist=n.distanceTo(s),this._moved=!1,this._zooming=!0,this._centerOffset=a.subtract(this._startCenter),i._panAnim&&i._panAnim.stop(),o.DomEvent.on(e,"touchmove",this._onTouchMove,this).on(e,"touchend",this._onTouchEnd,this),o.DomEvent.preventDefault(t)}},_onTouchMove:function(t){var e=this._map;if(t.touches&&2===t.touches.length&&this._zooming){var i=e.mouseEventToLayerPoint(t.touches[0]),n=e.mouseEventToLayerPoint(t.touches[1]);this._scale=i.distanceTo(n)/this._startDist,this._delta=i._add(n)._divideBy(2)._subtract(this._startCenter),1!==this._scale&&(e.options.bounceAtZoomLimits||!(e.getZoom()===e.getMinZoom()&&this._scale<1||e.getZoom()===e.getMaxZoom()&&this._scale>1))&&(this._moved||(o.DomUtil.addClass(e._mapPane,"leaflet-touching"),e.fire("movestart").fire("zoomstart"),this._moved=!0),o.Util.cancelAnimFrame(this._animRequest),this._animRequest=o.Util.requestAnimFrame(this._updateOnMove,this,!0,this._map._container),o.DomEvent.preventDefault(t))}},_updateOnMove:function(){var t=this._map,e=this._getScaleOrigin(),i=t.layerPointToLatLng(e),n=t.getScaleZoom(this._scale);t._animateZoom(i,n,this._startCenter,this._scale,this._delta,!1,!0)},_onTouchEnd:function(){if(!this._moved||!this._zooming)return void(this._zooming=!1);var t=this._map;this._zooming=!1,o.DomUtil.removeClass(t._mapPane,"leaflet-touching"),o.Util.cancelAnimFrame(this._animRequest),o.DomEvent.off(e,"touchmove",this._onTouchMove).off(e,"touchend",this._onTouchEnd);var i=this._getScaleOrigin(),n=t.layerPointToLatLng(i),s=t.getZoom(),a=t.getScaleZoom(this._scale)-s,r=a>0?Math.ceil(a):Math.floor(a),h=t._limitZoom(s+r),l=t.getZoomScale(h)/this._scale;t._animateZoom(n,h,i,l)},_getScaleOrigin:function(){var t=this._centerOffset.subtract(this._delta).divideBy(this._scale);return this._startCenter.add(t)}}),o.Map.addInitHook("addHandler","touchZoom",o.Map.TouchZoom),o.Map.mergeOptions({tap:!0,tapTolerance:15}),o.Map.Tap=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onDown,this)},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onDown,this)},_onDown:function(t){if(t.touches){if(o.DomEvent.preventDefault(t),this._fireClick=!0,t.touches.length>1)return this._fireClick=!1,void clearTimeout(this._holdTimeout);var i=t.touches[0],n=i.target;this._startPos=this._newPos=new o.Point(i.clientX,i.clientY),n.tagName&&"a"===n.tagName.toLowerCase()&&o.DomUtil.addClass(n,"leaflet-active"),this._holdTimeout=setTimeout(o.bind(function(){this._isTapValid()&&(this._fireClick=!1,this._onUp(),this._simulateEvent("contextmenu",i))},this),1e3),o.DomEvent.on(e,"touchmove",this._onMove,this).on(e,"touchend",this._onUp,this)}},_onUp:function(t){if(clearTimeout(this._holdTimeout),o.DomEvent.off(e,"touchmove",this._onMove,this).off(e,"touchend",this._onUp,this),this._fireClick&&t&&t.changedTouches){var i=t.changedTouches[0],n=i.target;n&&n.tagName&&"a"===n.tagName.toLowerCase()&&o.DomUtil.removeClass(n,"leaflet-active"),this._isTapValid()&&this._simulateEvent("click",i)}},_isTapValid:function(){return this._newPos.distanceTo(this._startPos)<=this._map.options.tapTolerance},_onMove:function(t){var e=t.touches[0];this._newPos=new o.Point(e.clientX,e.clientY)},_simulateEvent:function(i,n){var o=e.createEvent("MouseEvents");o._simulated=!0,n.target._simulatedClick=!0,o.initMouseEvent(i,!0,!0,t,1,n.screenX,n.screenY,n.clientX,n.clientY,!1,!1,!1,!1,0,null),n.target.dispatchEvent(o)}}),o.Browser.touch&&!o.Browser.pointer&&o.Map.addInitHook("addHandler","tap",o.Map.Tap),o.Map.mergeOptions({boxZoom:!0}),o.Map.BoxZoom=o.Handler.extend({initialize:function(t){this._map=t,this._container=t._container,this._pane=t._panes.overlayPane,this._moved=!1},addHooks:function(){o.DomEvent.on(this._container,"mousedown",this._onMouseDown,this)},removeHooks:function(){o.DomEvent.off(this._container,"mousedown",this._onMouseDown),this._moved=!1},moved:function(){return this._moved},_onMouseDown:function(t){return this._moved=!1,!t.shiftKey||1!==t.which&&1!==t.button?!1:(o.DomUtil.disableTextSelection(),o.DomUtil.disableImageDrag(),this._startLayerPoint=this._map.mouseEventToLayerPoint(t),void o.DomEvent.on(e,"mousemove",this._onMouseMove,this).on(e,"mouseup",this._onMouseUp,this).on(e,"keydown",this._onKeyDown,this))},_onMouseMove:function(t){this._moved||(this._box=o.DomUtil.create("div","leaflet-zoom-box",this._pane),o.DomUtil.setPosition(this._box,this._startLayerPoint),this._container.style.cursor="crosshair",this._map.fire("boxzoomstart"));var e=this._startLayerPoint,i=this._box,n=this._map.mouseEventToLayerPoint(t),s=n.subtract(e),a=new o.Point(Math.min(n.x,e.x),Math.min(n.y,e.y));o.DomUtil.setPosition(i,a),this._moved=!0,i.style.width=Math.max(0,Math.abs(s.x)-4)+"px",i.style.height=Math.max(0,Math.abs(s.y)-4)+"px"},_finish:function(){this._moved&&(this._pane.removeChild(this._box),this._container.style.cursor=""),o.DomUtil.enableTextSelection(),o.DomUtil.enableImageDrag(),o.DomEvent.off(e,"mousemove",this._onMouseMove).off(e,"mouseup",this._onMouseUp).off(e,"keydown",this._onKeyDown)},_onMouseUp:function(t){this._finish();var e=this._map,i=e.mouseEventToLayerPoint(t);if(!this._startLayerPoint.equals(i)){var n=new o.LatLngBounds(e.layerPointToLatLng(this._startLayerPoint),e.layerPointToLatLng(i));e.fitBounds(n),e.fire("boxzoomend",{boxZoomBounds:n})}},_onKeyDown:function(t){27===t.keyCode&&this._finish()}}),o.Map.addInitHook("addHandler","boxZoom",o.Map.BoxZoom),o.Map.mergeOptions({keyboard:!0,keyboardPanOffset:80,keyboardZoomOffset:1}),o.Map.Keyboard=o.Handler.extend({keyCodes:{left:[37],right:[39],down:[40],up:[38],zoomIn:[187,107,61,171],zoomOut:[189,109,173]},initialize:function(t){this._map=t,this._setPanOffset(t.options.keyboardPanOffset),this._setZoomOffset(t.options.keyboardZoomOffset)},addHooks:function(){var t=this._map._container;-1===t.tabIndex&&(t.tabIndex="0"),o.DomEvent.on(t,"focus",this._onFocus,this).on(t,"blur",this._onBlur,this).on(t,"mousedown",this._onMouseDown,this),this._map.on("focus",this._addHooks,this).on("blur",this._removeHooks,this)},removeHooks:function(){this._removeHooks();var t=this._map._container;o.DomEvent.off(t,"focus",this._onFocus,this).off(t,"blur",this._onBlur,this).off(t,"mousedown",this._onMouseDown,this),this._map.off("focus",this._addHooks,this).off("blur",this._removeHooks,this)},_onMouseDown:function(){if(!this._focused){var i=e.body,n=e.documentElement,o=i.scrollTop||n.scrollTop,s=i.scrollLeft||n.scrollLeft;this._map._container.focus(),t.scrollTo(s,o)}},_onFocus:function(){this._focused=!0,this._map.fire("focus")},_onBlur:function(){this._focused=!1,this._map.fire("blur")},_setPanOffset:function(t){var e,i,n=this._panKeys={},o=this.keyCodes;for(e=0,i=o.left.length;i>e;e++)n[o.left[e]]=[-1*t,0];for(e=0,i=o.right.length;i>e;e++)n[o.right[e]]=[t,0];for(e=0,i=o.down.length;i>e;e++)n[o.down[e]]=[0,t];for(e=0,i=o.up.length;i>e;e++)n[o.up[e]]=[0,-1*t]},_setZoomOffset:function(t){var e,i,n=this._zoomKeys={},o=this.keyCodes;for(e=0,i=o.zoomIn.length;i>e;e++)n[o.zoomIn[e]]=t;for(e=0,i=o.zoomOut.length;i>e;e++)n[o.zoomOut[e]]=-t},_addHooks:function(){o.DomEvent.on(e,"keydown",this._onKeyDown,this)},_removeHooks:function(){o.DomEvent.off(e,"keydown",this._onKeyDown,this)},_onKeyDown:function(t){var e=t.keyCode,i=this._map;if(e in this._panKeys){if(i._panAnim&&i._panAnim._inProgress)return;i.panBy(this._panKeys[e]),i.options.maxBounds&&i.panInsideBounds(i.options.maxBounds)}else{if(!(e in this._zoomKeys))return;i.setZoom(i.getZoom()+this._zoomKeys[e])}o.DomEvent.stop(t)}}),o.Map.addInitHook("addHandler","keyboard",o.Map.Keyboard),o.Handler.MarkerDrag=o.Handler.extend({initialize:function(t){this._marker=t},addHooks:function(){var t=this._marker._icon;this._draggable||(this._draggable=new o.Draggable(t,t)),this._draggable.on("dragstart",this._onDragStart,this).on("drag",this._onDrag,this).on("dragend",this._onDragEnd,this),this._draggable.enable(),o.DomUtil.addClass(this._marker._icon,"leaflet-marker-draggable")},removeHooks:function(){this._draggable.off("dragstart",this._onDragStart,this).off("drag",this._onDrag,this).off("dragend",this._onDragEnd,this),this._draggable.disable(),o.DomUtil.removeClass(this._marker._icon,"leaflet-marker-draggable")},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){this._marker.closePopup().fire("movestart").fire("dragstart")},_onDrag:function(){var t=this._marker,e=t._shadow,i=o.DomUtil.getPosition(t._icon),n=t._map.layerPointToLatLng(i);e&&o.DomUtil.setPosition(e,i),t._latlng=n,t.fire("move",{latlng:n}).fire("drag")},_onDragEnd:function(t){this._marker.fire("moveend").fire("dragend",t)}}),o.Control=o.Class.extend({options:{position:"topright"},initialize:function(t){o.setOptions(this,t)},getPosition:function(){return this.options.position},setPosition:function(t){var e=this._map;return e&&e.removeControl(this),this.options.position=t,e&&e.addControl(this),this},getContainer:function(){return this._container},addTo:function(t){this._map=t;var e=this._container=this.onAdd(t),i=this.getPosition(),n=t._controlCorners[i];return o.DomUtil.addClass(e,"leaflet-control"),-1!==i.indexOf("bottom")?n.insertBefore(e,n.firstChild):n.appendChild(e),this},removeFrom:function(t){var e=this.getPosition(),i=t._controlCorners[e];return i.removeChild(this._container),this._map=null,this.onRemove&&this.onRemove(t),this},_refocusOnMap:function(){this._map&&this._map.getContainer().focus()}}),o.control=function(t){return new o.Control(t)},o.Map.include({addControl:function(t){return t.addTo(this),this},removeControl:function(t){return t.removeFrom(this),this},_initControlPos:function(){function t(t,s){var a=i+t+" "+i+s;e[t+s]=o.DomUtil.create("div",a,n)}var e=this._controlCorners={},i="leaflet-",n=this._controlContainer=o.DomUtil.create("div",i+"control-container",this._container);t("top","left"),t("top","right"),t("bottom","left"),t("bottom","right")},_clearControlPos:function(){this._container.removeChild(this._controlContainer)}}),o.Control.Zoom=o.Control.extend({options:{position:"topleft",zoomInText:"+",zoomInTitle:"Zoom in",zoomOutText:"-",zoomOutTitle:"Zoom out"},onAdd:function(t){var e="leaflet-control-zoom",i=o.DomUtil.create("div",e+" leaflet-bar");return this._map=t,this._zoomInButton=this._createButton(this.options.zoomInText,this.options.zoomInTitle,e+"-in",i,this._zoomIn,this),this._zoomOutButton=this._createButton(this.options.zoomOutText,this.options.zoomOutTitle,e+"-out",i,this._zoomOut,this),this._updateDisabled(),t.on("zoomend zoomlevelschange",this._updateDisabled,this),i},onRemove:function(t){t.off("zoomend zoomlevelschange",this._updateDisabled,this)},_zoomIn:function(t){this._map.zoomIn(t.shiftKey?3:1)},_zoomOut:function(t){this._map.zoomOut(t.shiftKey?3:1)},_createButton:function(t,e,i,n,s,a){var r=o.DomUtil.create("a",i,n);r.innerHTML=t,r.href="#",r.title=e;var h=o.DomEvent.stopPropagation;return o.DomEvent.on(r,"click",h).on(r,"mousedown",h).on(r,"dblclick",h).on(r,"click",o.DomEvent.preventDefault).on(r,"click",s,a).on(r,"click",this._refocusOnMap,a),r},_updateDisabled:function(){var t=this._map,e="leaflet-disabled";o.DomUtil.removeClass(this._zoomInButton,e),o.DomUtil.removeClass(this._zoomOutButton,e),t._zoom===t.getMinZoom()&&o.DomUtil.addClass(this._zoomOutButton,e),t._zoom===t.getMaxZoom()&&o.DomUtil.addClass(this._zoomInButton,e)}}),o.Map.mergeOptions({zoomControl:!0}),o.Map.addInitHook(function(){this.options.zoomControl&&(this.zoomControl=new o.Control.Zoom,this.addControl(this.zoomControl))}),o.control.zoom=function(t){return new o.Control.Zoom(t)},o.Control.Attribution=o.Control.extend({options:{position:"bottomright",prefix:'<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'},initialize:function(t){o.setOptions(this,t),this._attributions={}},onAdd:function(t){this._container=o.DomUtil.create("div","leaflet-control-attribution"),o.DomEvent.disableClickPropagation(this._container);for(var e in t._layers)t._layers[e].getAttribution&&this.addAttribution(t._layers[e].getAttribution());return t.on("layeradd",this._onLayerAdd,this).on("layerremove",this._onLayerRemove,this),this._update(),this._container},onRemove:function(t){t.off("layeradd",this._onLayerAdd).off("layerremove",this._onLayerRemove)},setPrefix:function(t){return this.options.prefix=t,this._update(),this},addAttribution:function(t){return t?(this._attributions[t]||(this._attributions[t]=0),this._attributions[t]++,this._update(),this):void 0},removeAttribution:function(t){return t?(this._attributions[t]&&(this._attributions[t]--,this._update()),this):void 0},_update:function(){if(this._map){var t=[];for(var e in this._attributions)this._attributions[e]&&t.push(e);var i=[];this.options.prefix&&i.push(this.options.prefix),t.length&&i.push(t.join(", ")),this._container.innerHTML=i.join(" | ")}},_onLayerAdd:function(t){t.layer.getAttribution&&this.addAttribution(t.layer.getAttribution())},_onLayerRemove:function(t){t.layer.getAttribution&&this.removeAttribution(t.layer.getAttribution())}}),o.Map.mergeOptions({attributionControl:!0}),o.Map.addInitHook(function(){this.options.attributionControl&&(this.attributionControl=(new o.Control.Attribution).addTo(this))}),o.control.attribution=function(t){return new o.Control.Attribution(t)},o.Control.Scale=o.Control.extend({options:{position:"bottomleft",maxWidth:100,metric:!0,imperial:!0,updateWhenIdle:!1},onAdd:function(t){this._map=t;var e="leaflet-control-scale",i=o.DomUtil.create("div",e),n=this.options;return this._addScales(n,e,i),t.on(n.updateWhenIdle?"moveend":"move",this._update,this),t.whenReady(this._update,this),i},onRemove:function(t){t.off(this.options.updateWhenIdle?"moveend":"move",this._update,this)},_addScales:function(t,e,i){t.metric&&(this._mScale=o.DomUtil.create("div",e+"-line",i)),t.imperial&&(this._iScale=o.DomUtil.create("div",e+"-line",i))},_update:function(){var t=this._map.getBounds(),e=t.getCenter().lat,i=6378137*Math.PI*Math.cos(e*Math.PI/180),n=i*(t.getNorthEast().lng-t.getSouthWest().lng)/180,o=this._map.getSize(),s=this.options,a=0;o.x>0&&(a=n*(s.maxWidth/o.x)),this._updateScales(s,a)},_updateScales:function(t,e){t.metric&&e&&this._updateMetric(e),t.imperial&&e&&this._updateImperial(e)},_updateMetric:function(t){var e=this._getRoundNum(t);this._mScale.style.width=this._getScaleWidth(e/t)+"px",this._mScale.innerHTML=1e3>e?e+" m":e/1e3+" km"},_updateImperial:function(t){var e,i,n,o=3.2808399*t,s=this._iScale;o>5280?(e=o/5280,i=this._getRoundNum(e),s.style.width=this._getScaleWidth(i/e)+"px",s.innerHTML=i+" mi"):(n=this._getRoundNum(o),s.style.width=this._getScaleWidth(n/o)+"px",s.innerHTML=n+" ft")},_getScaleWidth:function(t){return Math.round(this.options.maxWidth*t)-10},_getRoundNum:function(t){var e=Math.pow(10,(Math.floor(t)+"").length-1),i=t/e;return i=i>=10?10:i>=5?5:i>=3?3:i>=2?2:1,e*i}}),o.control.scale=function(t){return new o.Control.Scale(t)},o.Control.Layers=o.Control.extend({options:{collapsed:!0,position:"topright",autoZIndex:!0},initialize:function(t,e,i){o.setOptions(this,i),this._layers={},this._lastZIndex=0,this._handlingClick=!1;for(var n in t)this._addLayer(t[n],n);for(n in e)this._addLayer(e[n],n,!0)},onAdd:function(t){return this._initLayout(),this._update(),t.on("layeradd",this._onLayerChange,this).on("layerremove",this._onLayerChange,this),this._container},onRemove:function(t){t.off("layeradd",this._onLayerChange,this).off("layerremove",this._onLayerChange,this)},addBaseLayer:function(t,e){return this._addLayer(t,e),this._update(),this},addOverlay:function(t,e){return this._addLayer(t,e,!0),this._update(),this},removeLayer:function(t){var e=o.stamp(t);return delete this._layers[e],this._update(),this},_initLayout:function(){var t="leaflet-control-layers",e=this._container=o.DomUtil.create("div",t);e.setAttribute("aria-haspopup",!0),o.Browser.touch?o.DomEvent.on(e,"click",o.DomEvent.stopPropagation):o.DomEvent.disableClickPropagation(e).disableScrollPropagation(e);var i=this._form=o.DomUtil.create("form",t+"-list");if(this.options.collapsed){o.Browser.android||o.DomEvent.on(e,"mouseover",this._expand,this).on(e,"mouseout",this._collapse,this);var n=this._layersLink=o.DomUtil.create("a",t+"-toggle",e);n.href="#",n.title="Layers",o.Browser.touch?o.DomEvent.on(n,"click",o.DomEvent.stop).on(n,"click",this._expand,this):o.DomEvent.on(n,"focus",this._expand,this),o.DomEvent.on(i,"click",function(){setTimeout(o.bind(this._onInputClick,this),0)},this),this._map.on("click",this._collapse,this)}else this._expand();this._baseLayersList=o.DomUtil.create("div",t+"-base",i),this._separator=o.DomUtil.create("div",t+"-separator",i),this._overlaysList=o.DomUtil.create("div",t+"-overlays",i),e.appendChild(i)},_addLayer:function(t,e,i){var n=o.stamp(t);this._layers[n]={layer:t,name:e,overlay:i},this.options.autoZIndex&&t.setZIndex&&(this._lastZIndex++,t.setZIndex(this._lastZIndex))},_update:function(){if(this._container){this._baseLayersList.innerHTML="",this._overlaysList.innerHTML="";var t,e,i=!1,n=!1;for(t in this._layers)e=this._layers[t],this._addItem(e),n=n||e.overlay,i=i||!e.overlay;this._separator.style.display=n&&i?"":"none"}},_onLayerChange:function(t){var e=this._layers[o.stamp(t.layer)];if(e){this._handlingClick||this._update();var i=e.overlay?"layeradd"===t.type?"overlayadd":"overlayremove":"layeradd"===t.type?"baselayerchange":null;i&&this._map.fire(i,e)}},_createRadioElement:function(t,i){var n='<input type="radio" class="leaflet-control-layers-selector" name="'+t+'"';i&&(n+=' checked="checked"'),n+="/>";var o=e.createElement("div");return o.innerHTML=n,o.firstChild},_addItem:function(t){var i,n=e.createElement("label"),s=this._map.hasLayer(t.layer);t.overlay?(i=e.createElement("input"),i.type="checkbox",i.className="leaflet-control-layers-selector",i.defaultChecked=s):i=this._createRadioElement("leaflet-base-layers",s),i.layerId=o.stamp(t.layer),o.DomEvent.on(i,"click",this._onInputClick,this);var a=e.createElement("span");a.innerHTML=" "+t.name,n.appendChild(i),n.appendChild(a);var r=t.overlay?this._overlaysList:this._baseLayersList;return r.appendChild(n),n},_onInputClick:function(){var t,e,i,n=this._form.getElementsByTagName("input"),o=n.length;for(this._handlingClick=!0,t=0;o>t;t++)e=n[t],i=this._layers[e.layerId],e.checked&&!this._map.hasLayer(i.layer)?this._map.addLayer(i.layer):!e.checked&&this._map.hasLayer(i.layer)&&this._map.removeLayer(i.layer);this._handlingClick=!1,this._refocusOnMap()},_expand:function(){o.DomUtil.addClass(this._container,"leaflet-control-layers-expanded")},_collapse:function(){this._container.className=this._container.className.replace(" leaflet-control-layers-expanded","")}}),o.control.layers=function(t,e,i){return new o.Control.Layers(t,e,i)},o.PosAnimation=o.Class.extend({includes:o.Mixin.Events,run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._newPos=e,this.fire("start"),t.style[o.DomUtil.TRANSITION]="all "+(i||.25)+"s cubic-bezier(0,0,"+(n||.5)+",1)",o.DomEvent.on(t,o.DomUtil.TRANSITION_END,this._onTransitionEnd,this),o.DomUtil.setPosition(t,e),o.Util.falseFn(t.offsetWidth),this._stepTimer=setInterval(o.bind(this._onStep,this),50)},stop:function(){this._inProgress&&(o.DomUtil.setPosition(this._el,this._getPos()),this._onTransitionEnd(),o.Util.falseFn(this._el.offsetWidth))},_onStep:function(){var t=this._getPos();return t?(this._el._leaflet_pos=t,void this.fire("step")):void this._onTransitionEnd()},_transformRe:/([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,_getPos:function(){var e,i,n,s=this._el,a=t.getComputedStyle(s);if(o.Browser.any3d){if(n=a[o.DomUtil.TRANSFORM].match(this._transformRe),!n)return;e=parseFloat(n[1]),i=parseFloat(n[2])}else e=parseFloat(a.left),i=parseFloat(a.top);return new o.Point(e,i,!0)},_onTransitionEnd:function(){o.DomEvent.off(this._el,o.DomUtil.TRANSITION_END,this._onTransitionEnd,this),this._inProgress&&(this._inProgress=!1,this._el.style[o.DomUtil.TRANSITION]="",this._el._leaflet_pos=this._newPos,clearInterval(this._stepTimer),this.fire("step").fire("end"))}}),o.Map.include({setView:function(t,e,n){if(e=e===i?this._zoom:this._limitZoom(e),t=this._limitCenter(o.latLng(t),e,this.options.maxBounds),n=n||{},this._panAnim&&this._panAnim.stop(),this._loaded&&!n.reset&&n!==!0){n.animate!==i&&(n.zoom=o.extend({animate:n.animate},n.zoom),n.pan=o.extend({animate:n.animate},n.pan));var s=this._zoom!==e?this._tryAnimatedZoom&&this._tryAnimatedZoom(t,e,n.zoom):this._tryAnimatedPan(t,n.pan);if(s)return clearTimeout(this._sizeTimer),this}return this._resetView(t,e),this},panBy:function(t,e){if(t=o.point(t).round(),e=e||{},!t.x&&!t.y)return this;if(this._panAnim||(this._panAnim=new o.PosAnimation,this._panAnim.on({step:this._onPanTransitionStep,end:this._onPanTransitionEnd},this)),e.noMoveStart||this.fire("movestart"),e.animate!==!1){o.DomUtil.addClass(this._mapPane,"leaflet-pan-anim");var i=this._getMapPanePos().subtract(t);this._panAnim.run(this._mapPane,i,e.duration||.25,e.easeLinearity)}else this._rawPanBy(t),this.fire("move").fire("moveend");return this},_onPanTransitionStep:function(){this.fire("move")},_onPanTransitionEnd:function(){o.DomUtil.removeClass(this._mapPane,"leaflet-pan-anim"),this.fire("moveend")},_tryAnimatedPan:function(t,e){var i=this._getCenterOffset(t)._floor();return(e&&e.animate)===!0||this.getSize().contains(i)?(this.panBy(i,e),!0):!1}}),o.PosAnimation=o.DomUtil.TRANSITION?o.PosAnimation:o.PosAnimation.extend({run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._duration=i||.25,this._easeOutPower=1/Math.max(n||.5,.2),this._startPos=o.DomUtil.getPosition(t),this._offset=e.subtract(this._startPos),this._startTime=+new Date,this.fire("start"),this._animate()},stop:function(){this._inProgress&&(this._step(),this._complete())},_animate:function(){this._animId=o.Util.requestAnimFrame(this._animate,this),this._step()},_step:function(){var t=+new Date-this._startTime,e=1e3*this._duration;e>t?this._runFrame(this._easeOut(t/e)):(this._runFrame(1),this._complete())},_runFrame:function(t){var e=this._startPos.add(this._offset.multiplyBy(t));o.DomUtil.setPosition(this._el,e),this.fire("step")},_complete:function(){o.Util.cancelAnimFrame(this._animId),this._inProgress=!1,this.fire("end")},_easeOut:function(t){return 1-Math.pow(1-t,this._easeOutPower)}}),o.Map.mergeOptions({zoomAnimation:!0,zoomAnimationThreshold:4}),o.DomUtil.TRANSITION&&o.Map.addInitHook(function(){this._zoomAnimated=this.options.zoomAnimation&&o.DomUtil.TRANSITION&&o.Browser.any3d&&!o.Browser.android23&&!o.Browser.mobileOpera,this._zoomAnimated&&o.DomEvent.on(this._mapPane,o.DomUtil.TRANSITION_END,this._catchTransitionEnd,this)}),o.Map.include(o.DomUtil.TRANSITION?{_catchTransitionEnd:function(t){this._animatingZoom&&t.propertyName.indexOf("transform")>=0&&this._onZoomTransitionEnd()},_nothingToAnimate:function(){return!this._container.getElementsByClassName("leaflet-zoom-animated").length},_tryAnimatedZoom:function(t,e,i){if(this._animatingZoom)return!0;if(i=i||{},!this._zoomAnimated||i.animate===!1||this._nothingToAnimate()||Math.abs(e-this._zoom)>this.options.zoomAnimationThreshold)return!1;var n=this.getZoomScale(e),o=this._getCenterOffset(t)._divideBy(1-1/n),s=this._getCenterLayerPoint()._add(o);return i.animate===!0||this.getSize().contains(o)?(this.fire("movestart").fire("zoomstart"),this._animateZoom(t,e,s,n,null,!0),!0):!1},_animateZoom:function(t,e,i,n,s,a,r){r||(this._animatingZoom=!0),o.DomUtil.addClass(this._mapPane,"leaflet-zoom-anim"),this._animateToCenter=t,this._animateToZoom=e,o.Draggable&&(o.Draggable._disabled=!0),o.Util.requestAnimFrame(function(){this.fire("zoomanim",{center:t,zoom:e,origin:i,scale:n,delta:s,backwards:a}),setTimeout(o.bind(this._onZoomTransitionEnd,this),250)},this)},_onZoomTransitionEnd:function(){this._animatingZoom&&(this._animatingZoom=!1,o.DomUtil.removeClass(this._mapPane,"leaflet-zoom-anim"),o.Util.requestAnimFrame(function(){this._resetView(this._animateToCenter,this._animateToZoom,!0,!0),o.Draggable&&(o.Draggable._disabled=!1)},this))}}:{}),o.TileLayer.include({_animateZoom:function(t){this._animating||(this._animating=!0,this._prepareBgBuffer());var e=this._bgBuffer,i=o.DomUtil.TRANSFORM,n=t.delta?o.DomUtil.getTranslateString(t.delta):e.style[i],s=o.DomUtil.getScaleString(t.scale,t.origin);e.style[i]=t.backwards?s+" "+n:n+" "+s},_endZoomAnim:function(){var t=this._tileContainer,e=this._bgBuffer;t.style.visibility="",t.parentNode.appendChild(t),o.Util.falseFn(e.offsetWidth);var i=this._map.getZoom();(i>this.options.maxZoom||i<this.options.minZoom)&&this._clearBgBuffer(),this._animating=!1},_clearBgBuffer:function(){var t=this._map;!t||t._animatingZoom||t.touchZoom._zooming||(this._bgBuffer.innerHTML="",this._bgBuffer.style[o.DomUtil.TRANSFORM]="")},_prepareBgBuffer:function(){var t=this._tileContainer,e=this._bgBuffer,i=this._getLoadedTilesPercentage(e),n=this._getLoadedTilesPercentage(t);return e&&i>.5&&.5>n?(t.style.visibility="hidden",void this._stopLoadingImages(t)):(e.style.visibility="hidden",e.style[o.DomUtil.TRANSFORM]="",this._tileContainer=e,e=this._bgBuffer=t,this._stopLoadingImages(e),void clearTimeout(this._clearBgBufferTimer))},_getLoadedTilesPercentage:function(t){var e,i,n=t.getElementsByTagName("img"),o=0;for(e=0,i=n.length;i>e;e++)n[e].complete&&o++;return o/i},_stopLoadingImages:function(t){var e,i,n,s=Array.prototype.slice.call(t.getElementsByTagName("img"));for(e=0,i=s.length;i>e;e++)n=s[e],n.complete||(n.onload=o.Util.falseFn,n.onerror=o.Util.falseFn,n.src=o.Util.emptyImageUrl,n.parentNode.removeChild(n))}}),o.Map.include({_defaultLocateOptions:{watch:!1,setView:!1,maxZoom:1/0,timeout:1e4,maximumAge:0,enableHighAccuracy:!1},locate:function(t){if(t=this._locateOptions=o.extend(this._defaultLocateOptions,t),!navigator.geolocation)return this._handleGeolocationError({code:0,message:"Geolocation not supported."}),this;var e=o.bind(this._handleGeolocationResponse,this),i=o.bind(this._handleGeolocationError,this);return t.watch?this._locationWatchId=navigator.geolocation.watchPosition(e,i,t):navigator.geolocation.getCurrentPosition(e,i,t),this},stopLocate:function(){return navigator.geolocation&&navigator.geolocation.clearWatch(this._locationWatchId),this._locateOptions&&(this._locateOptions.setView=!1),this},_handleGeolocationError:function(t){var e=t.code,i=t.message||(1===e?"permission denied":2===e?"position unavailable":"timeout");this._locateOptions.setView&&!this._loaded&&this.fitWorld(),this.fire("locationerror",{code:e,message:"Geolocation error: "+i+"."})},_handleGeolocationResponse:function(t){var e=t.coords.latitude,i=t.coords.longitude,n=new o.LatLng(e,i),s=180*t.coords.accuracy/40075017,a=s/Math.cos(o.LatLng.DEG_TO_RAD*e),r=o.latLngBounds([e-s,i-a],[e+s,i+a]),h=this._locateOptions;if(h.setView){var l=Math.min(this.getBoundsZoom(r),h.maxZoom);this.setView(n,l)}var u={latlng:n,bounds:r,timestamp:t.timestamp};for(var c in t.coords)"number"==typeof t.coords[c]&&(u[c]=t.coords[c]);this.fire("locationfound",u)}})}(window,document);
   },{}],
   "lie":[function(require,module,exports){
   !function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var t;t="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,t.Promise=e()}}(function(){return function e(t,n,r){function o(u,s){if(!n[u]){if(!t[u]){var c="function"==typeof require&&require;if(!s&&c)return c(u,!0);if(i)return i(u,!0);var f=new Error("Cannot find module '"+u+"'");throw f.code="MODULE_NOT_FOUND",f}var a=n[u]={exports:{}};t[u][0].call(a.exports,function(e){var n=t[u][1][e];return o(n?n:e)},a,a.exports,e,t,n,r)}return n[u].exports}for(var i="function"==typeof require&&require,u=0;u<r.length;u++)o(r[u]);return o}({1:[function(e,t,n){(function(e){"use strict";function n(){a=!0;for(var e,t,n=l.length;n;){for(t=l,l=[],e=-1;++e<n;)t[e]();n=l.length}a=!1}function r(e){1!==l.push(e)||a||o()}var o,i=e.MutationObserver||e.WebKitMutationObserver;if(i){var u=0,s=new i(n),c=e.document.createTextNode("");s.observe(c,{characterData:!0}),o=function(){c.data=u=++u%2}}else if(e.setImmediate||"undefined"==typeof e.MessageChannel)o="document"in e&&"onreadystatechange"in e.document.createElement("script")?function(){var t=e.document.createElement("script");t.onreadystatechange=function(){n(),t.onreadystatechange=null,t.parentNode.removeChild(t),t=null},e.document.documentElement.appendChild(t)}:function(){setTimeout(n,0)};else{var f=new e.MessageChannel;f.port1.onmessage=n,o=function(){f.port2.postMessage(0)}}var a,l=[];t.exports=r}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],2:[function(e,t,n){"use strict";function r(){}function o(e){if("function"!=typeof e)throw new TypeError("resolver must be a function");this.state=j,this.queue=[],this.outcome=void 0,e!==r&&c(this,e)}function i(e,t,n){this.promise=e,"function"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),"function"==typeof n&&(this.onRejected=n,this.callRejected=this.otherCallRejected)}function u(e,t,n){d(function(){var r;try{r=t(n)}catch(t){return v.reject(e,t)}r===e?v.reject(e,new TypeError("Cannot resolve promise with itself")):v.resolve(e,r)})}function s(e){var t=e&&e.then;if(e&&("object"==typeof e||"function"==typeof e)&&"function"==typeof t)return function(){t.apply(e,arguments)}}function c(e,t){function n(t){i||(i=!0,v.reject(e,t))}function r(t){i||(i=!0,v.resolve(e,t))}function o(){t(r,n)}var i=!1,u=f(o);"error"===u.status&&n(u.value)}function f(e,t){var n={};try{n.value=e(t),n.status="success"}catch(e){n.status="error",n.value=e}return n}function a(e){return e instanceof this?e:v.resolve(new this(r),e)}function l(e){var t=new this(r);return v.reject(t,e)}function h(e){function t(e,t){function r(e){u[t]=e,++s!==o||i||(i=!0,v.resolve(f,u))}n.resolve(e).then(r,function(e){i||(i=!0,v.reject(f,e))})}var n=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var o=e.length,i=!1;if(!o)return this.resolve([]);for(var u=new Array(o),s=0,c=-1,f=new this(r);++c<o;)t(e[c],c);return f}function p(e){function t(e){n.resolve(e).then(function(e){i||(i=!0,v.resolve(s,e))},function(e){i||(i=!0,v.reject(s,e))})}var n=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var o=e.length,i=!1;if(!o)return this.resolve([]);for(var u=-1,s=new this(r);++u<o;)t(e[u]);return s}var d=e(1),v={},y=["REJECTED"],m=["FULFILLED"],j=["PENDING"];t.exports=o,o.prototype.catch=function(e){return this.then(null,e)},o.prototype.then=function(e,t){if("function"!=typeof e&&this.state===m||"function"!=typeof t&&this.state===y)return this;var n=new this.constructor(r);if(this.state!==j){var o=this.state===m?e:t;u(n,o,this.outcome)}else this.queue.push(new i(n,e,t));return n},i.prototype.callFulfilled=function(e){v.resolve(this.promise,e)},i.prototype.otherCallFulfilled=function(e){u(this.promise,this.onFulfilled,e)},i.prototype.callRejected=function(e){v.reject(this.promise,e)},i.prototype.otherCallRejected=function(e){u(this.promise,this.onRejected,e)},v.resolve=function(e,t){var n=f(s,t);if("error"===n.status)return v.reject(e,n.value);var r=n.value;if(r)c(e,r);else{e.state=m,e.outcome=t;for(var o=-1,i=e.queue.length;++o<i;)e.queue[o].callFulfilled(t)}return e},v.reject=function(e,t){e.state=y,e.outcome=t;for(var n=-1,r=e.queue.length;++n<r;)e.queue[n].callRejected(t);return e},o.resolve=a,o.reject=l,o.all=h,o.race=p},{1:1}]},{},[2])(2)});
   },{}],
   "mergexml":[function(require,module,exports){
   /**
    * XML merging class
    * Merge multiple XML sources
    *
    * @package     MergeXML
    * @author      Vallo Reima
    * @copyright   (C)2014-2016
    */

   /**
    * AMD/CommonJS wrapper
    * @param {object} root
    * @param {function} factory
    */
   (function(root, factory) {
     "use strict";
     if (typeof define === 'function' && define.amd) {
       // AMD. Register as an anonymous module
       define([], factory);
     } else if (typeof exports === 'object') {
       // Does not work with strict CommonJS,
       // but only CommonJS-like environments
       // that support module.exports, like Node
       module.exports = factory();
     } else {
       // Direct call, root is the owner (window)
       root.MergeXML = factory();
     }
   }(this, function() {
     /**
      * Return a function as the exported value
      * @param {object} opts -- stay, join, updn (see readme)
      */
     return function(opts) {

       var mde;        /* access mode 0,1,2 */
       var msv;        /* MS DOM version */
       var psr;        /* DOM parser object */
       var nse;        /* parsererror namespace */
       var xpe;        /* xPath evaluator */
       var nsr;        /* namespace resolver */
       var nsd = '_';  /* default namespace prefix */
       var stay;       /* overwrite protection */
       var join;       /* joining root name and status*/
       var updn;       /* update nodes sequentially by name */
       var XML_ELEMENT_NODE = 1;
       var XML_TEXT_NODE = 3;
       var XML_COMMENT_NODE = 8;
       var XML_PI_NODE = 7;
       var that = this;

       that.Init = function() {
         that.dom = null; /* result DOM object */
         that.nsp = {};   /* namespaces */
         that.count = 0; /* adding counter */
         join[1] = false;
         if (mde > 0) {
           that.error = {code: '', text: ''};
         }
         return (mde > 0);
       };

       /**
        * add XML file
        * @param {object} file -- FileList element
        * @return {object|false}
        */
       that.AddFile = function(file) {
         var rlt;
         if (!file || !file.target) {
           rlt = Error('nof');
         } else if (!file.target.result) {
           rlt = Error('emf');
         } else {
           rlt = that.AddSource(file.target.result);
         }
         return rlt;
       };

       /**
        * add XML string
        * @param {string|oobject} xml
        * @return mixed -- false - bad content
        *                  object - result
        */
       that.AddSource = function(xml) {
         var rlt, doc;
         if (typeof xml === 'object') {
           doc = that.Get(1, xml) ? xml : false;
           if (doc && ((mde === 1 && !window.DOMParser) || (mde === 2 && !doc.selectSingleNode('/')))) {
             doc = null; /* not compatible */
           }
         } else {
           try {
             doc = Load(xml);
           } catch (e) {
             doc = false;
           }
         }
         if (doc === null) {
           rlt = Error('nos');
         } else if (doc === false) {
           rlt = Error('inv');
         } else if (doc === true) {
           that.nsp = NameSpaces(that.dom.documentElement);
           that.count = 1;
           rlt = that.dom;
         } else if (CheckSource(doc)) {
           Merge(doc, '/');  /* add to existing */
           if (join[1] === true) {
             var tmp = that.dom.createTextNode("\r\n");
             that.dom.documentElement.appendChild(tmp);
           }
           that.count++;
           rlt = that.dom;
         } else {
           rlt = false;
         }
         return rlt;
       };

       /**
        * load the source into dom object
        * @param {object|string} src -- the source
        * @return {mixed} -- false - error
        *                    true - 1st load
        *                    object - loaded doc
        */
       var Load = function(src) {
         var rlt, doc;
         if (mde === 1) {
           if (that.dom) {
             doc = psr.parseFromString(src, 'text/xml');
             rlt = ParseError(doc) ? doc : false;
           } else {
             that.dom = psr.parseFromString(src, 'text/xml');
             rlt = ParseError(that.dom) ? true : false;
           }
         } else if (that.dom) {
           doc = new ActiveXObject(msv);
           doc.async = false;
           rlt = doc.loadXML(src) ? doc : false;
         } else {
           that.dom = new ActiveXObject(msv);
           that.dom.async = false;
           that.dom.setProperty('SelectionLanguage', 'XPath');
           rlt = that.dom.loadXML(src) ? true : false;
         }
         return rlt;
       };

       /**
        * check for xml syntax (mode 1)
        * @param {object} doc
        * @return {bool} -- true - ok
        */
       var ParseError = function(doc) {
         return doc.getElementsByTagNameNS(nse, 'parsererror').length === 0;
       };

       /**
        *
        * @param {object} doc
        * @return {bool} -- true - ok
        */
       var CheckSource = function(doc) {
         var rlt = true;
         var charSet1 = that.dom.characterSet || that.dom.inputEncoding || that.dom.xmlEncoding;
         var charSet2 = doc.characterSet || doc.inputEncoding || doc.xmlEncoding
         if (charSet2 !== charSet1) {
           rlt = Error('enc');
         } else if (doc.documentElement.namespaceURI !== that.dom.documentElement.namespaceURI) { /* $dom->documentElement->lookupnamespaceURI(NULL) */
           rlt = Error('nse');
         } else if (doc.documentElement.nodeName !== that.dom.documentElement.nodeName) {
           if (!join[0]) {
             rlt = Error('dif');
           } else if (!join[1]) {
             var enc = typeof charSet1 !== 'undefined' ? charSet1 : 'UTF-8';
             var ver = that.dom.xmlVersion ? that.dom.xmlVersion : '1.0';
             var xml = '<?xml version="' + ver + '" encoding="' + enc + "\"?>\r\n<" + join[0] + ">\r\n</" + join[0] + '>';
             var d = Load(xml);
             if (d) {
               var tmp = that.dom.documentElement.cloneNode(true);
               d.documentElement.appendChild(tmp);
               tmp = d.createTextNode("\r\n");
               d.documentElement.appendChild(tmp);
               that.dom = d;
               join[1] = true;
             } else {
               rlt = Error('jne');
               join[1] = null;
             }
           }
         }
         if (rlt) {
           var a = NameSpaces(doc.documentElement);
           for (var c in a) {
             if (!that.nsp[c]) {
               if (typeof that.dom.documentElement.setAttributeNS !== 'undefined') {
                 that.dom.documentElement.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:' + c, a[c]);
               } else {
                 // no choice but to use the incorrect setAttribute instead
                 that.dom.documentElement.setAttribute('xmlns:' + c, a[c]);
               }
               that.nsp[c] = a[c];
             }
           }
           if (!updn) {
             nsr = null;
           } else if (mde === 1) {
             nsr = Resolver;
           } else {
             ResolverIE();
           }
         }
         return rlt;
       };
       /**
        * join 2 dom objects recursively
        * @param {object} src -- current source node
        * @param {string} pth -- current source path
        */
       var Merge = function(src, pth) {
         for (var i = 0; i < src.childNodes.length; i++) {
           var tmp;
           var node = src.childNodes[i]; //$node->getNodePath()
           var path = GetNodePath(src.childNodes, node, pth, i);
           var obj = that.Query(path);
           if (node.nodeType === XML_ELEMENT_NODE) {
             var flg = true;  /* replace existing node by default */
             if (obj === null || obj.namespaceURI !== node.namespaceURI) {
               tmp = node.cloneNode(true); /* take existing node */
               obj = that.Query(pth); /* destination parent */
               obj.appendChild(tmp); /* add a node */
             } else {
               if (ArraySearch(obj.getAttribute('stay'), stay) !== false) {
                 flg = false; /* don't replace */
               }
               if (flg) {
                 try {
                   for (var j = 0; j < node.attributes.length; j++) { /* add/replace attributes */
                     if (node.attributes[j].namespaceURI && typeof node.setAttributeNS !== 'undefined') {
                       obj.setAttributeNS(node.attributes[j].namespaceURI, node.attributes[j].nodeName, node.attributes[j].nodeValue);
                     } else {
                       obj.setAttribute(node.attributes[j].nodeName, node.attributes[j].nodeValue);
                     }
                   }
                 } catch (e) {
                   /* read-only node */
                 }
               }
             }
             if (node.hasChildNodes() && flg) {
               Merge(node, path); /* go to subnodes */
             }
           } else if (node.nodeType === XML_TEXT_NODE || node.nodeType === XML_COMMENT_NODE) { /* leaf node */
             if (obj === null || obj.nodeType !== node.nodeType) {
               obj = that.Query(pth);    /* destination parent node */
               if (node.nodeType === XML_TEXT_NODE) {
                 tmp = that.dom.createTextNode(node.nodeValue); /* add text */
               } else {
                 tmp = that.dom.createComment(node.nodeValue);  /* add comment */
               }
               obj.appendChild(tmp); /* add leaf */
             } else {
               obj.nodeValue = node.nodeValue; /* replace leaf */
             }
           }
         }
       };

       /**
        * form the node xPath
        * @param {object} nodes -- child nodes
        * @param {object} node -- current child
        * @param {string} pth -- parent path
        * @param {int} eln -- element sequence number
        * @return {string} query path
        */
       var GetNodePath = function(nodes, node, pth, eln) {
         var p, i;
         var j = 0;
         if (node.nodeType === XML_ELEMENT_NODE) {
           for (i = 0; i <= eln; i++) {
             if ((updn && nodes[i].nodeType === node.nodeType && nodes[i].nodeName === node.nodeName) ||
                     (!updn && nodes[i].nodeType !== XML_PI_NODE)) {
               j++;
             }
           }
           if (updn) {
             var f = false;
             var a = NameSpaces(node);
             for (var c in a) {
               if (c !== nsd) {
                 that.nsp[c] = a[c];
                 f = (mde === 2);
               }
             }
             if (f) {
               ResolverIE();
             }
             if (node.prefix) {
               p = node.prefix + ':';
             } else if (that.nsp[nsd]) {
               p = nsd + ':';
             } else {
               p = '';
             }
             p += (node.localName ? node.localName : node.baseName);
           } else {
             p = 'node()';
           }
         } else if (node.nodeType === XML_TEXT_NODE || node.nodeType === XML_COMMENT_NODE) {
           for (i = 0; i <= eln; i++) {
             if (nodes[i].nodeType === node.nodeType) {
               j++;
             }
           }
           p = node.nodeType === XML_TEXT_NODE ? 'text()' : 'comment()';
         } else {
           p = pth;
         }
         if (j) {
           p = pth + (pth.slice(-1) === '/' ? '' : '/') + p + '[' + j + ']';
         }
         return p;
       };

       /**
        * get node's namespaces
        * @param {object} node
        * @return {array}
        */
       var NameSpaces = function(node) {
         var rlt = {};
         var attrs = node.attributes;
         for (var i = 0; i < attrs.length; ++i) {
           var a = attrs[i].name.split(':');
           if (a[0] === 'xmlns') {
             var c = a[1] ? a[1] : nsd;
             rlt[c] = attrs[i].value;
           }
         }
         return rlt;
       };

       /**
        * xPath query
        * @param {string} qry -- query statement
        * @return {object}
        */
       that.Query = function(qry) {
         var rlt;
         if (join[1]) {
           qry = '/' + that.dom.documentElement.nodeName + (qry === '/' ? '' : qry);
         }
         try {
           if (mde === 1) {
             rlt = xpe.evaluate(qry, that.dom, nsr, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
             rlt = rlt.singleNodeValue;
           } else {
             rlt = that.dom.selectSingleNode(qry);
           }
         }
         catch (e) {
           rlt = null; /* no such path */
         }
         return rlt;
       };

       /**
        * XPathNSResolver
        * @param {string} pfx node prefix
        * @return {string} namespace URI
        */
       var Resolver = function(pfx) {
         return that.nsp[pfx] || null;
       };

       /**
        * XPath IE Resolver
        */
       var ResolverIE = function() {
         var p = '';
         for (var c in that.nsp) {
           p += ' xmlns:' + c + '=' + "'" + that.nsp[c] + "'";
         }
         if (p) {
           that.dom.setProperty('SelectionNamespaces', p.substr(1));
         }
       };

       /**
        * find array memeber by value
        * @param {mixed} val
        * @param {array} arr
        * @returns {mixed}
        */
       var ArraySearch = function(val, arr) {
         var rlt = false;
         for (var key in arr) {
           if (arr[key] === val) {
             rlt = key;
             break;
           }
         }
         return rlt;
       };

       /**
        * get result
        * @param {int} flg -- 0 - object
        *                     1 - xml
        *                     2 - html
        * @param {object} doc
        * @return {mixed}
        */
       that.Get = function(flg, doc) {
         var rlt;
         if (flg && !doc) {
           doc = that.dom;
         }
         if (!flg) {
           rlt = that.dom;
         } else if (!doc) {
           rlt = '';
         } else if (doc.xml) {
           rlt = doc.xml;
         } else {
           try {
             rlt = (new XMLSerializer()).serializeToString(doc);
           } catch (e) {
             rlt = null;
           }
         }
         if (rlt && flg === 2) { /* make html view */
           if (join[1]) {
             var k = rlt.indexOf('<' + join[0]);
             rlt = rlt.substr(0, k) + "\r\n" + rlt.substr(k);
           }
           rlt = rlt.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/ |\t/g, '&nbsp;'); /* tags and spaces */
           rlt = rlt.replace(/(\r\n|\n|\r)/g, '<br>');  /* line breaks */
         }
         return rlt;
       };

       /**
        * set error message
        * @param {string} err -- token
        * @return {false}
        */
       var Error = function(err) {
         var errs = {
           nod: 'XML DOM is not supported in this browser',
           nox: 'xPath is not supported in this browser',
           nos: 'Incompatible source object',
           nof: 'File not found',
           emf: 'File is empty', /* possible delivery fault */
           inv: 'Invalid XML source',
           enc: 'Different encoding',
           dif: 'Different root nodes',
           jne: 'Invalid join parameter',
           nse: 'Namespace incompatibility',
           und: 'Undefined error'
         };
         that.error.code = errs[err] ? err : 'und';
         that.error.text = errs[that.error.code];
         return false;
       };

       /**
        * identify browser functionality
        * @return {int|string} mode number or error code
        */
       var GetMode = function() {
         var m;
         var f = false;
         var vers = [
           'MSXML2.DOMDocument.6.0',
           'MSXML2.DOMDocument.3.0',
           'MSXML2.DOMDocument',
           'Microsoft.XmlDom'
         ];
         var n = vers.length;
         for (var i = 0; i < n; i++) {
           try {
             var d = new ActiveXObject(vers[i]);
             d.async = false;
             f = true;   /* DOM supported */
             if (d.loadXML('<x></x>') && d.selectSingleNode('/')) {
               break;    /* xPath supported */
             }
           } catch (e) {
             /* skip */
           }
         }
         if (f) {
           if (i < n) {
             msv = vers[i];
             m = 2;  /* IE mode */
           } else {
             m = 'nox';  /* no xPath */
           }
         } else if (!window.DOMParser) {
           m = 'nod';  /* no DOM */
         } else if (!window.XPathEvaluator) {
           m = 'nox';  /* no xPath */
         } else {
           psr = new DOMParser();
           var e = psr.parseFromString('Invalid', 'text/xml'); /* to detect source error */
           nse = e.getElementsByTagName('parsererror')[0].namespaceURI;
           xpe = new XPathEvaluator();
           m = 1;  /*  Firefox, Safari, Chrome, Opera */
         }
         return m;
       };

       if (typeof opts !== 'object') {
         opts = {};
       }
       /* set stay attribute value to check */
       if (typeof opts.stay === 'undefined') {
         stay = ['all'];
       } else if (!opts.stay) {
         stay = [];
       } else if (typeof opts.stay === 'object' && opts.stay instanceof Array) {
         stay = opts.stay;
       } else {
         stay = [opts.stay];
       }
       /* set join condtion for different roots */
       if (typeof opts.join === 'undefined') {
         join = ['root'];
       } else {
         join = [opts.join ? String(opts.join) : false];
       }
       /* set update sequence manner */
       if (typeof opts.updn === 'undefined') {
         updn = true;
       } else {
         updn = opts.updn;
       }
       /* detect browser features: 2 - IE, 1 - rest, 0 - N/A */
       mde = GetMode();
       if (typeof mde === 'string') {
         that.error = {};
         Error(mde);
         mde = 0;
       }
       that.Init();
     };
   }));
   },{}],
   "branch":[function(require,module,exports){
   'use strict';

   /**
    * Updates branches
    *
    * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
    */

   var $ = require( 'jquery' );

   module.exports = {
       update: function( updated, forceClearIrrelevant ) {
           var p;
           var $branchNode;
           var result;
           var insideRepeat;
           var insideRepeatClone;
           var cacheIndex;
           var $nodes;
           var relevantCache = {};
           var alreadyCovered = [];
           var branchChange = false;
           var that = this;
           var clonedRepeatsPresent;

           if ( !this.form ) {
               throw new Error( 'Branch module not correctlsy instantiated with form property.' );
           }

           $nodes = this.form.getRelatedNodes( 'data-relevant', '', updated );

           clonedRepeatsPresent = ( this.form.repeatsPresent && this.form.view.$.find( '.or-repeat.clone' ).length > 0 ) ? true : false;

           $nodes.each( function() {
               var $node = $( this );
               var context;

               //note that $(this).attr('name') is not the same as p.path for repeated radiobuttons!
               if ( $.inArray( $node.attr( 'name' ), alreadyCovered ) !== -1 ) {
                   return;
               }

               // since this result is almost certainly not empty, closest() is the most efficient
               $branchNode = $node.closest( '.or-branch' );

               p = {};
               cacheIndex = null;

               p.relevant = that.form.input.getRelevant( $node );
               p.path = that.form.input.getName( $node );

               if ( $branchNode.length !== 1 ) {
                   if ( $node.parentsUntil( '.or', '#or-calculated-items' ).length === 0 ) {
                       console.error( 'could not find branch node for ', $( this ) );
                   }
                   return;
               }
               /*
                * Determining ancestry is expensive. Using the knowledge most forms don't use repeats and
                * if they do, they usually don't have cloned repeats during initialization we perform first a check for .repeat.clone.
                * The first condition is usually false (and is a very quick one-time check) so this presents a big performance boost
                * (6-7 seconds of loading time on the bench6 form)
                */
               insideRepeat = ( clonedRepeatsPresent && $branchNode.parentsUntil( '.or', '.or-repeat' ).length > 0 ) ? true : false;
               insideRepeatClone = ( clonedRepeatsPresent && $branchNode.parentsUntil( '.or', '.or-repeat.clone' ).length > 0 ) ? true : false;
               /*
                * If the relevant is placed on a group and that group contains repeats with the same name,
                * but currently has 0 repeats, the context will not be available.
                */
               if ( $node.children( '.or-repeat-info[data-name="' + p.path + '"]' ).length && !$node.children( '.or-repeat[name="' + p.path + '"]' ).length ) {
                   context = null;
               } else {
                   context = p.path;
               }
               /*
                * Determining the index is expensive, so we only do this when the branch is inside a cloned repeat.
                * It can be safely set to 0 for other branches.
                */
               p.ind = ( context && insideRepeatClone ) ? that.form.input.getIndex( $node ) : 0;
               /*
                * Caching is only possible for expressions that do not contain relative paths to nodes.
                * So, first do a *very* aggresive check to see if the expression contains a relative path.
                * This check assumes that child nodes (e.g. "mychild = 'bob'") are NEVER used in a relevant
                * expression, which may prove to be incorrect.
                */
               if ( p.relevant.indexOf( '..' ) === -1 ) {
                   if ( !insideRepeat ) {
                       cacheIndex = p.relevant;
                   } else {
                       // The path is stripped of the last nodeName to record the context.
                       // This might be dangerous, but until we find a bug, it helps in those forms where one group contains
                       // many sibling questions that each have the same relevant.
                       cacheIndex = p.relevant + '__' + p.path.substring( 0, p.path.lastIndexOf( '/' ) ) + '__' + p.ind;
                   }
               }
               if ( cacheIndex && typeof relevantCache[ cacheIndex ] !== 'undefined' ) {
                   result = relevantCache[ cacheIndex ];
               } else {
                   result = that.evaluate( p.relevant, context, p.ind );
                   relevantCache[ cacheIndex ] = result;
               }

               if ( !insideRepeat ) {
                   alreadyCovered.push( $( this ).attr( 'name' ) );
               }

               if ( that.process( $branchNode, result, forceClearIrrelevant ) === true ) {
                   branchChange = true;
               }
           } );

           if ( branchChange ) {
               this.form.view.$.trigger( 'changebranch' );
           }
       },
       /**
        * Evaluates a relevant expression (for future fancy stuff this is placed in a separate function)
        *
        * @param  {string} expr        [description]
        * @param  {string} contextPath [description]
        * @param  {number} index       [description]
        * @return {boolean}             [description]
        */
       evaluate: function( expr, contextPath, index ) {
           var result = this.form.model.evaluate( expr, 'boolean', contextPath, index );
           return result;
       },
       /**
        * Processes the evaluation result for a branch
        *
        * @param  {jQuery} $branchNode [description]
        * @param  {boolean} result      [description]
        */
       process: function( $branchNode, result, forceClearIrrelevant ) {
           if ( result === true ) {
               return this.enable( $branchNode );
           } else {
               return this.disable( $branchNode, forceClearIrrelevant );
           }
       },

       /**
        * Checks whether branch currently has 'relevant' state
        *
        * @param  {jQuery} $branchNode [description]
        * @return {boolean}             [description]
        */
       selfRelevant: function( $branchNode ) {
           return !$branchNode.hasClass( 'disabled' ) && !$branchNode.hasClass( 'pre-init' );
       },

       /**
        * Enables and reveals a branch node/group
        *
        * @param  {jQuery} $branchNode The jQuery object to reveal and enable
        */
       enable: function( $branchNode ) {
           var type;
           var change = false;

           if ( !this.selfRelevant( $branchNode ) ) {
               change = true;
               $branchNode.removeClass( 'disabled pre-init' );

               this.form.widgets.enable( $branchNode );

               type = $branchNode.prop( 'nodeName' ).toLowerCase();

               if ( type === 'label' ) {
                   $branchNode.children( 'input, select, textarea' ).prop( 'disabled', false );
               } else if ( type === 'fieldset' || type === 'section' ) {
                   $branchNode.prop( 'disabled', false );
                   /*
                    * A temporary workaround for a Chrome bug described in https://github.com/modilabs/enketo/issues/503
                    * where the file inputs end up in a weird partially enabled state.
                    * Refresh the state by disabling and enabling the file inputs again.
                    */
                   $branchNode.find( '*:not(.or-branch) input[type="file"]:not([data-relevant])' )
                       .prop( 'disabled', true )
                       .prop( 'disabled', false );
               } else {
                   $branchNode.find( 'fieldset, input, select, textarea' ).prop( 'disabled', false );
               }
           }
           return change;
       },
       /**
        * Disables and hides a branch node/group
        *
        * @param  {jQuery} $branchNode The jQuery object to hide and disable
        */
       disable: function( $branchNode, forceClearIrrelevant ) {
           var type = $branchNode.prop( 'nodeName' ).toLowerCase();
           var virgin = $branchNode.hasClass( 'pre-init' );
           var change = false;

           if ( virgin || this.selfRelevant( $branchNode ) || forceClearIrrelevant ) {
               change = true;
               $branchNode.addClass( 'disabled' );
               this.form.widgets.disable( $branchNode );
               // if the branch was previously enabled
               if ( !virgin ) {
                   if ( this.form.options.clearIrrelevantImmediately || forceClearIrrelevant ) {
                       // A change event ensures the model is updated
                       // An inputupdate event is required to update widgets
                       $branchNode.clearInputs( 'change', 'inputupdate.enketo' );
                   }
                   // all remaining fields marked as invalid can now be marked as valid
                   $branchNode.find( '.invalid-required, .invalid-constraint' ).find( 'input, select, textarea' ).each( function() {
                       this.setValid( $( this ) );
                   } );
               } else {
                   $branchNode.removeClass( 'pre-init' );
               }

               if ( type === 'label' ) {
                   $branchNode.children( 'input, select, textarea' ).prop( 'disabled', true );
               } else if ( type === 'fieldset' || type === 'section' ) {
                   // TODO: a <section> cannot be disabled like this
                   $branchNode.prop( 'disabled', true );
               } else {
                   $branchNode.find( 'fieldset, input, select, textarea' ).prop( 'disabled', true );
               }
           }
           return change;
       }

   };

   },{"jquery":"jquery"}],
   "calculation":[function(require,module,exports){
   'use strict';

   /**
    * Updates calculated items
    *
    * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
    */

   var $ = require( 'jquery' );

   module.exports = {
       update: function( updated ) {
           var $nodes;
           var that = this;

           if ( !this.form ) {
               throw new Error( 'Calculation module not correctly instantiated with form property.' );
           }

           updated = updated || {};

           $nodes = this.form.getRelatedNodes( 'data-calculate', '', updated );

           // add relevant items that have a (any) calculation
           $nodes = $nodes.add( this.form.getRelatedNodes( 'data-relevant', '[data-calculate]', updated ) );

           $nodes.each( function() {
               var result;
               var dataNodesObj;
               var dataNodes;
               var $dataNode;
               var index;
               var name;
               var dataNodeName;
               var expr;
               var newExpr;
               var dataType;
               var constraintExpr;
               var relevantExpr;
               var relevant;
               var $this;

               $this = $( this );
               name = that.form.input.getName( $this );
               dataNodeName = ( name.lastIndexOf( '/' ) !== -1 ) ? name.substring( name.lastIndexOf( '/' ) + 1 ) : name;
               expr = that.form.input.getCalculation( $this );
               dataType = that.form.input.getXmlType( $this );
               // for inputs that have a calculation and need to be validated
               constraintExpr = that.form.input.getConstraint( $this );
               relevantExpr = that.form.input.getRelevant( $this );

               dataNodesObj = that.form.model.node( name );
               dataNodes = dataNodesObj.get();

               /*
                * If the update was triggered by a datanode inside a repeat
                * and the dependent node is inside the same repeat
                */
               if ( dataNodes.length > 1 && updated.repeatPath && name.indexOf( updated.repeatPath ) !== -1 ) {
                   $dataNode = that.form.model.node( updated.repeatPath, updated.repeatIndex ).get().find( dataNodeName );
                   index = $( dataNodes ).index( $dataNode );
                   updateCalc( index );
               } else if ( dataNodes.length === 1 ) {
                   index = 0;
                   updateCalc( index );
               } else {
                   // This occurs when update is called with empty updated object and multiple repeats are present
                   dataNodes.each( function( index ) {
                       updateCalc( index );
                   } );
               }

               function updateCalc( index ) {
                   relevant = ( relevantExpr ) ? that.form.model.evaluate( relevantExpr, 'boolean', name, index ) : true;

                   // not sure if using 'string' is always correct
                   newExpr = that.form.replaceChoiceNameFn( expr, 'string', name, index );

                   // it is possible that the fixed expr is '' which causes an error in XPath
                   result = ( relevant && newExpr ) ? that.form.model.evaluate( newExpr, 'string', name, index ) : '';

                   // filter the result set to only include the target node
                   dataNodesObj.setIndex( index );

                   // set the value
                   dataNodesObj.setVal( result, constraintExpr, dataType );

                   // Not the most efficient to use input.setVal here as it will do another lookup
                   // of the node, that we already have...
                   // We should not use value "result" here because node.setVal() may have done a data type conversion
                   that.form.input.setVal( name, index, dataNodesObj.getVal()[ 0 ] );
               }
           } );
       }
   };

   },{"jquery":"jquery"}],
   "dropdown.jquery":[function(require,module,exports){
   // Copied from Bootstrap

   // DROPDOWN CLASS DEFINITION
   // =========================
   var $ = require( 'jquery' );
   var backdrop = '.dropdown-backdrop';
   var toggle = '[data-toggle=dropdown]';
   var Dropdown = function( element ) {
       $( element ).on( 'click.bs.dropdown', this.toggle );
   };

   Dropdown.prototype.toggle = function( e ) {
       var $this = $( this );

       if ( $this.is( '.disabled, :disabled' ) ) {
           return;
       }

       var $parent = getParent( $this );
       var isActive = $parent.hasClass( 'open' );

       clearMenus();

       if ( !isActive ) {
           if ( 'ontouchstart' in document.documentElement && !$parent.closest( '.navbar-nav' ).length ) {
               // if mobile we use a backdrop because click events don't delegate
               $( '<div class="dropdown-backdrop"/>' ).insertAfter( $( this ) ).on( 'click', clearMenus );
           }

           var relatedTarget = {
               relatedTarget: this
           };
           $parent.trigger( e = $.Event( 'show.bs.dropdown', relatedTarget ) );

           if ( e.isDefaultPrevented() ) {
               return;
           }

           $parent
               .toggleClass( 'open' )
               .trigger( 'shown.bs.dropdown', relatedTarget );

           $this.focus();
       }

       return false;
   };

   Dropdown.prototype.keydown = function( e ) {
       if ( !/^(38|40|27)$/.test( e.keyCode ) ) {
           return;
       }

       var $this = $( this );

       e.preventDefault();
       e.stopPropagation();

       if ( $this.is( '.disabled, :disabled' ) ) {
           return;
       }

       var $parent = getParent( $this );
       var isActive = $parent.hasClass( 'open' );

       if ( !isActive || ( isActive && e.keyCode === 27 ) ) {
           if ( e.which === 27 ) {
               $parent.find( toggle ).focus();
           }
           return $this.click();
       }

       var desc = ' li:not(.divider):visible a';
       var $items = $parent.find( '[role=menu]' + desc + ', [role=listbox]' + desc );

       if ( !$items.length ) {
           return;
       }

       var index = $items.index( $items.filter( ':focus' ) );

       if ( e.keyCode === 38 && index > 0 ) {
           index--; // up
       }
       if ( e.keyCode === 40 && index < $items.length - 1 ) {
           index++; // down
       }
       if ( !~index ) {
           index = 0;
       }

       $items.eq( index ).focus();
   };

   function clearMenus( e ) {
       $( backdrop ).remove();
       $( toggle ).each( function() {
           var $parent = getParent( $( this ) );
           var relatedTarget = {
               relatedTarget: this
           };
           if ( !$parent.hasClass( 'open' ) ) {
               return;
           }
           $parent.trigger( e = $.Event( 'hide.bs.dropdown', relatedTarget ) );
           if ( e.isDefaultPrevented() ) {
               return;
           }
           $parent.removeClass( 'open' ).trigger( 'hidden.bs.dropdown', relatedTarget );
       } );
   }

   function getParent( $this ) {
       var selector = $this.attr( 'data-target' );

       if ( !selector ) {
           selector = $this.attr( 'href' );
           selector = selector && /#[A-Za-z]/.test( selector ) && selector.replace( /.*(?=#[^\s]*$)/, '' ); //strip for ie7
       }

       var $parent = selector && $( selector );

       return $parent && $parent.length ? $parent : $this.parent();
   }


   // DROPDOWN PLUGIN DEFINITION
   // ==========================

   var old = $.fn.dropdown;

   $.fn.dropdown = function( option ) {
       return this.each( function() {
           var $this = $( this );
           var data = $this.data( 'bs.dropdown' );

           if ( !data ) {
               $this.data( 'bs.dropdown', new Dropdown( this ) );
           }
           if ( typeof option === 'string' ) {
               data[ option ].call( $this );
           }
       } );
   };

   $.fn.dropdown.Constructor = Dropdown;


   // DROPDOWN NO CONFLICT
   // ====================

   $.fn.dropdown.noConflict = function() {
       $.fn.dropdown = old;
       return this;
   };


   // APPLY TO STANDARD DROPDOWN ELEMENTS
   // ===================================

   $( document )
       .on( 'click.bs.dropdown.data-api', clearMenus )
       .on( 'click.bs.dropdown.data-api', '.dropdown form', function( e ) {
           e.stopPropagation();
       } )
       .on( 'click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle )
       .on( 'keydown.bs.dropdown.data-api', toggle + ', [role=menu], [role=listbox]', Dropdown.prototype.keydown );

   },{"jquery":"jquery"}],
   "extend":[function(require,module,exports){
   // Extend native objects, aka monkey patching ..... really I see no harm!

   /**
    * Pads a string with prefixed zeros until the requested string length is achieved.
    * @param  {number} digits [description]
    * @return {String|string}        [description]
    */
   String.prototype.pad = function( digits ) {
       var x = this;
       while ( x.length < digits ) {
           x = '0' + x;
       }
       return x;
   };

   /**
    * Converts a native Date UTC String to a RFC 3339-compliant date string with local offsets
    * used in JavaRosa, so it replaces the Z in the ISOstring with a local offset
    * @return {string} a datetime string formatted according to RC3339 with local offset
    */
   Date.prototype.toISOLocalString = function() {
       //2012-09-05T12:57:00.000-04:00 (ODK)
       var offset = {},
           pad2 = function( x ) {
               return ( x < 10 ) ? '0' + x : x;
           };

       if ( this.toString() === 'Invalid Date' ) {
           return this.toString();
       }

       offset.minstotal = this.getTimezoneOffset();
       offset.direction = ( offset.minstotal < 0 ) ? '+' : '-';
       offset.hrspart = pad2( Math.abs( Math.floor( offset.minstotal / 60 ) ) );
       offset.minspart = pad2( Math.abs( Math.floor( offset.minstotal % 60 ) ) );

       return new Date( this.getTime() - ( offset.minstotal * 60 * 1000 ) ).toISOString()
           .replace( 'Z', offset.direction + offset.hrspart + ':' + offset.minspart );
   };

   },{}],
   "fake-translator":[function(require,module,exports){
   'use strict';

   // This is NOT a complete list of all enketo-core UI strings. Use a parser to find
   // all strings. E.g. https://github.com/i18next/i18next-parser
   var SOURCE_STRINGS = {
       "constraint": {
           "invalid": "Value not allowed",
           "required": "This field is required"
       },
       "esri-geopicker": {
           "coordinate-mgrs": "MGRS coordinate",
           "decimal": "decimal",
           "degrees": "degrees, minutes, seconds",
           "latitude-degrees": "latitude (d m s N)",
           "longitude-degrees": "longitude (d m s W)",
           "mgrs": "MGRS",
           "notavailable": "Not Available",
           "utm": "UTM",
           "utm-easting": "easting (m)",
           "utm-hemisphere": "hemisphere",
           "utm-north": "North",
           "utm-northing": "northing (m)",
           "utm-south": "South",
           "utm-zone": "zone"
       },
       "form": {
           "required": "required"
       },
       "geopicker": {
           "accuracy": "accuracy (m)",
           "altitude": "altitude (m)",
           "closepolygon": "close polygon",
           "kmlcoords": "KML coordinates",
           "kmlpaste": "paste KML coordinates here",
           "latitude": "latitude (x.y )",
           "longitude": "longitude (x.y )",
           "points": "points",
           "searchPlaceholder": "search for place or address"
       },
       "selectpicker": {
           "noneselected": "none selected",
           "numberselected": "__number__ selected"
       },
       "widget": {
           "comment": {
               "update": "Update"
           }
       }
   };

   /**
    * Add keys from XSL stylesheets manually so i18next-parser will detect them.
    *
    * t('constraint.invalid');
    * t('constraint.required');
    */

   /**
    * Meant to be replaced by a real translator in the app that consumes enketo-core
    *
    * @param  {String} key translation key
    * @param  {*} key translation options
    * @return {String} translation output
    */
   function t( key, options ) {
       var str = '';
       var target = SOURCE_STRINGS;
       var AR = ' ';
       // crude string getter
       key.split( '.' ).forEach( function( part ) {
           target = target ? target[ part ] : '';
           str = target;
       } );
       // crude interpolator
       options = options || {};
       str = str.replace( /__([^_]+)__/, function( match, p1 ) {
           return options[ p1 ];
       } );

       // Enable line below to switch to fake Arabic, very useful for testing RTL
       // return str.split( "" ).map( function( char, i ) { return AR[ i % AR.length ];} ).join( "" );
       return str;
   }

   module.exports = {
       t: t
   };

   },{}],
   "file-manager":[function(require,module,exports){
   'use strict';
   /**
    * Simple file manager with cross-browser support. That uses the FileReader
    * to create previews. Can be replaced with a more advanced version that
    * obtains files from storage.
    *
    * The replacement should support the same public methods and return the same
    * types.
    */

   var Promise = require( 'lie' );
   var $ = require( 'jquery' );
   var utils = require( './utils' );

   var supported = typeof FileReader !== 'undefined',
       notSupportedAdvisoryMsg = '';

   /**
    * Initialize the file manager .
    * @return {[type]} promise boolean or rejection with Error
    */
   function init() {
       if ( supported ) {
           return Promise.resolve( true );
       } else {
           return Promise.reject( new Error( 'FileReader not supported.' ) );
       }
   }

   /**
    * Whether filemanager is supported in browser
    * @return {Boolean}
    */
   function isSupported() {
       return supported;
   }

   /**
    * Whether the filemanager is waiting for user permissions
    * @return {Boolean} [description]
    */
   function isWaitingForPermissions() {
       return false;
   }

   /**
    * Obtains a url that can be used to show a preview of the file when used
    * as a src attribute.
    *
    * @param  {?string|Object} subject File or filename
    * @return {[type]}         promise url string or rejection with Error
    */
   function getFileUrl( subject ) {
       return new Promise( function( resolve, reject ) {
           var error, reader;

           if ( !subject ) {
               resolve( null );
           } else if ( typeof subject === 'string' ) {
               // TODO obtain from storage
           } else if ( typeof subject === 'object' ) {
               if ( _isTooLarge( subject ) ) {
                   error = new Error( 'File too large' );
                   reject( error );
               } else {
                   reader = new FileReader();
                   reader.onload = function( e ) {
                       resolve( e.target.result );
                   };
                   reader.onerror = function( e ) {
                       reject( error );
                   };
                   reader.readAsDataURL( subject );
               }
           } else {
               reject( new Error( 'Unknown error occurred' ) );
           }
       } );
   }

   /**
    * Obtain files currently stored in file input elements of open record
    * @return {[File]} array of files
    */
   function getCurrentFiles() {
       var file;
       var newFilename;
       var files = [];

       // first get any files inside file input elements
       $( 'form.or input[type="file"]' ).each( function() {
           file = this.files[ 0 ];
           if ( file && file.name ) {
               // Correct file names by adding a unique-ish postfix
               // First create a clone, because the name property is immutable
               // TODO: in the future, when browser support increase we can invoke
               // the File constructor to do this.
               newFilename = utils.getFilename( file, this.dataset.filenamePostfix );
               file = new Blob( [ file ], {
                   type: file.type
               } );
               file.name = newFilename;
               files.push( file );
           }
       } );
       return files;
   }

   /**
    * Placeholder function to check if file size is acceptable.
    *
    * @param  {Blob}  file [description]
    * @return {Boolean}      [description]
    */
   function _isTooLarge( file ) {
       return false;
   }

   module.exports = {
       isSupported: isSupported,
       notSupportedAdvisoryMsg: notSupportedAdvisoryMsg,
       isWaitingForPermissions: isWaitingForPermissions,
       init: init,
       getFileUrl: getFileUrl,
       getCurrentFiles: getCurrentFiles
   };

   },{"jquery":"jquery","lie":"lie","./utils":"utils"}],
   "Form":[function(require,module,exports){
   'use strict';

   var FormModel = require( './Form-model' );
   var $ = require( 'jquery' );
   var Promise = require( 'lie' );
   var utils = require( './utils' );
   var t = require( 'translator' ).t;
   var config = require( 'enketo-config' );
   var inputHelper = require( './input' );
   var repeatModule = require( './repeat' );
   var pageModule = require( './page' );
   var branchModule = require( './branch' );
   var itemsetModule = require( './itemset' );
   var progressModule = require( './progress' );
   var widgetModule = require( './widgets-controller' );
   var languageModule = require( './language' );
   var preloadModule = require( './preload' );
   var outputModule = require( './output' );
   var calculationModule = require( './calculation' );
   require( './plugins' );
   require( './extend' );

   /**
    * Class: Form
    *
    * Most methods are prototype method to facilitate customizations outside of enketo-core.
    *
    * @param {string} formSelector  jquery selector for the form
    * @param {{modelStr: string, ?instanceStr: string, ?submitted: boolean, ?external: <{id: string, xmlStr: string }> }} data data object containing XML model, (partial) XML instance-to-load, external data and flag about whether instance-to-load has already been submitted before.
    * @param { {?webMapId: string}} options form options
    *
    * @constructor
    */

   function Form( formSelector, data, options ) {
       var $form = $( formSelector );

       this.$nonRepeats = {};
       this.options = typeof options !== 'object' ? {} : options;
       if ( typeof this.options.clearIrrelevantImmediately === 'undefined' ) {
           this.options.clearIrrelevantImmediately = true;
       }
       this.view = {
           $: $form,
           html: $form[ 0 ],
           $clone: $form.clone()
       };
       this.model = new FormModel( data );
       this.repeatsPresent = this.view.$.find( '.or-repeat' ).length > 0;
       this.widgetsInitialized = false;
       this.pageNavigationBlocked = false;
   }

   /**
    * Getter and setter functions
    * @type {Object}
    */
   Form.prototype = {
       evaluationCascadeAdditions: [],
       get evaluationCascade() {
           return [
               this.calc.update.bind( this.calc ),
               this.repeats.countUpdate.bind( this.repeats ),
               this.branch.update.bind( this.branch ),
               this.output.update.bind( this.output ),
               this.itemset.update.bind( this.itemset ),
               this.validationUpdate
           ].concat( this.evaluationCascadeAdditions );
       },
       get recordName() {
           return this.view.$.attr( 'name' );
       },
       set recordName( name ) {
           this.view.$.attr( 'name', name );
       },
       get editStatus() {
           return !!this.view.$.data( 'edited' );
       },
       set editStatus( status ) {
           // only trigger edit event once
           if ( status && status !== this.view.$.data( 'edited' ) ) {
               this.view.$.trigger( 'edited.enketo' );
           }
           this.view.$.data( 'edited', status );
       },
       get surveyName() {
           return this.view.$.find( '#form-title' ).text();
       },
       get instanceID() {
           return this.model.instanceID;
       },
       get deprecatedID() {
           return this.model.deprecatedID;
       },
       get instanceName() {
           return this.model.instanceName;
       },
       get version() {
           return this.model.version;
       },
       get encryptionKey() {
           return this.view.$.data( 'base64rsapublickey' );
       },
       get action() {
           return this.view.$.attr( 'action' );
       },
       get method() {
           return this.view.$.attr( 'method' );
       },
   };

   Form.prototype.addModule = function( module ) {
       return Object.create( module, {
           form: {
               value: this
           }
       } );
   };

   /**
    * Function: init
    *
    * Initializes the Form instance (XML Model and HTML View).
    *
    */
   Form.prototype.init = function() {
       var loadErrors = [];
       var that = this;

       loadErrors = loadErrors.concat( this.model.init() );

       if ( typeof this.model === 'undefined' || !( this.model instanceof FormModel ) ) {
           loadErrors.push( 'Form could not be initialized without a model.' );
           return loadErrors;
       }

       // Before initializing form view, passthrough some model events externally
       this.model.$events.on( 'dataupdate', function( event, updated ) {
           that.view.$.trigger( 'dataupdate.enketo', updated );
       } );
       this.model.$events.on( 'removed', function( event, updated ) {
           that.view.$.trigger( 'removed.enketo', updated );
       } );

       this.pages = this.addModule( pageModule );
       this.langs = this.addModule( languageModule );
       this.progress = this.addModule( progressModule );
       this.widgets = this.addModule( widgetModule );
       this.preloads = this.addModule( preloadModule );
       this.branch = this.addModule( branchModule );
       this.repeats = this.addModule( repeatModule );
       this.input = this.addModule( inputHelper );
       this.output = this.addModule( outputModule );
       this.itemset = this.addModule( itemsetModule );
       this.calc = this.addModule( calculationModule );

       try {
           this.preloads.init();

           // before widgets.init (as instanceID used in offlineFilepicker widget)
           // store the current instanceID as data on the form element so it can be easily accessed by e.g. widgets
           this.view.$.data( {
               instanceID: this.model.instanceID
           } );

           // before calc.update!
           this.grosslyViolateStandardComplianceByIgnoringCertainCalcs();
           // before repeats.init to make sure the jr:repeat-count calculation has been evaluated
           this.calc.update();

           // before itemset.update
           this.langs.init();

           // after repeats.init so that template contain role="page" when applicable
           this.pages.init();

           // after radio button data-name setting
           this.repeats.init();

           // after repeats.init
           this.itemset.update();

           // after repeats.init
           this.setAllVals();

           // after setAllVals, after repeats.init

           this.options.input = this.input;
           this.options.pathToAbsolute = this.pathToAbsolute.bind( this );
           this.options.evaluate = this.model.evaluate.bind( this.model );
           this.options.formClasses = utils.toArray( this.view.html.classList );
           this.widgetsInitialized = this.widgets.init( null, this.options );

           // after widgets.init(), and repeats.init()
           this.branch.update();

           // after repeats.init()
           this.output.update();

           // after widgets init to make sure widget handlers are called before
           // after loading existing instance to not trigger an 'edit' event
           this.setEventHandlers();

           // update field calculations again to make sure that dependent
           // field values are calculated
           this.calc.update();

           this.editStatus = false;

           if ( this.options.goTo === true && location.hash ) {
               // if goTo fails (not found), it will return false
               if ( !this.goTo( this.getGoToTarget( location.hash ) ) ) {
                   loadErrors.push( 'Failed to find question "' + location.hash.substring( 1 ) + '" in form. Is it a valid path?' );
               }
           }

           setTimeout( function() {
               that.progress.update();
           }, 0 );

           return loadErrors;
       } catch ( e ) {
           console.error( e );
           loadErrors.push( e.name + ': ' + e.message );
       }

       document.querySelector( 'body' ).scrollIntoView();

       console.debug( 'loadErrors', loadErrors );
       return loadErrors;
   };

   /**
    * Obtains a string of primary instance.
    *
    * @param  {!{include: boolean}=} include optional object items to exclude if false
    * @return {string}        XML string of primary instance
    */

   Form.prototype.getDataStr = function( include ) {
       include = ( typeof include !== 'object' || include === null ) ? {} : include;
       // By default everything is included
       if ( include.irrelevant === false ) {
           return this.getDataStrWithoutIrrelevantNodes();
       }
       return this.model.getStr();
   };

   /**
    * Restores HTML form to pre-initialized state. It is meant to be called before re-initializing with
    * new Form ( .....) and form.init()
    * For this reason, it does not fix event handler, $form, formView.$ etc.!
    * It also does not affect the XML instance!
    */
   Form.prototype.resetView = function() {
       //form language selector was moved outside of <form> so has to be separately removed
       $( '#form-languages' ).remove();
       this.view.$.replaceWith( this.view.$clone );
   };

   /**
    * Implements jr:choice-name
    * TODO: this needs to work for all expressions (relevants, constraints), now it only works for calculated items
    * Ideally this belongs in the form Model, but unfortunately it needs access to the view
    *
    * @param  {[type]} expr       [description]
    * @param  {[type]} resTypeStr [description]
    * @param  {[type]} selector   [description]
    * @param  {[type]} index      [description]
    * @param  {[type]} tryNative  [description]
    * @return {[type]}            [description]
    */
   Form.prototype.replaceChoiceNameFn = function( expr, resTypeStr, selector, index, tryNative ) {
       var value;
       var name;
       var $input;
       var label = '';
       var matches = expr.match( /jr:choice-name\(([^,]+),\s?'(.*?)'\)/ );

       if ( matches ) {
           value = this.model.evaluate( matches[ 1 ], resTypeStr, selector, index, tryNative );
           name = matches[ 2 ].trim();
           $input = this.view.$.find( '[name="' + name + '"]' );

           if ( $input.length > 0 && $input.prop( 'nodeName' ).toLowerCase() === 'select' ) {
               label = $input.find( '[value="' + value + '"]' ).text();
           } else if ( $input.length > 0 && $input.prop( 'nodeName' ).toLowerCase() === 'input' ) {
               label = $input.filter( function() {
                   return $( this ).attr( 'value' ) === value;
               } ).siblings( '.option-label.active' ).text();
           }
           return expr.replace( matches[ 0 ], '"' + label + '"' );
       }
       return expr;
   };

   /**
    *  Uses current state of model to set all the values in the form.
    *  Since not all data nodes with a value have a corresponding input element,
    *  we cycle through the HTML form elements and check for each form element whether data is available.
    */
   Form.prototype.setAllVals = function( $group, groupIndex ) {
       var index;
       var name;
       var value;
       var that = this;
       var selector = ( $group && $group.attr( 'name' ) ) ? $group.attr( 'name' ) : null;

       groupIndex = ( typeof groupIndex !== 'undefined' ) ? groupIndex : null;

       this.model.node( selector, groupIndex ).get().find( '*' ).filter( function() {
           var $node = $( this );
           // only return non-empty leafnodes
           return $node.children().length === 0 && $node.text();
       } ).each( function() {
           var $node = $( this );

           try {
               value = $node.text();
               name = that.model.getXPath( $node.get( 0 ), 'instance' );
               index = that.model.node( name ).get().index( this );
               that.input.setVal( name, index, value );
           } catch ( e ) {
               console.error( e );
               // TODO: Test if this correctly adds to loadErrors
               //loadErrors.push( 'Could not load input field value with name: ' + name + ' and value: ' + value );
               throw new Error( 'Could not load input field value with name: ' + name + ' and value: ' + value );
           }
       } );
       return;
   };


   /**
    * Finds nodes that have attributes with XPath expressions that refer to particular XML elements.
    *
    * @param  {string} attribute The attribute name to search for
    * @param  {?string} filter   The optional filter to append to each selector
    * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
    * @return {jQuery}           A jQuery collection of elements
    */
   Form.prototype.getRelatedNodes = function( attr, filter, updated ) {
       var $collection;
       var $repeat = null;
       var selector = [];
       var that = this;
       var radioCheckNames = [];

       updated = updated || {};
       filter = filter || '';

       // The collection of non-repeat inputs is cached (unchangeable)
       if ( !this.$nonRepeats[ attr ] ) {
           this.$nonRepeats[ attr ] = this.view.$.find( filter + '[' + attr + ']' )
               .parentsUntil( '.or', '.calculation, .question' ).filter( function() {
                   return $( this ).closest( '.or-repeat' ).length === 0;
               } );
       }

       // If the updated node is inside a repeat (and there are multiple repeats present)
       if ( typeof updated.repeatPath !== 'undefined' && updated.repeatIndex >= 0 ) {
           $repeat = this.view.$.find( '.or-repeat[name="' + updated.repeatPath + '"]' ).eq( updated.repeatIndex );
       }

       /**
        * If the update was triggered from a repeat, it improves performance (a lot)
        * to exclude all those repeats that did not trigger it...
        * However, this will break if people are referring to nodes in other
        * repeats such as with /path/to/repeat[3]/node, /path/to/repeat[position() = 3]/node or indexed-repeat(/path/to/repeat/node, /path/to/repeat, 3).
        * We accept that for now.
        **/
       if ( $repeat ) {
           // the non-repeat fields have to be added too, e.g. to update a calculated item with count(to/repeat/node) at the top level
           $collection = this.$nonRepeats[ attr ]
               .add( $repeat );
       } else {
           $collection = this.view.$;
       }

       // add selectors based on specific changed nodes
       // Add selectors based on specific changed nodes
       if ( !updated.nodes || updated.nodes.length === 0 ) {
           selector = selector.concat( [ filter + '[' + attr + ']' ] );
       } else {
           updated.nodes.forEach( function( node ) {
               selector = selector.concat( that.getQuerySelectorsForLogic( filter, attr, node ) );
           } );
           // add all the paths that use the /* selector at end of path
           selector = selector.concat( that.getQuerySelectorsForLogic( filter, attr, '*' ) );
       }

       // TODO: exclude descendents of disabled elements? .find( ':not(:disabled) span.active' )
       return $collection.find( selector.join() )
           .filter( function() {
               var radioCheckName = this.dataset.name;
               // Filter out duplicate radiobuttons and checkboxes
               if ( radioCheckName ) {
                   if ( radioCheckNames.indexOf( radioCheckName ) !== -1 ) {
                       return false;
                   }
                   radioCheckNames.push( radioCheckName );
               }
               return true;
           } );
   };

   /**
    * Crafts an optimized jQuery selector for element attributes that contain an expression with a target node name.
    *
    * @param  {string} filter   The filter to use
    * @param  {string} attr     The attribute to target
    * @param  {string} nodeName The XML nodeName to find
    * @return {string}          The selector
    */
   Form.prototype.getQuerySelectorsForLogic = function( filter, attr, nodeName ) {
       return [
           // The target node name is ALWAYS at the END of a path inside the expression.
           // #1: followed by space
           filter + '[' + attr + '*="/' + nodeName + ' "]',
           // #2: followed by )
           filter + '[' + attr + '*="/' + nodeName + ')"]',
           // #3: followed by , if used as first parameter of multiple parameters
           filter + '[' + attr + '*="/' + nodeName + ',"]',
           // #4: at the end of an expression
           filter + '[' + attr + '$="/' + nodeName + '"]',
           // #5: followed by ] (used in itemset filters)
           filter + '[' + attr + '*="/' + nodeName + ']"]'
       ];
   };

   /**
    * Obtains the XML primary instance as string without nodes that have a relevant
    * that evaluates to false.
    *
    * Though this function may be slow it is slow when it doesn't matter much (upon saving). The
    * alternative is to add some logic to branch.update to mark irrelevant nodes in the model
    * but that would slow down form loading and form traversal when it does matter.
    *
    * @return {string} [description]
    */
   Form.prototype.getDataStrWithoutIrrelevantNodes = function() {
       var that = this;
       var modelClone = new FormModel( this.model.getStr() );
       modelClone.init();

       this.getRelatedNodes( 'data-relevant' ).each( function() {
           var $node = $( this );
           var relevant = that.input.getRelevant( $node );
           var index = that.input.getIndex( $node );
           var path = that.input.getName( $node );
           var context;

           /*
            * Copied from branch.js:
            *
            * If the relevant is placed on a group and that group contains repeats with the same name,
            * but currently has 0 repeats, the context will not be available.
            */
           if ( $node.children( '.or-repeat-info[data-name="' + path + '"]' ).length && !$node.children( '.or-repeat[name="' + path + '"]' ).length ) {
               context = null;
           } else {
               context = path;
           }

           /*
            * If performance becomes an issue, some opportunities are:
            * - check if ancestor is relevant
            * - use cache of branch.update
            * - check for repeatClones to avoid calculating index (as in branch.update)
            */
           if ( context && !that.model.evaluate( relevant, 'boolean', context, index ) ) {
               modelClone.node( context, index ).remove();
           }
       } );

       return modelClone.getStr();
   };

   /**
    * See https://groups.google.com/forum/?fromgroups=#!topic/opendatakit-developers/oBn7eQNQGTg
    * and http://code.google.com/p/opendatakit/issues/detail?id=706
    *
    * This is using an aggressive name attribute selector to also find e.g. name="/../orx:meta/orx:instanceID", with
    * *ANY* namespace prefix.
    *
    * Once the following is complete this function can and should be removed:
    *
    * 1. ODK Collect starts supporting an instanceID preload item (or automatic handling of meta->instanceID without binding)
    * 2. Pyxforms changes the instanceID binding from calculate to preload (or without binding)
    * 3. Formhub has re-generated all stored XML forms from the stored XLS forms with the updated pyxforms
    *
    */
   Form.prototype.grosslyViolateStandardComplianceByIgnoringCertainCalcs = function() {
       var $culprit = this.view.$.find( '[name$="instanceID"][data-calculate]' );
       if ( $culprit.length > 0 ) {
           $culprit.removeAttr( 'data-calculate' );
       }
   };

   Form.prototype.validationUpdate = function( updated ) {
       var $nodes;
       var that = this;

       if ( config.validateContinuously === true ) {
           updated = updated || {};

           $nodes = this.getRelatedNodes( 'data-constraint', '', updated )
               .add( this.getRelatedNodes( 'data-required', '', updated ) );

           $nodes.each( function() {
               that.validateInput( $( this ) );
           } );
       }
   };

   Form.prototype.setEventHandlers = function() {
       var that = this;

       //first prevent default submission, e.g. when text field is filled in and Enter key is pressed
       this.view.$.attr( 'onsubmit', 'return false;' );

       /*
        * workaround for Chrome to clear invalid values right away
        * issue: https://code.google.com/p/chromium/issues/detail?can=2&start=0&num=100&q=&colspec=ID%20Pri%20M%20Iteration%20ReleaseBlock%20Cr%20Status%20Owner%20Summary%20OS%20Modified&groupby=&sort=&id=178437)
        * a workaround was chosen instead of replacing the change event listener to a blur event listener
        * because I'm guessing that Google will bring back the old behaviour.
        */
       this.view.$.on( 'blur', 'input:not([type="text"], [type="radio"], [type="checkbox"])', function() {
           var $input = $( this );
           if ( typeof $input.prop( 'validity' ).badInput !== 'undefined' && $input.prop( 'validity' ).badInput ) {
               $input.val( '' );
           }
       } );

       /*
        * The .file namespace is used in the filepicker to avoid an infinite loop.
        * The listener below catches both change and change.file events.
        */
       this.view.$.on( 'change.file',
           'input:not([readonly]):not(.ignore), select:not([readonly]):not(.ignore), textarea:not([readonly]):not(.ignore)',
           function() {
               var requiredExpr;
               var $input = $( this );
               var n = {
                   path: that.input.getName( $input ),
                   inputType: that.input.getInputType( $input ),
                   xmlType: that.input.getXmlType( $input ),
                   enabled: that.input.isEnabled( $input ),
                   constraint: that.input.getConstraint( $input ),
                   val: that.input.getVal( $input ),
                   required: that.input.getRequired( $input ),
                   index: that.input.getIndex( $input )
               };

               // determine 'required' check if applicable
               if ( n.enabled && n.inputType !== 'hidden' && n.required ) {
                   requiredExpr = n.required;
               }
               // set file input values to the actual name of file (without c://fakepath or anything like that)
               if ( n.val.length > 0 && n.inputType === 'file' && $input[ 0 ].files[ 0 ] && $input[ 0 ].files[ 0 ].size > 0 ) {
                   n.val = utils.getFilename( $input[ 0 ].files[ 0 ], $input[ 0 ].dataset.filenamePostfix );
               }

               that.model.node( n.path, n.index ).setVal( n.val, n.constraint, n.xmlType, requiredExpr, true );

               that.validateInput( $input )
                   .then( function( valid ) {
                       // propagate event externally after internal processing is completed
                       $input.trigger( 'valuechange.enketo', valid );
                   } );
           } );

       // doing this on the focus event may have little effect on performance, because nothing else is happening :)
       this.view.$.on( 'focus fakefocus', 'input:not(.ignore), select:not(.ignore), textarea:not(.ignore)', function( event ) {
           // update the form progress status
           that.progress.update( event.target );
       } );

       this.model.$events.on( 'dataupdate', function( event, updated ) {
           that.evaluationCascade.forEach( function( fn ) {
               fn.call( that, updated );
           } );
           // edit is fired when the model changes after the form has been initialized
           that.editStatus = true;
       } );

       this.view.$.on( 'addrepeat', function( event, index ) {
           var $clone = $( event.target );
           var updated = {
               repeatPath: $clone.attr( 'name' ),
               repeatIndex: index,
               cloned: true
           };
           // Set defaults of added repeats in Form, setAllVals does not trigger change event
           that.setAllVals( $clone, index );
           // Initialize calculations, branch, itemset, output inside that repeat.
           that.evaluationCascade.forEach( function( fn ) {
               fn.call( that, updated );
           } );
           that.progress.update();
       } );

       this.view.$.on( 'removerepeat', function() {
           that.progress.update();
       } );

       this.view.$.on( 'changelanguage', function() {
           that.output.update();
       } );
   };

   Form.prototype.setValid = function( $node, type ) {
       var classes = ( type ) ? 'invalid-' + type : 'invalid-constraint invalid-required';
       this.input.getWrapNodes( $node ).removeClass( classes );
   };

   Form.prototype.setInvalid = function( $node, type ) {
       type = type || 'constraint';

       if ( config.validatePage === false && this.isValid( $node ) ) {
           this.blockPageNavigation();
       }

       this.input.getWrapNodes( $node ).addClass( 'invalid-' + type );
   };

   /**
    * Blocks page navigation for a short period.
    * This can be used to ensure that the user sees a new error message before moving to another page.
    *
    * @return {[type]} [description]
    */
   Form.prototype.blockPageNavigation = function() {
       var that = this;
       this.pageNavigationBlocked = true;
       window.clearTimeout( this.blockPageNavigationTimeout );
       this.blockPageNavigationTimeout = window.setTimeout( function() {
           that.pageNavigationBlocked = false;
       }, 600 );
   };

   /**
    * Checks whether the question is not currently marked as invalid. If no argument is provided, it checks the whole form.
    *
    * @return {!boolean} whether the question/form is not marked as invalid.
    */
   Form.prototype.isValid = function( $node ) {
       var $question;
       if ( $node ) {
           $question = this.input.getWrapNodes( $node );
           return !$question.hasClass( 'invalid-required' ) && !$question.hasClass( 'invalid-constraint' );
       }
       return this.view.$.find( '.invalid-required, .invalid-constraint' ).length === 0;
   };

   Form.prototype.clearIrrelevant = function() {
       this.branch.update( null, true );
   };

   /**
    * Clears all irrelevant question values if necessary and then
    * validates all enabled input fields after first resetting everything as valid.
    *
    * @return {Promise} wrapping {boolean} whether the form contains any errors
    */
   Form.prototype.validateAll = function() {
       var that = this;
       // to not delay validation unneccessarily we only clear irrelevants if necessary
       if ( this.options.clearIrrelevantImmediately === false ) {
           this.clearIrrelevant();
       }

       return this.validateContent( this.view.$ )
           .then( function( valid ) {
               that.view.$.trigger( 'validationcomplete.enketo' );
               return valid;
           } );
   };
   /**
    * Alias of validateAll
    */
   Form.prototype.validate = Form.prototype.validateAll;


   /**
    * Validates all enabled input fields in the supplied container, after first resetting everything as valid.
    * @return {Promise} wrapping {boolean} whether the container contains any errors
    */
   Form.prototype.validateContent = function( $container ) {
       var $firstError;
       var that = this;

       //can't fire custom events on disabled elements therefore we set them all as valid
       $container.find( 'fieldset:disabled input, fieldset:disabled select, fieldset:disabled textarea, ' +
           'input:disabled, select:disabled, textarea:disabled' ).each( function() {
           that.setValid( $( this ) );
       } );

       var validations = $container.find( '.question' ).addBack( '.question' ).map( function() {
           // only trigger validate on first input and use a **pure CSS** selector (huge performance impact)
           var $elem = $( this )
               .find( 'input:not(.ignore):not(:disabled), select:not(.ignore):not(:disabled), textarea:not(.ignore):not(:disabled)' );
           if ( $elem.length === 0 ) {
               return Promise.resolve();
           }
           return that.validateInput( $elem.eq( 0 ) );
       } ).toArray();

       return Promise.all( validations )
           .then( function() {
               $firstError = $container
                   .find( '.invalid-required, .invalid-constraint' )
                   .addBack( '.invalid-required, .invalid-constraint' )
                   .eq( 0 );

               if ( $firstError.length > 0 ) {
                   that.goTo( $firstError[ 0 ] );
               }
               return $firstError.length === 0;
           } )
           .catch( function( e ) {
               // fail whole-form validation if any of the question
               // validations threw.
               return false;
           } );
   };

   Form.prototype.pathToAbsolute = function( targetPath, contextPath ) {
       var target;

       if ( targetPath.indexOf( '/' ) === 0 ) {
           return targetPath;
       }

       // index is irrelevant (no positions in returned path)
       target = this.model.evaluate( targetPath, 'node', contextPath, 0, true );

       return this.model.getXPath( target, 'instance', false );
   };

   /**
    * Validates question values.
    *
    * @param  {jQuery} $input    [description]
    * @return {Promise}           [description]
    */
   Form.prototype.validateInput = function( $input ) {
       var that = this;
       var getValidationResult;
       // All relevant properties, except for the **very expensive** index property
       // There is some scope for performance improvement by determining other properties when they
       // are needed, but that may not be so significant.
       var n = {
           path: this.input.getName( $input ),
           inputType: this.input.getInputType( $input ),
           xmlType: this.input.getXmlType( $input ),
           enabled: this.input.isEnabled( $input ),
           constraint: this.input.getConstraint( $input ),
           calculation: this.input.getCalculation( $input ),
           required: this.input.getRequired( $input ),
           readonly: this.input.getReadonly( $input ),
           val: this.input.getVal( $input )
       };
       // No need to validate, **nor send validation events**. Meant for simple empty "notes" only.
       if ( n.readonly && !n.val && !n.required && !n.constraint && !n.calculation ) {
           return Promise.resolve();
       }

       // The enabled check serves a purpose only when an input field itself is marked as enabled but its parent fieldset is not.
       // If an element is disabled mark it as valid (to undo a previously shown branch with fields marked as invalid).
       if ( n.enabled && n.inputType !== 'hidden' ) {
           // Only now, will we determine the index.
           n.ind = this.input.getIndex( $input );
           getValidationResult = this.model.node( n.path, n.ind ).validate( n.constraint, n.required, n.xmlType );
       } else {
           getValidationResult = Promise.resolve( {
               requiredValid: true,
               constraintValid: true
           } );
       }

       return getValidationResult
           .then( function( result ) {
               var previouslyInvalid = false;
               var passed = result.requiredValid !== false && result.constraintValid !== false;

               if ( n.inputType !== 'hidden' ) {
                   // Check current UI state
                   n.$q = that.input.getWrapNodes( $input );
                   n.$required = n.$q.find( '.required' );
                   previouslyInvalid = n.$q.hasClass( 'invalid-required' ) || n.$q.hasClass( 'invalid-constraint' );

                   // Update UI
                   if ( result.requiredValid === false ) {
                       that.setValid( $input, 'constraint' );
                       that.setInvalid( $input, 'required' );
                       n.$required.removeClass( 'hide' );
                   } else {
                       that.updateRequiredVisibility( n );

                       if ( result.constraintValid === false ) {
                           that.setValid( $input, 'required' );
                           that.setInvalid( $input, 'constraint' );
                       } else {
                           that.setValid( $input, 'constraint' );
                           that.setValid( $input, 'required' );
                       }
                   }
               }
               // Send invalidated event
               if ( !passed && !previouslyInvalid ) {
                   $input.trigger( 'invalidated.enketo' );
               }
               return passed;
           } )
           .catch( function( e ) {
               console.error( 'validation error', e );
               that.setInvalid( $input, 'constraint' );
               throw e;
           } );
   };

   /**
    * Extracted as separate function for the purpose of overriding it in custom apps.
    * @param  {{$required: jQuery collection, path: string, ind: number, required: string}} n [description]
    */
   Form.prototype.updateRequiredVisibility = function( n ) {
       // Show/hide the asterisk of dynamic required expressions
       // This is only 'realtime' with `validateContinuously: true`
       if ( n.required ) {
           n.$required.toggleClass( 'hide', !this.model.node( n.path, n.ind ).isRequired( n.required ) );
       }
   };


   Form.prototype.getGoToTarget = function( hash ) {
       var path;
       var hits;
       var modelNode;
       var target;
       var intermediateTarget;
       var selector = '';
       var repeatRegEx = /([^\[]+)\[(\d+)\]([^\[]*$)?/g;

       if ( !hash ) {
           return;
       }

       path = hash.substr( 1 );
       modelNode = this.model.node( path ).get().get( 0 );

       if ( !modelNode ) {
           return;
       }

       // Convert to absolute path, while maintaining positions.
       path = this.model.getXPath( modelNode, 'instance', true );

       // Not inside a cloned repeat.
       target = this.view.html.querySelector( '[name="' + path + '"]' );

       // If inside a cloned repeat (i.e. a repeat that is not first-in-series)
       if ( !target ) {
           intermediateTarget = this.view.html;
           while ( ( hits = repeatRegEx.exec( path ) ) !== null && intermediateTarget ) {
               selector += hits[ 1 ];
               intermediateTarget = intermediateTarget
                   .querySelectorAll( '[name="' + selector + '"], [data-name="' + selector + '"]' )[ hits[ 2 ] ];
               if ( intermediateTarget && hits[ 3 ] ) {
                   selector += hits[ 3 ];
                   intermediateTarget = intermediateTarget
                       .querySelector( '[name="' + selector + '"],[data-name="' + selector + '"]' );
               }
               target = intermediateTarget;
           }
       }

       return target ? this.input.getWrapNodes( $( target ) ).get( 0 ) : target;
   };


   /**
    * Scrolls to a HTML Element, flips to the page it is on and focuses on the nearest form control.
    *
    * @param  {HTMLElement} target A HTML element to scroll to
    */
   Form.prototype.goTo = function( target ) {
       if ( target ) {
           if ( this.pages.active ) {
               // Flip to page
               this.pages.flipToPageContaining( $( target ) );
           }
           // check if the nearest question or group is hidden after page flip (e.g. by being irrelevant)
           if ( $( target ).closest( '.question, .or-group, .or-group-data' ).is( ':hidden' ) ) {
               // It is up to the apps to decide what to do with this event.
               $( target ).trigger( 'gotohidden.enketo' );
           }
           // Scroll to element
           target.scrollIntoView();
           // Focus on the first non .ignore form control
           // If the element is hidden (e.g. because it's been replaced by a widget),
           // the focus event will not fire, so we also trigger an applyfocus event that widgets can listen for.
           $( target.querySelector( 'input:not(.ignore), textarea:not(.ignore), select:not(.ignore)' ) )
               .trigger( 'focus' ).trigger( 'applyfocus' );
       }
       return !!target;
   };

   /**
    * Static method to obtain required enketo-transform version direct from class.
    */
   Form.getRequiredTransformerVersion = function() {
       console.warn( 'Form.getRequiredTransformerVersion() is deprecated, use Form.requiredTransformerVersion' );
       return Form.requiredTransformerVersion;
   };
   Form.requiredTransformerVersion = '1.17.2';

   module.exports = Form;

   // The deprecated methods below to be removed for version 5.0.0:
   /**
    * @deprecated
    */
   Form.prototype.getInstanceID = function() {
       console.warn( 'form.getInstanceID() is deprecated, use form.instanceID instead' );
       return this.instanceID;
   };
   /**
    * @deprecated
    */
   Form.prototype.getDeprecatedID = function() {
       console.warn( 'form.getDeprecatedID() is deprecated, use form.deprecatedID instead' );
       return this.deprecatedID;
   };
   /**
    * @deprecated
    */
   Form.prototype.getInstanceName = function() {
       console.warn( 'form.getModel() is deprecated, use form.instanceName instead' );
       return this.instanceName;
   };
   /**
    * @deprecated
    */
   Form.prototype.getVersion = function() {
       console.warn( 'form.getVersion() is deprecated, use form.version instead' );
       return this.version;
   };
   /**
    * @deprecated
    */
   Form.prototype.getEncryptionKey = function() {
       console.warn( 'form.getEncryptionKey() is deprecated, use form.encryptionKey instead' );
       return this.encryptionKey;
   };
   /**
    * @deprecated
    */
   Form.prototype.getAction = function() {
       console.warn( 'form.getAction() is deprecated, use form.action instead' );
       return this.action;
   };
   /**
    * @deprecated
    */
   Form.prototype.getMethod = function() {
       console.warn( 'form.getMethod() is deprecated, use form.method instead' );
       return this.method;
   };
   /**
    * @deprecated
    */
   Form.prototype.getModel = function() {
       console.warn( 'form.getModel() is deprecated, use form.model instead' );
       return this.model;
   };
   /**
    * @deprecated
    */
   Form.prototype.getView = function() {
       console.warn( 'form.getView() is deprecated, use form.view instead' );
       return this.view;
   };
   /**
    * @deprecated
    */
   Form.prototype.getRecordName = function() {
       console.warn( 'form.getRecordName() is deprecated, use form.recordName instead' );
       return this.recordName;
   };
   /**
    * @deprecated
    */
   Form.prototype.setRecordName = function( name ) {
       console.warn( 'form.setRecordName() is deprecated, use form.recordName="val" instead' );
       this.recordName = name;
   };
   /**
    * @deprecated
    */
   Form.prototype.setEditStatus = function( status ) {
       console.warn( 'form.setEditStatus() is deprecated, use form.editStatus="val" instead' );
       this.editStatus = status;
   };
   /**
    * @deprecated
    */
   Form.prototype.getEditStatus = function() {
       console.warn( 'form.getEditStatus() is deprecated, use form.editStatus instead' );
       return this.editStatus;
   };
   /**
    * @deprecated
    */
   Form.prototype.getSurveyName = function() {
       console.warn( 'form.getSurveyName() is deprecated, use form.editStatus instead' );
       return this.surveyName;
   };

   },{"jquery":"jquery","./Form-model":"Form-model","lie":"lie","./utils":"utils","translator":"fake-translator","enketo-config":"text!enketo-config","./input":"input","./repeat":"repeat","./page":"page","./branch":"branch","./itemset":"itemset","./progress":"progress","./widgets-controller":"widgets-controller","./language":"language","./preload":"preload","./output":"output","./calculation":"calculation","./plugins":"plugins","./extend":"extend"}],
   "Form-logic-error":[function(require,module,exports){
   'use strict';

   function FormLogicError( message ) {
       this.message = message || 'unknown';
       this.name = 'FormLogicError';
       this.stack = ( new Error() ).stack;
   }

   FormLogicError.prototype = Object.create( Error.prototype );
   FormLogicError.prototype.constructor = FormLogicError;

   module.exports = FormLogicError;

   },{}],
   "Form-model":[function(require,module,exports){
   'use strict';


   var MergeXML = require( 'mergexml/mergexml' );
   var utils = require( './utils' );
   var $ = require( 'jquery' );
   var Promise = require( 'lie' );
   var FormLogicError = require( './Form-logic-error' );
   var config = require( 'enketo-config' );
   var types = require( './types' );
   var REPEAT_COMMENT_PREFIX = 'repeat:/';
   var INSTANCE = /instance\([\'|\"]([^\/:\s]+)[\'|\"]\)/g;
   var OPENROSA = /(decimal-date-time\(|pow\(|indexed-repeat\(|format-date\(|coalesce\(|join\(|max\(|min\(|random\(|substr\(|int\(|uuid\(|regex\(|now\(|today\(|date\(|if\(|boolean-from-string\(|checklist\(|selected\(|selected-at\(|round\(|area\(|position\([^\)])/;
   var OPENROSA_XFORMS_NS = 'http://openrosa.org/xforms';
   var JAVAROSA_XFORMS_NS = 'http://openrosa.org/javarosa';
   var ENKETO_XFORMS_NS = 'http://enketo.org/xforms';
   require( './plugins' );
   require( './extend' );
   var FormModel;
   var Nodeset;

   /**
    * Class dealing with the XML Model of a form
    *
    * @constructor
    * @param {{modelStr: string, ?instanceStr: string, ?external: <{id: string, xmlStr: string }>, ?submitted: boolean }} data:
    *                            data object containing XML model,
    *                            (partial) XML instance to load,
    *                            external data array
    *                            flag to indicate whether data was submitted before
    * @param {?{?full:boolean}} options Whether to initialize the full model or only the primary instance
    */
   FormModel = function( data, options ) {

       if ( typeof data === 'string' ) {
           data = {
               modelStr: data
           };
       }

       data.external = data.external || [];
       data.submitted = ( typeof data.submitted !== 'undefined' ) ? data.submitted : true;
       options = options || {};
       options.full = ( typeof options.full !== 'undefined' ) ? options.full : true;

       this.$events = $( '<div/>' );
       this.convertedExpressions = {};
       this.templates = {};
       this.loadErrors = [];

       this.data = data;
       this.options = options;
       this.namespaces = {};
   };

   /**
    * Getter and setter functions
    * @type {Object}
    */
   FormModel.prototype = {
       get version() {
           return this.evaluate( '/node()/@version', 'string', null, null, true );
       },
       /**
        * Gets the instance ID
        *
        * @return {string} instanceID
        */
       get instanceID() {
           return this.getMetaNode( 'instanceID' ).getVal()[ 0 ];
       },
       /**
        * Gets the deprecated ID
        *
        * @return {string} deprecatedID
        */
       get deprecatedID() {
           return this.getMetaNode( 'deprecatedID' ).getVal()[ 0 ] || '';
       },
       /**
        * Gets the instance Name
        *
        * @return {string} instanceID
        */
       get instanceName() {
           return this.getMetaNode( 'instanceName' ).getVal()[ 0 ];
       },
   };

   /**
    * Initializes FormModel
    */
   FormModel.prototype.init = function() {
       var id;
       var i;
       var instanceDoc;
       var secondaryInstanceChildren;
       var that = this;

       /**
        * Default namespaces (on a primary instance, instance child, model) would create a problem using the **native** XPath evaluator.
        * It wouldn't find any regular /path/to/nodes. The solution is to ignore these by renaming these attributes to data-xmlns.
        *
        * If the regex is later deemed too aggressive, it could target the model, primary instance and primary instance child only, after creating an XML Document.
        */
       this.data.modelStr = this.data.modelStr.replace( /\s(xmlns\=("|')[^\s\>]+("|'))/g, ' data-$1' );

       if ( !this.options.full ) {
           // Strip all secondary instances from string before parsing
           // This regex works because the model never includes itext in Enketo
           this.data.modelStr = this.data.modelStr.replace( /^(<model\s*><instance((?!<instance).)+<\/instance\s*>\s*)(<instance.+<\/instance\s*>)*/, '$1' );
       }

       // Create the model
       try {
           id = 'model';
           // the default model
           this.xml = $.parseXML( this.data.modelStr );
           // add external data to model
           this.data.external.forEach( function( instance ) {
               id = 'instance "' + instance.id + '"' || 'instance unknown';
               instanceDoc = that.getSecondaryInstance( instance.id );
               // remove any existing content that is just an XLSForm hack to pass ODK Validate
               secondaryInstanceChildren = instanceDoc.childNodes;
               for ( i = secondaryInstanceChildren.length - 1; i >= 0; i-- ) {
                   instanceDoc.removeChild( secondaryInstanceChildren[ i ] );
               }
               instanceDoc.appendChild( $.parseXML( instance.xmlStr ).firstChild );
           } );

           // TODO: in the future, we should search for jr://instance/session and
           // populate that one. This is just moving in that direction to implement preloads.
           this.createSession( '__session', this.data.session );
       } catch ( e ) {
           console.error( 'parseXML error' );
           this.loadErrors.push( 'Error trying to parse XML ' + id + '. ' + e.message );
       }

       // Initialize/process the model
       if ( this.xml ) {
           try {
               this.$ = $( this.xml );
               this.hasInstance = !!this.xml.querySelector( 'model > instance' );
               this.rootElement = this.xml.querySelector( 'instance > *' ) || this.xml.documentElement;
               this.setNamespaces();

               // Check if instanceID is present
               if ( !this.getMetaNode( 'instanceID' ).get().get( 0 ) ) {
                   that.loadErrors.push( 'Invalid primary instance. Missing instanceID node.' );
               }

               // Check if all secondary instances with an external source have been populated
               this.$.find( 'model > instance[src]:empty' ).each( function( index, instance ) {
                   that.loadErrors.push( 'External instance "' + $( instance ).attr( 'id' ) + '" is empty.' );
               } );

               this.trimValues();
               this.cloneAllTemplates();
               this.extractTemplates();
           } catch ( e ) {
               console.error( e );
               this.loadErrors.push( e.name + ': ' + e.message );
           }
           // Merge an existing instance into the model, AFTER templates have been removed
           try {
               id = 'record';
               if ( this.data.instanceStr ) {
                   this.mergeXml( this.data.instanceStr );
               }
               // Set the two most important meta fields before any field 'dataupdate' event fires.
               this.setInstanceIdAndDeprecatedId();
           } catch ( e ) {
               console.error( e );
               this.loadErrors.push( 'Error trying to parse XML ' + id + '. ' + e.message );
           }
       }

       return this.loadErrors;
   };

   FormModel.prototype.createSession = function( id, sessObj ) {
       var instance;
       var session;
       var model = this.xml.querySelector( 'model' );
       var fixedProps = [ 'deviceid', 'username', 'email', 'phonenumber', 'simserial', 'subscriberid' ];
       if ( !model ) {
           return;
       }

       sessObj = ( typeof sessObj === 'object' ) ? sessObj : {};
       instance = model.querySelector( 'instance[id="' + id + '"]' );

       if ( !instance ) {
           instance = $.parseXML( '<instance id="' + id + '"/>' ).documentElement;
           this.xml.adoptNode( instance );
           model.appendChild( instance );
       }

       // fixed: /sesssion/context properties
       fixedProps.forEach( function( prop ) {
           sessObj[ prop ] = sessObj[ prop ] || utils.readCookie( '__enketo_meta_' + prop ) || prop + ' not found';
       } );

       session = $.parseXML( '<session><context>' +
           fixedProps.map( function( prop ) {
               return '<' + prop + '>' + sessObj[ prop ] + '</' + prop + '>';
           } ) +
           '</context></session>' ).documentElement;

       // TODO: custom properties could be added to /session/user/data or to /session/data

       this.xml.adoptNode( session );
       instance.appendChild( session );
   };

   /**
    * For some unknown reason we cannot use doc.getElementById(id) or doc.querySelector('#'+id)
    * in IE11. This function is a replacement for this specifically to find a secondary instance.
    *
    * @param  {string} id [description]
    * @return {Element}    [description]
    */
   FormModel.prototype.getSecondaryInstance = function( id ) {
       var instanceEl;

       [].slice.call( this.xml.querySelectorAll( 'model > instance' ) ).some( function( el ) {
           var idAttr = el.getAttribute( 'id' );
           if ( idAttr === id ) {
               instanceEl = el;
               return true;
           } else {
               return false;
           }
       } );

       return instanceEl;
   };



   /**
    * Returns a new Nodeset instance
    *
    * @param {(string|null)=} selector - [type/description]
    * @param {(string|number|null)=} index    - [type/description]
    * @param {(Object|null)=} filter   - [type/description]
    * @param filter.onlyLeaf
    * @param filter.noEmpty
    * @return {Nodeset}
    */
   FormModel.prototype.node = function( selector, index, filter ) {
       return new Nodeset( selector, index, filter, this );
   };

   /**
    * Alternative adoptNode on IE11 (http://stackoverflow.com/questions/1811116/ie-support-for-dom-importnode)
    */
   FormModel.prototype.importNode = function( node, allChildren ) {
       var i;
       var il;
       switch ( node.nodeType ) {
           case document.ELEMENT_NODE:
               var newNode = document.createElementNS( node.namespaceURI, node.nodeName );
               if ( node.attributes && node.attributes.length > 0 ) {
                   for ( i = 0, il = node.attributes.length; i < il; i++ ) {
                       var attr = node.attributes[ i ];
                       if ( attr.namespaceURI ) {
                           newNode.setAttributeNS( attr.namespaceURI, attr.nodeName, node.getAttributeNS( attr.namespaceURI, attr.localName ) );
                       } else {
                           newNode.setAttribute( attr.nodeName, node.getAttribute( attr.nodeName ) );
                       }
                   }
               }
               if ( allChildren && node.childNodes && node.childNodes.length > 0 ) {
                   for ( i = 0, il = node.childNodes.length; i < il; i++ ) {
                       newNode.appendChild( this.importNode( node.childNodes[ i ], allChildren ) );
                   }
               }
               return newNode;
           case document.TEXT_NODE:
           case document.CDATA_SECTION_NODE:
           case document.COMMENT_NODE:
               return document.createTextNode( node.nodeValue );
       }
   };

   /**
    * Merges an XML instance string into the XML Model
    *
    * @param  {string} recordStr The XML record as string
    * @param  {string} modelDoc  The XML model to merge the record into
    */
   FormModel.prototype.mergeXml = function( recordStr ) {
       var modelInstanceChildStr;
       var merger;
       var modelInstanceEl;
       var modelInstanceChildEl;
       var mergeResultDoc;
       var that = this;
       var templateEls;
       var record;
       var $record;

       if ( !recordStr ) {
           return;
       }

       modelInstanceEl = this.xml.querySelector( 'instance' );
       modelInstanceChildEl = this.xml.querySelector( 'instance > *' ); // do not use firstChild as it may find a #textNode

       if ( !modelInstanceChildEl ) {
           throw new Error( 'Model is corrupt. It does not contain a childnode of instance' );
       }

       /**
        * A Namespace merge problem occurs when ODK decides to invent a new namespace for a submission
        * that is different from the XForm model namespace... So we just remove this nonsense.
        */
       recordStr = recordStr.replace( /\s(xmlns\=("|')[^\s\>]+("|'))/g, '' );
       /**
        * Comments aren't merging in document order (which would be impossible also).
        * This may mess up repeat functionality, so until we actually need
        * comments, we simply remove them (multiline comments are probably not removed, but we don't care about them).
        */
       recordStr = recordStr.replace( /<!--[^>]*-->/g, '' );
       record = $.parseXML( recordStr );
       $record = $( record );

       /**
        * Normally records will not contain the special "jr:template" attribute. However, we should still be able to deal with
        * this if they do, including the old hacked non-namespaced "template" attribute.
        * https://github.com/enketo/enketo-core/issues/376
        *
        * The solution if these are found is to delete the node.
        *
        * Since the record is not a FormModel instance we revert to a very aggressive querySelectorAll that selects all
        * nodes with a template attribute name IN ANY NAMESPACE.
        */

       templateEls = record.querySelectorAll( '[*|template]' );

       for ( var i = 0; i < templateEls.length; i++ ) {
           // IE11 has no remove method, so we use jQuery
           $( templateEls[ i ] ).remove();
       }

       /**
        * To comply with quirky behaviour of repeats in XForms, we manually create the correct number of repeat instances
        * before merging. This resolves these two issues:
        *  a) Multiple repeat instances in record are added out of order when merged into a record that contains fewer
        *     repeat instances, see https://github.com/kobotoolbox/enketo-express/issues/223
        *  b) If a repeat node is missing from a repeat instance (e.g. the 2nd) in a record, and that repeat instance is not
        *     in the model, that node will be missing in the result.
        */
       $record.find( '*' ).each( function() {
           var node = this;
           var repeatPath;
           var repeatIndex = 0;
           var positionedPath;
           var repeatParts;
           try {
               if ( that.getRepeatIndex( node ) > 0 ) {

                   repeatPath = that.getXPath( node, 'instance', false );
                   positionedPath = that.getXPath( node, 'instance', true );

                   if ( !that.evaluate( positionedPath, 'node', null, null, true ) ) {
                       repeatParts = positionedPath.match( /([^\[]+)\[(\d+)\]/g );
                       // if the positionedPath has two non-0 repeat indices, avoid cloning out of order
                       if ( repeatParts && repeatParts.length > 1 ) {
                           // repeatIndex of immediate parent repeat of deepest nested repeat in positionedPath
                           repeatIndex = repeatParts[ repeatParts.length - 2 ].match( /\[(\d+)\]/ )[ 1 ] - 1;
                       }
                       that.cloneRepeat( repeatPath, repeatIndex, true );
                   }
               }
           } catch ( e ) {
               console.log( 'Ignored error:', e );
           }
       } );

       /**
        * Any default values in the model, may have been emptied in the record.
        * MergeXML will keep those default values, which would be bad, so we manually clear defaults before merging.
        */
       // first find all empty leaf nodes in record
       $record.find( '*' ).filter( function() {
           var node = this;
           var val = node.textContent;
           return node.childNodes.length === 0 && val.trim().length === 0;
       } ).each( function() {
           var path = that.getXPath( this, 'instance', true );
           // find the corresponding node in the model, and set value to empty
           that.node( path, 0 ).setVal( '' );
       } );

       merger = new MergeXML( {
           join: false
       } );

       modelInstanceChildStr = ( new XMLSerializer() ).serializeToString( modelInstanceChildEl );
       recordStr = ( new XMLSerializer() ).serializeToString( record );

       // first the model, to preserve DOM order of that of the default instance
       merger.AddSource( modelInstanceChildStr );
       // then merge the record into the model
       merger.AddSource( recordStr );

       if ( merger.error.code ) {
           throw new Error( merger.error.text );
       }

       /**
        * Beware: merge.Get(0) returns an ActiveXObject in IE11. We turn this
        * into a proper XML document by parsing the XML string instead.
        */
       mergeResultDoc = $.parseXML( merger.Get( 1 ) );

       // remove the primary instance  childnode from the original model
       this.xml.querySelector( 'instance' ).removeChild( modelInstanceChildEl );
       // checking if IE
       if ( global.navigator.userAgent.indexOf( 'Trident/' ) >= 0 ) {
           // IE not support adoptNode
           modelInstanceChildEl = this.importNode( mergeResultDoc.documentElement, true );
       } else {
           // adopt the merged instance childnode
           modelInstanceChildEl = this.xml.adoptNode( mergeResultDoc.documentElement, true );
       }
       // append the adopted node to the primary instance
       modelInstanceEl.appendChild( modelInstanceChildEl );
       // reset the rootElement
       this.rootElement = modelInstanceChildEl;

   };

   /**
    * Creates an XPath from a node
    * @param { XMLElement} node XML node
    * @param  {string=} rootNodeName   if absent the root is #document
    * @param  {boolean=} includePosition whether or not to include the positions /path/to/repeat[2]/node
    * @return {string}                 XPath
    */
   FormModel.prototype.getXPath = function( node, rootNodeName, includePosition ) {
       var index;
       var steps = [];
       var position = '';
       var nodeName = node.nodeName;
       var parent = node.parentNode;
       var parentName = parent.nodeName;

       rootNodeName = rootNodeName || '#document';
       includePosition = includePosition || false;

       if ( includePosition ) {
           index = this.getRepeatIndex( node );
           if ( index > 0 ) {
               position = '[' + ( index + 1 ) + ']';
           }
       }

       steps.push( nodeName + position );

       while ( parent && parentName !== rootNodeName && parentName !== '#document' ) {
           if ( includePosition ) {
               index = this.getRepeatIndex( parent );
               position = ( index > 0 ) ? '[' + ( index + 1 ) + ']' : '';
           }
           steps.push( parentName + position );
           parent = parent.parentNode;
           parentName = parent.nodeName;
       }

       return '/' + steps.reverse().join( '/' );
   };

   /**
    * Obtains the index of a repeat instance within its own series.
    *
    * @param  {[type]} node [description]
    * @return {[type]}      [description]
    */
   FormModel.prototype.getRepeatIndex = function( node ) {
       var index = 0;
       var nodeName = node.nodeName;
       var prevSibling = node.previousSibling;

       while ( prevSibling ) {
           // ignore any sibling text and comment nodes (e.g. whitespace with a newline character)
           if ( prevSibling.nodeName && prevSibling.nodeName === nodeName ) {
               index++;
           }
           prevSibling = prevSibling.previousSibling;
       }

       return index;
   };

   /**
    * Trims values
    *
    */
   FormModel.prototype.trimValues = function() {
       this.node( null, null, {
           noEmpty: true
       } ).get().each( function() {
           this.textContent = this.textContent.trim();
       } );
   };

   /**
    * [deprecateId description]
    * @return {[type]} [description]
    */
   FormModel.prototype.setInstanceIdAndDeprecatedId = function() {
       var instanceIdObj;
       var instanceIdEl;
       var deprecatedIdEl;
       var metaEl;
       var instanceIdExistingVal;

       instanceIdObj = this.getMetaNode( 'instanceID' );
       instanceIdEl = instanceIdObj.get().get( 0 );
       instanceIdExistingVal = instanceIdObj.getVal()[ 0 ];

       if ( this.data.instanceStr && this.data.submitted ) {
           deprecatedIdEl = this.getMetaNode( 'deprecatedID' ).get().get( 0 );

           // set the instanceID value to empty
           instanceIdEl.textContent = '';

           // add deprecatedID node if necessary
           if ( !deprecatedIdEl ) {
               deprecatedIdEl = $.parseXML( '<deprecatedID/>' ).documentElement;
               this.xml.adoptNode( deprecatedIdEl );
               metaEl = this.xml.querySelector( '* > meta' );
               metaEl.appendChild( deprecatedIdEl );
           }
       }

       if ( !instanceIdObj.getVal()[ 0 ] ) {
           instanceIdObj.setVal( this.evaluate( 'concat("uuid:", uuid())', 'string' ) );
       }

       // after setting instanceID, give deprecatedID element the old value of the instanceId
       // ensure dataupdate event fires by using setVal
       if ( deprecatedIdEl ) {
           this.getMetaNode( 'deprecatedID' ).setVal( instanceIdExistingVal );
       }
   };

   /**
    * Creates a custom XPath Evaluator to be used for XPath Expresssions that contain custom
    * OpenRosa functions or for browsers that do not have a native evaluator.
    */
   FormModel.prototype.bindJsEvaluator = require( './xpath-evaluator-binding' );

   FormModel.prototype.getMetaNode = function( localName ) {
       var orPrefix = this.getNamespacePrefix( OPENROSA_XFORMS_NS );
       var n = this.node( '/*/' + orPrefix + ':meta/' + orPrefix + ':' + localName );

       if ( n.get().length === 0 ) {
           n = this.node( '/*/meta/' + localName );
       }

       return n;
   };

   FormModel.prototype.getRepeatCommentText = function( path ) {
       path = path.trim();
       return REPEAT_COMMENT_PREFIX + path;
   };

   FormModel.prototype.getRepeatCommentEl = function( repeatPath, repeatSeriesIndex ) {
       var xPath = '//comment()[self::comment()="' + this.getRepeatCommentText( repeatPath ) + '"]';
       return this.evaluate( xPath, 'nodes', null, null, true )[ repeatSeriesIndex ];
   };

   /**
    * Clones a <repeat>able instance node in a particular series of a repeat.
    *
    * @param  {string} repeatPath absolute path of a repeat
    * @param  {number} repeatSeriesIndex    index of the repeat series that gets a new repeat (this is always 0 for non-nested repeats)
    * @param  {boolean} merge   whether this operation is part of a merge operation (won't send dataupdate event, clears all values and
    *                           will not add ordinal attributes as these should be provided in the record)
    */
   FormModel.prototype.cloneRepeat = function( repeatPath, repeatSeriesIndex, merge ) {
       var $insertAfterNode;
       var $templateClone;
       var repeatSeries;
       var $template;
       var that = this;

       if ( !this.templates[ repeatPath ] ) {
           // This allows the model itself without requiring the controller to cal call .extractFakeTemplates()
           // to extract non-jr:templates by assuming that cloneRepeat would only called for a repeat.
           this.extractFakeTemplates( [ repeatPath ] );
       }

       $template = this.templates[ repeatPath ];
       repeatSeries = this.getRepeatSeries( repeatPath, repeatSeriesIndex );
       $insertAfterNode = ( repeatSeries.length ) ? $( repeatSeries[ repeatSeries.length - 1 ] ) : $( this.getRepeatCommentEl( repeatPath, repeatSeriesIndex ) );

       // if not exists and not a merge operation
       if ( !merge ) {
           repeatSeries.forEach( function( el ) {
               that.addOrdinalAttribute( el, repeatSeries[ 0 ] );
           } );
       }

       /**
        * If templatenodes and insertAfterNode(s) have been identified
        */
       if ( $template[ 0 ] && $insertAfterNode.length === 1 ) {
           $templateClone = $template.clone()
               .insertAfter( $insertAfterNode );

           this.removeOrdinalAttributes( $templateClone[ 0 ] );
           // We should not automatically add ordinal attributes for an existing record as the ordinal values cannot be determined.
           // They should be provided in the instanceStr (record).
           if ( !merge ) {
               this.addOrdinalAttribute( $templateClone[ 0 ], repeatSeries[ 0 ] );
           }

           // If part of a merge operation (during form load) where the values will be populated from the record, defaults are not desired.
           if ( merge ) {
               $templateClone.find( '*' ).filter( function() {
                   return $( this ).children().length === 0;
               } ).text( '' );
           }

           // Note: the addrepeat eventhandler in Form.js takes care of initializing branches etc, so no need to fire an event here.
       } else {
           console.error( 'Could not find template node and/or node to insert the clone after' );
       }
   };

   FormModel.prototype.addOrdinalAttribute = function( repeat, firstRepeatInSeries ) {
       var lastUsedOrdinal;
       var newOrdinal;
       var enkNs = this.getNamespacePrefix( ENKETO_XFORMS_NS );
       firstRepeatInSeries = firstRepeatInSeries || repeat;
       if ( config.repeatOrdinals === true && !repeat.getAttributeNS( ENKETO_XFORMS_NS, 'ordinal' ) ) {
           // getAttributeNs and setAttributeNs results in duplicate namespace declarations on each repeat node in IE11 when serializing the model.
           // However, the regular getAttribute and setAttribute do not work properly in IE11.
           lastUsedOrdinal = firstRepeatInSeries.getAttributeNS( ENKETO_XFORMS_NS, 'last-used-ordinal' ) || 0;
           newOrdinal = Number( lastUsedOrdinal ) + 1;
           firstRepeatInSeries.setAttributeNS( ENKETO_XFORMS_NS, enkNs + ':last-used-ordinal', newOrdinal );

           repeat.setAttributeNS( ENKETO_XFORMS_NS, enkNs + ':ordinal', newOrdinal );
       }
   };

   FormModel.prototype.removeOrdinalAttributes = function( el ) {
       if ( config.repeatOrdinals === true ) {
           // Find all nested repeats first (this is only used for repeats that have no template).
           // The querySelector is actually too unspecific as it matches all ordinal attributes in ANY namespace.
           // However the proper [enk\\:ordinal] doesn't work if setAttributeNS was used to add the attribute.
           var repeats = Array.prototype.slice.call( el.querySelectorAll( '[*|ordinal]' ) );
           repeats.push( el );
           for ( var i = 0; i < repeats.length; i++ ) {
               repeats[ i ].removeAttributeNS( ENKETO_XFORMS_NS, 'last-used-ordinal' );
               repeats[ i ].removeAttributeNS( ENKETO_XFORMS_NS, 'ordinal' );
           }
       }
   };

   /**
    * Obtains a single series of repeat element;
    *
    * @param  {string} repeatPath        The absolute path of the repeat.
    * @param  {number} repeatSeriesIndex The index of the series of that repeat.
    * @return {<Element>}                Array of all repeat elements in a series.
    */
   FormModel.prototype.getRepeatSeries = function( repeatPath, repeatSeriesIndex ) {
       var repeatCommentEl = this.getRepeatCommentEl( repeatPath, repeatSeriesIndex );
       var pathSegments = repeatCommentEl.textContent.substr( REPEAT_COMMENT_PREFIX.length ).split( '/' );
       var nodeName = pathSegments[ pathSegments.length - 1 ];
       var result = [];
       var checkEl = repeatCommentEl.nextSibling;

       // then add all subsequent repeats
       while ( checkEl ) {
           // Ignore any sibling text and comment nodes (e.g. whitespace with a newline character)
           // also deal with repeats that have non-repeat siblings in between them, event though that would be a bug.
           if ( checkEl.nodeName && checkEl.nodeName === nodeName ) {
               result.push( checkEl );
           }
           checkEl = checkEl.nextSibling;
       }

       return result;
   };

   FormModel.prototype.hasPreviousSiblingElementSameName = function( el ) {
       var found = false;
       var nodeName = el.nodeName;
       el = el.previousSibling;

       while ( el ) {
           // Ignore any sibling text and comment nodes (e.g. whitespace with a newline character)
           // also deal with repeats that have non-repeat siblings in between them, event though that would be a bug.
           if ( el.nodeName && el.nodeName === nodeName ) {
               found = true;
               break;
           }
           el = el.previousSibling;
       }
       return found;
   };

   FormModel.prototype.hasPreviousCommentSiblingWithContent = function( node, content ) {
       var found = false;
       node = node.previousSibling;

       while ( node ) {
           if ( node.nodeType === Node.COMMENT_NODE && node.textContent === content ) {
               found = true;
               break;
           }
           node = node.previousSibling;
       }
       return found;
   };

   /**
    * Determines the index of a repeated node amongst all nodes with the same XPath selector
    *
    * @param  {} $node optional jquery element
    * @return {number}       [description]
    */
   FormModel.prototype.determineIndex = function( $node ) {
       var nodeName;
       var path;
       var $family;
       var that = this;

       if ( $node.length === 1 ) {
           nodeName = $node.prop( 'nodeName' );
           path = this.getXPath( $node.get( 0 ), 'instance' );
           $family = this.$.find( nodeName.replace( /\./g, '\\.' ) ).filter( function() {
               return path === that.getXPath( this, 'instance' );
           } );
           return ( $family.length === 1 ) ? null : $family.index( $node );
       } else {
           console.error( 'no node, or multiple nodes, provided to determineIndex function' );
           return -1;
       }
   };

   /**
    * Extracts all templates from the model and stores them in a Javascript object poperties as Jquery collections
    * @return {[type]} [description]
    */
   FormModel.prototype.extractTemplates = function() {
       var that = this;

       // in reverse document order to properly deal with nested repeat templates
       this.getTemplateNodes().reverse().forEach( function( templateEl ) {
           var xPath = that.getXPath( templateEl, 'instance' );
           that.addTemplate( xPath, templateEl );
           /*
            * Nested repeats that have a template attribute are correctly add to that.templates.
            * The template of the repeat ancestor of the nested repeat contains the correct comment.
            * However, since the ancestor repeat (template)
            */
           // IE11 has no remove() method so we use jQuery
           $( templateEl ).remove();
       } );
   };

   FormModel.prototype.extractFakeTemplates = function( repeatPaths ) {
       var that = this;
       var repeat;

       repeatPaths.forEach( function( repeatPath ) {
           // Filter by elements that are the first in a series. This means that multiple instances of nested repeats
           // all get a comment insertion point.
           repeat = that.evaluate( repeatPath, 'node', null, null, true );
           if ( repeat ) {
               that.addTemplate( repeatPath, repeat, true );
           }
       } );
   };

   FormModel.prototype.addRepeatComments = function( repeatPath ) {
       var comment = this.getRepeatCommentText( repeatPath );
       var that = this;
       // Find all repeat series.
       this.evaluate( repeatPath, 'nodes', null, null, true ).forEach( function( repeat ) {
           if ( !that.hasPreviousSiblingElementSameName( repeat ) && !that.hasPreviousCommentSiblingWithContent( repeat, comment ) ) {
               // Add a comment to the primary instance that serves as an insertion point for each repeat series,
               $( repeat ).before( document.createComment( comment ) );
           }
       } );
   };

   FormModel.prototype.addTemplate = function( repeatPath, repeat, empty ) {
       var $clone;

       this.addRepeatComments( repeatPath );

       if ( !this.templates[ repeatPath ] ) {
           $clone = $( repeat ).clone().removeAttr( 'template' ).removeAttr( 'jr:template' );
           if ( empty ) {
               $clone.find( '*' ).filter( function() {
                   return $( this ).children().length === 0;
               } ).text( '' );
           }
           // Add to templates object.
           this.templates[ repeatPath ] = $clone;
       }
   };

   FormModel.prototype.getTemplateNodes = function() {
       var jrPrefix = this.getNamespacePrefix( JAVAROSA_XFORMS_NS );
       // For now we support both the official namespaced template and the hacked non-namespaced template attributes
       // Note: due to an MS Edge bug, we use the slow JS XPath evaluator here. It would be VERY GOOD for performance
       // to switch back once the Edge bug is fixed. The bug results in not finding any templates.
       // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9544701/
       return this.evaluate( '/model/instance[1]/*//*[@template] | /model/instance[1]/*//*[@' + jrPrefix + ':template]', 'nodes', null, null, false );
   };

   /**
    * Initialization function that creates <repeat>able data nodes with the defaults from the template if no repeats have been created yet.
    * Strictly speaking creating the first repeat automatically is not "according to the spec" as the user should be asked first whether it
    * has any data for this question.
    * However, it seems usually always better to assume at least one 'repeat' (= 1 question). It doesn't make use of the Nodeset subclass (CHANGE?)
    *
    * See also: In JavaRosa, the documentation on the jr:template attribute.
    */
   FormModel.prototype.cloneAllTemplates = function() {
       var jrPrefix = this.getNamespacePrefix( JAVAROSA_XFORMS_NS );
       var that = this;

       // for now we support both the official namespaced template and the hacked non-namespaced template attributes
       this.getTemplateNodes().forEach( function( templateEl ) {
           var nodeName = templateEl.nodeName;
           var selector = that.getXPath( templateEl, 'instance' );
           var ancestorTemplateNodes = that.evaluate( 'ancestor::' + nodeName + '[@template] | ancestor::' + nodeName + '[@' + jrPrefix + ':template]', 'nodes', selector, 0, true );
           if ( ancestorTemplateNodes.length === 0 && $( templateEl ).siblings( nodeName.replace( /\./g, '\\.' ) ).length === 0 ) {
               $( templateEl ).clone().insertAfter( $( templateEl ) )
                   // for backwards compatibility
                   .find( '*' ).addBack().removeAttr( 'template' )
                   // just to be sure, but could be omitted
                   .removeAttr( jrPrefix + ':template' )
                   // the proper way of doing this
                   .get( 0 ).removeAttributeNS( JAVAROSA_XFORMS_NS, 'template' );
           }
       } );
   };

   /**
    * Obtains a cleaned up string of the data instance
    *
    * @return {string}           XML string
    */
   FormModel.prototype.getStr = function() {
       var dataStr = ( new XMLSerializer() ).serializeToString( this.xml.querySelector( 'instance > *' ) || this.xml.documentElement, 'text/xml' );
       // restore default namespaces
       dataStr = dataStr.replace( /\s(data-)(xmlns\=("|')[^\s\>]+("|'))/g, ' $2' );
       // remove repeat comments
       dataStr = dataStr.replace( new RegExp( '<!--' + REPEAT_COMMENT_PREFIX + '\/[^>]+-->', 'g' ), '' );
       // If not IE, strip duplicate namespace declarations. IE doesn't manage to add a namespace declaration to the root element.
       if ( navigator.userAgent.indexOf( 'Trident/' ) === -1 ) {
           dataStr = this.removeDuplicateEnketoNsDeclarations( dataStr );
       }
       return dataStr;
   };

   FormModel.prototype.removeDuplicateEnketoNsDeclarations = function( xmlStr ) {
       var i = 0;
       var declarationExp = new RegExp( '( xmlns:' + this.getNamespacePrefix( ENKETO_XFORMS_NS ) + '="' + ENKETO_XFORMS_NS + '")', 'g' );
       return xmlStr.replace( declarationExp, function( match, p1 ) {
           i++;
           if ( i > 1 ) {
               return '';
           } else {
               return match;
           }
       } );
   };

   /**
    * There is a huge bug in JavaRosa that has resulted in the usage of incorrect formulae on nodes inside repeat nodes.
    * Those formulae use absolute paths when relative paths should have been used. See more here:
    * http://opendatakit.github.io/odk-xform-spec/#a-big-deviation-with-xforms
    *
    * Tools such as pyxform also build forms in this incorrect manner. See https://github.com/modilabs/pyxform/issues/91
    * It will take time to correct this so makeBugCompliant() aims to mimic the incorrect
    * behaviour by injecting the 1-based [position] of repeats into the XPath expressions. The resulting expression
    * will then be evaluated in a way users expect (as if the paths were relative) without having to mess up
    * the XPath Evaluator.
    *
    * E.g. '/data/rep_a/node_a' could become '/data/rep_a[2]/node_a' if the context is inside
    * the second rep_a repeat.
    *
    * This function should be removed as soon as JavaRosa (or maybe just pyxform) fixes the way those formulae
    * are created (or evaluated).
    *
    * @param  {string} expr        the XPath expression
    * @param  {string} selector    of the (context) node on which expression is evaluated
    * @param  {number} index       of the instance node with that selector
    */
   FormModel.prototype.makeBugCompliant = function( expr, selector, index ) {
       var i;
       var parentSelector;
       var parentIndex;
       var $target;
       var $node;
       var nodeName;
       var $siblings;
       var $parents;

       // TODO: eliminate jQuery from this function.

       $target = this.node( selector, index ).get();
       // add() sorts the resulting collection in document order
       $parents = $target.parents().add( $target );
       // traverse collection in reverse document order
       for ( i = $parents.length - 1; i >= 0; i-- ) {
           $node = $parents.eq( i );
           // escape any dots in the node name
           nodeName = $node.prop( 'nodeName' ).replace( /\./g, '\\.' );
           $siblings = $node.siblings( nodeName ).not( '[template]' );
           // if the node is a repeat node that has been cloned at least once (i.e. if it has siblings with the same nodeName)
           if ( nodeName.toLowerCase() !== 'instance' && nodeName.toLowerCase() !== 'model' && $siblings.length > 0 ) {
               parentSelector = this.getXPath( $node.get( 0 ), 'instance' );
               parentIndex = $siblings.add( $node ).index( $node );
               // Add position to segments that do not have an XPath predicate.
               expr = expr.replace( new RegExp( parentSelector + '/', 'g' ), parentSelector + '[' + ( parentIndex + 1 ) + ']/' );
           }
       }
       return expr;
   };

   FormModel.prototype.setNamespaces = function() {
       /**
        * Passing through all nodes would be very slow with an XForms model that contains lots of nodes such as large secondary instances.
        * (The namespace XPath axis is not support in native browser XPath evaluators unfortunately).
        *
        * For now it has therefore been restricted to only look at the top-level node in the primary instance.
        * We can always expand that later.
        */
       var start = this.hasInstance ? '/model/instance[1]' : '';
       var node = this.evaluate( start + '/*', 'node', null, null, true );
       var that = this;
       var prefix;

       if ( node ) {
           if ( node.hasAttributes() ) {
               for ( var i = 0; i < node.attributes.length; i++ ) {
                   var attribute = node.attributes[ i ];

                   if ( attribute.name.indexOf( 'xmlns:' ) === 0 ) {
                       this.namespaces[ attribute.name.substring( 6 ) ] = attribute.value;
                   }
               }
           }
           // add required namespaces to resolver and document if they are missing
           [
               [ 'orx', OPENROSA_XFORMS_NS, false ],
               [ 'jr', JAVAROSA_XFORMS_NS, false ],
               [ 'enk', ENKETO_XFORMS_NS, config.repeatOrdinals === true ]
           ].forEach( function( arr ) {
               if ( !that.getNamespacePrefix( arr[ 1 ] ) ) {
                   prefix = ( !that.namespaces[ arr[ 0 ] ] ) ? arr[ 0 ] : '__' + arr[ 0 ];
                   // add to resolver
                   that.namespaces[ prefix ] = arr[ 1 ];
                   // add to document
                   if ( arr[ 2 ] ) {
                       node.setAttributeNS( 'http://www.w3.org/2000/xmlns/', 'xmlns:' + prefix, arr[ 1 ] );
                   }
               }
           } );
       }
   };

   FormModel.prototype.getNamespacePrefix = function( namespace ) {
       var p;
       for ( var prefix in this.namespaces ) {
           if ( this.namespaces.hasOwnProperty( prefix ) && this.namespaces[ prefix ] === namespace ) {
               p = prefix;
               break;
           }
       }
       return p;
   };

   FormModel.prototype.getNsResolver = function() {
       var namespaces = ( typeof this.namespaces === 'undefined' ) ? {} : this.namespaces;

       return {
           lookupNamespaceURI: function( prefix ) {
               return namespaces[ prefix ] || null;
           }
       };
   };


   /**
    * Shift root to first instance for all absolute paths not starting with /model
    *
    * @param  {string} expr original expression
    * @return {string}      new expression
    */
   FormModel.prototype.shiftRoot = function( expr ) {
       var LITERALS = /"([^"]*)(")|'([^']*)(')/g;
       if ( this.hasInstance ) {
           // Encode all string literals in order to exclude them, without creating a monsterly regex
           expr = expr.replace( LITERALS, function( m, p1, p2, p3, p4 ) {
               var encoded = typeof p1 !== 'undefined' ? encodeURIComponent( p1 ) : encodeURIComponent( p3 );
               var quote = p2 ? p2 : p4;
               return quote + encoded + quote;
           } );
           // Insert /model/instance[1]
           expr = expr.replace( /^(\/(?!model\/)[^\/][^\/\s,"']*\/)/g, '/model/instance[1]$1' );
           expr = expr.replace( /([^a-zA-Z0-9\.\]\)\/\*_-])(\/(?!model\/)[^\/][^\/\s,"']*\/)/g, '$1/model/instance[1]$2' );
           // Decode string literals
           expr = expr.replace( LITERALS, function( m, p1, p2, p3, p4 ) {
               var decoded = typeof p1 !== 'undefined' ? decodeURIComponent( p1 ) : decodeURIComponent( p3 );
               var quote = p2 ? p2 : p4;
               return quote + decoded + quote;
           } );
       }
       return expr;
   };

   /**
    * Replace instance('id') with an absolute path
    * Doing this here instead of adding an instance() function to the XPath evaluator, means we can keep using
    * the much faster native evaluator in most cases!
    *
    * @param  {string} expr original expression
    * @return {string}      new expression
    */
   FormModel.prototype.replaceInstanceFn = function( expr ) {
       var prefix;
       var that = this;

       // TODO: would be more consistent to use utls.parseFunctionFromExpression() and utils.stripQuotes
       return expr.replace( INSTANCE, function( match, id ) {
           prefix = '/model/instance[@id="' + id + '"]';
           // check if referred instance exists in model
           if ( that.evaluate( prefix, 'nodes', null, null, true ).length ) {
               return prefix;
           } else {
               throw new FormLogicError( 'instance "' + id + '" does not exist in model' );
           }
       } );
   };

   /**
    * Replaces current() with /absolute/path/to/node to ensure the context is shifted to the primary instance
    *
    * Doing this here instead of adding a current() function to the XPath evaluator, means we can keep using
    * the much faster native evaluator in most cases!
    *
    * Root will be shifted, and repeat positions injected, **later on**, so it's not included here.
    *
    * @param  {string} expr            original expression
    * @param  {string} contextSelector context selector
    * @return {string}                 new expression
    */
   FormModel.prototype.replaceCurrentFn = function( expr, contextSelector ) {
       // relative paths
       expr = expr.replace( 'current()/.', contextSelector + '/.' );
       // absolute paths
       expr = expr.replace( 'current()/', '/' );

       return expr;
   };

   /**
    * Replaces indexed-repeat(node, path, position, path, position, etc) substrings by converting them
    * to their native XPath equivalents using [position() = x] predicates
    *
    * @param  {string} expr the XPath expression
    * @return {string}      converted XPath expression
    */
   FormModel.prototype.replaceIndexedRepeatFn = function( expr, selector, index ) {
       var that = this;
       var indexedRepeats = utils.parseFunctionFromExpression( expr, 'indexed-repeat' );

       if ( !indexedRepeats.length ) {
           return expr;
       }

       indexedRepeats.forEach( function( indexedRepeat ) {
           var i, positionedPath;
           var position;
           var params = indexedRepeat[ 1 ];

           if ( params.length % 2 === 1 ) {

               positionedPath = params[ 0 ];

               for ( i = params.length - 1; i > 1; i -= 2 ) {
                   // The position will become an XPath predicate. The context for an XPath predicate, is not the same
                   // as the context for the complete expression, so we have to evaluate the position separately. Otherwise
                   // relative paths would break.
                   position = !isNaN( params[ i ] ) ? params[ i ] : that.evaluate( params[ i ], 'number', selector, index, true );
                   positionedPath = positionedPath.replace( params[ i - 1 ], params[ i - 1 ] + '[position() = ' + position + ']' );
               }

               expr = expr.replace( indexedRepeat[ 0 ], positionedPath );

           } else {
               throw new FormLogicError( 'indexed repeat with incorrect number of parameters found: ' + indexedRepeat[ 0 ] );
           }
       } );

       return expr;
   };

   FormModel.prototype.replacePullDataFn = function( expr, selector, index ) {
       var pullDataResult;
       var that = this;
       var replacements = this.convertPullDataFn( expr, selector, index );

       for ( var pullData in replacements ) {
           if ( replacements.hasOwnProperty( pullData ) ) {
               // We evaluate this here, so we can use the native evaluator safely. This speeds up pulldata() by about a factor *740*!
               pullDataResult = that.evaluate( replacements[ pullData ], 'string', selector, index, true );
               expr = expr.replace( pullData, '"' + pullDataResult + '"' );
           }
       }
       return expr;
   };

   FormModel.prototype.convertPullDataFn = function( expr, selector, index ) {
       var that = this;
       var pullDatas = utils.parseFunctionFromExpression( expr, 'pulldata' );
       var replacements = {};

       if ( !pullDatas.length ) {
           return replacements;
       }

       pullDatas.forEach( function( pullData ) {
           var searchValue;
           var searchXPath;
           var params = pullData[ 1 ];

           if ( params.length === 4 ) {

               // strip quotes
               params[ 1 ] = utils.stripQuotes( params[ 1 ] );
               params[ 2 ] = utils.stripQuotes( params[ 2 ] );

               // TODO: the 2nd and 3rd parameter could probably also be expressions.

               // The 4th argument will become an XPath predicate. The context for an XPath predicate, is not the same
               // as the context for the complete expression, so we have to evaluate the position separately. Otherwise
               // relative paths would break.
               searchValue = that.evaluate( params[ 3 ], 'string', selector, index, true );
               searchValue = searchValue === '' || isNaN( searchValue ) ? '\'' + searchValue + '\'' : searchValue;
               searchXPath = 'instance(' + params[ 0 ] + ')/root/item[' + params[ 2 ] + ' = ' + searchValue + ']/' + params[ 1 ];

               replacements[ pullData[ 0 ] ] = searchXPath;

           } else {
               throw new FormLogicError( 'pulldata with incorrect number of parameters found: ' + pullData[ 0 ] );
           }
       } );

       return replacements;
   };

   /**
    * Evaluates an XPath Expression using XPathJS_javarosa (not native XPath 1.0 evaluator)
    *
    * This function does not seem to work properly for nodeset resulttypes otherwise:
    * muliple nodes can be accessed by returned node.snapshotItem(i)(.textContent)
    * a single node can be accessed by returned node(.textContent)
    *
    * @param  { string }     expr        the expression to evaluate
    * @param  { string= }    resTypeStr  boolean, string, number, node, nodes (best to always supply this)
    * @param  { string= }    selector    jQuery selector which will be use to provide the context to the evaluator
    * @param  { number= }    index       0-based index of selector in document
    * @param  { boolean= }   tryNative   whether an attempt to try the Native Evaluator is safe (ie. whether it is
    *                                    certain that there are no date comparisons)
    * @return { ?(number|string|boolean|Array<element>) } the result
    */
   FormModel.prototype.evaluate = function( expr, resTypeStr, selector, index, tryNative ) {
       var j, context, doc, resTypeNum, resultTypes, result, $collection, response, repeats, cacheKey, original, cacheable;

       // console.debug( 'evaluating expr: ' + expr + ' with context selector: ' + selector + ', 0-based index: ' +
       //    index + ' and result type: ' + resTypeStr );
       original = expr;
       tryNative = tryNative || false;
       resTypeStr = resTypeStr || 'any';
       index = index || 0;
       doc = this.xml;
       repeats = null;

       // path corrections for repeated nodes: http://opendatakit.github.io/odk-xform-spec/#a-big-deviation-with-xforms
       if ( selector ) {
           $collection = this.node( selector ).get();
           repeats = $collection.length;
           context = $collection.eq( index )[ 0 ];
       } else {
           // either the first data child of the first instance or the first child (for loaded instances without a model)
           context = this.rootElement;
       }

       // cache key includes the number of repeated context nodes,
       // to force a new cache item if the number of repeated changes to > 0
       // TODO: these cache keys can get quite large. Would it be beneficial to get the md5 of the key?
       cacheKey = [ expr, selector, index, repeats ].join( '|' );

       // These functions need to come before makeBugCompliant.
       // An expression transformation with indexed-repeat or pulldata cannot be cached because in
       // "indexed-repeat(node, repeat nodeset, index)" the index parameter could be an expression.
       expr = this.replaceIndexedRepeatFn( expr, selector, index );
       expr = this.replacePullDataFn( expr, selector, index );
       cacheable = ( original === expr );

       // if no cached conversion exists
       if ( !this.convertedExpressions[ cacheKey ] ) {
           expr = expr;
           expr = expr.trim();
           expr = this.replaceInstanceFn( expr );
           expr = this.replaceCurrentFn( expr, selector );
           // shiftRoot should come after replaceCurrentFn
           expr = this.shiftRoot( expr );
           if ( repeats && repeats > 1 ) {
               expr = this.makeBugCompliant( expr, selector, index );
           }
           // decode
           expr = expr.replace( /&lt;/g, '<' );
           expr = expr.replace( /&gt;/g, '>' );
           expr = expr.replace( /&quot;/g, '"' );
           if ( cacheable ) {
               this.convertedExpressions[ cacheKey ] = expr;
           }
       } else {
           expr = this.convertedExpressions[ cacheKey ];
       }

       resultTypes = {
           0: [ 'any', 'ANY_TYPE' ],
           1: [ 'number', 'NUMBER_TYPE', 'numberValue' ],
           2: [ 'string', 'STRING_TYPE', 'stringValue' ],
           3: [ 'boolean', 'BOOLEAN_TYPE', 'booleanValue' ],
           7: [ 'nodes', 'ORDERED_NODE_SNAPSHOT_TYPE' ],
           9: [ 'node', 'FIRST_ORDERED_NODE_TYPE', 'singleNodeValue' ]
       };

       // translate typeStr to number according to DOM level 3 XPath constants
       for ( resTypeNum in resultTypes ) {
           if ( resultTypes.hasOwnProperty( resTypeNum ) ) {
               resTypeNum = Number( resTypeNum );
               if ( resultTypes[ resTypeNum ][ 0 ] === resTypeStr ) {
                   break;
               } else {
                   resTypeNum = 0;
               }
           }
       }

       // try native to see if that works... (will not work if the expr contains custom OpenRosa functions)
       if ( tryNative && typeof doc.evaluate !== 'undefined' && !OPENROSA.test( expr ) ) {
           try {
               // console.log( 'trying the blazing fast native XPath Evaluator for', expr, index );
               result = doc.evaluate( expr, context, this.getNsResolver(), resTypeNum, null );
           } catch ( e ) {
               console.log( '%cWell native XPath evaluation did not work... No worries, worth a shot, the expression probably ' +
                   'contained unknown OpenRosa functions or errors:', 'color:orange', expr );
           }
       }

       // if that didn't work, try the slow XPathJS evaluator
       if ( !result ) {
           try {
               if ( typeof doc.jsEvaluate === 'undefined' ) {
                   this.bindJsEvaluator();
               }
               // console.log( 'trying the slow enketo-xpathjs "openrosa" evaluator for', expr, index );
               result = doc.jsEvaluate( expr, context, this.getNsResolver(), resTypeNum, null );
           } catch ( e ) {
               throw new FormLogicError( 'Could not evaluate: ' + expr + ', message: ' + e.message );
           }
       }

       // get desired value from the result object
       if ( result ) {
           // for type = any, see if a valid string, number or boolean is returned
           if ( resTypeNum === 0 ) {
               for ( resTypeNum in resultTypes ) {
                   if ( resultTypes.hasOwnProperty( resTypeNum ) ) {
                       resTypeNum = Number( resTypeNum );
                       if ( resTypeNum === Number( result.resultType ) && resTypeNum > 0 && resTypeNum < 4 ) {
                           response = result[ resultTypes[ resTypeNum ][ 2 ] ];
                           break;
                       }
                   }
               }
               console.error( 'Expression: ' + expr + ' did not return any boolean, string or number value as expected' );
           } else if ( resTypeNum === 7 ) {
               // response is an array of Elements
               response = [];
               for ( j = 0; j < result.snapshotLength; j++ ) {
                   response.push( result.snapshotItem( j ) );
               }
           } else {
               response = result[ resultTypes[ resTypeNum ][ 2 ] ];
           }
           return response;
       }
   };

   /**
    * Class dealing with nodes and nodesets of the XML instance
    *
    * @constructor
    * @param {string=} selector simpleXPath or jQuery selectedor
    * @param {number=} index    the index of the target node with that selector
    * @param {?{onlyLeaf: boolean, noEmpty: boolean}=} filter   filter object for the result nodeset
    * @param { FormModel } model instance of FormModel
    */
   Nodeset = function( selector, index, filter, model ) {
       var defaultSelector = model.hasInstance ? '/model/instance[1]//*' : '//*';

       this.model = model;
       this.originalSelector = selector;
       this.selector = ( typeof selector === 'string' && selector.length > 0 ) ? selector : defaultSelector;
       filter = ( typeof filter !== 'undefined' && filter !== null ) ? filter : {};
       this.filter = filter;
       this.filter.onlyLeaf = ( typeof filter.onlyLeaf !== 'undefined' ) ? filter.onlyLeaf : false;
       this.filter.noEmpty = ( typeof filter.noEmpty !== 'undefined' ) ? filter.noEmpty : false;
       this.index = index;
   };

   /**
    * Privileged method to find data nodes filtered by a jQuery or XPath selector and additional filter properties
    * Without parameters it returns a collection of all data nodes excluding template nodes and their children. Therefore, most
    * queries will not require filter properties. This function handles all (?) data queries in the application.
    *
    * @return {jQuery} jQuery-wrapped filtered instance nodes that match the selector and index
    */
   Nodeset.prototype.get = function() {
       var $nodes;
       var /** @type {string} */ val;

       // cache evaluation result
       if ( !this.nodes ) {
           this.nodes = this.model.evaluate( this.selector, 'nodes', null, null, true );
       }

       // noEmpty automatically excludes non-leaf nodes
       if ( this.filter.noEmpty === true ) {
           $nodes = $( this.nodes ).filter( function() {
               var $node = $( this );
               val = $node.text();
               return $node.children().length === 0 && val.trim().length > 0;
           } );
       }
       // this may still contain empty leaf nodes
       else if ( this.filter.onlyLeaf === true ) {
           $nodes = $( this.nodes ).filter( function() {
               return $( this ).children().length === 0;
           } );
       } else {
           $nodes = $( this.nodes );
       }

       return ( typeof this.index !== 'undefined' && this.index !== null ) ? $nodes.eq( this.index ) : $nodes;
   };

   /**
    * Sets the index of the Nodeset instance
    *
    * @param {=number?} index The 0-based index
    */
   Nodeset.prototype.setIndex = function( index ) {
       this.index = index;
   };

   /**
    * Sets data node values.
    *
    * @param {(string|Array.<string>)=} newVals    The new value of the node.
    * @param {?string=} expr  XPath expression to validate the node.
    * @param {?string=} xmlDataType XML data type of the node
    * @param {?string=} requiredExpr XPath expression to determine where value is required
    * @param {?boolean} noValidate Whether to skip validation
    *
    * @return {?*} wrapping {?boolean}; null is returned when the node is not found or multiple nodes were selected,
    *                            otherwise an object with update information is returned.
    */
   Nodeset.prototype.setVal = function( newVals, constraintExpr, xmlDataType, requiredExpr, noValidate ) {
       var $target;
       var curVal;
       var /**@type {string}*/ newVal;
       var updated;
       var customData;

       curVal = this.getVal()[ 0 ];

       if ( typeof newVals !== 'undefined' && newVals !== null ) {
           newVal = ( Array.isArray( newVals ) ) ? newVals.join( ' ' ) : newVals.toString();
       } else {
           newVal = '';
       }

       newVal = this.convert( newVal, xmlDataType );
       $target = this.get();

       if ( $target.length === 1 && newVal.toString().trim() !== curVal.toString().trim() ) {
           // first change the value so that it can be evaluated in XPath (validated)
           $target.text( newVal.toString() );
           // then return validation result
           updated = this.getClosestRepeat();
           updated.nodes = [ $target.prop( 'nodeName' ) ];

           customData = this.model.getUpdateEventData( $target.get( 0 ), xmlDataType );
           updated = ( customData ) ? $.extend( {}, updated, customData ) : updated;

           this.model.$events.trigger( 'dataupdate', updated );

           if ( config.validateContinuously && noValidate !== true ) {
               this.validate( constraintExpr, requiredExpr, xmlDataType );
           }

           //add type="file" attribute for file references
           if ( xmlDataType === 'binary' ) {
               if ( newVal.length > 0 ) {
                   $target.attr( 'type', 'file' );
               } else {
                   $target.removeAttr( 'type' );
               }
           }
           return updated;
       }
       if ( $target.length > 1 ) {
           console.error( 'nodeset.setVal expected nodeset with one node, but received multiple' );
           return null;
       }
       if ( $target.length === 0 ) {
           console.log( 'Data node: ' + this.selector + ' with null-based index: ' + this.index + ' not found. Ignored.' );
           return null;
       }

       return null;
   };

   /**
    * Obtains the data value if a JQuery or XPath selector for a single node is provided.
    *
    * @return {Array<string|number|boolean>} [description]
    */
   Nodeset.prototype.getVal = function() {
       var vals = [];
       this.get().each( function() {
           vals.push( $( this ).text() );
       } );
       return vals;
   };

   // if repeats have not been cloned yet, they are not considered a repeat by this function
   Nodeset.prototype.getClosestRepeat = function() {
       var el = this.get().get( 0 );
       var nodeName = el.nodeName;

       while ( nodeName !== 'instance' && !( el.nextSibling && el.nextSibling.nodeName === nodeName ) && !( el.previousSibling && el.previousSibling.nodeName === nodeName ) ) {
           el = el.parentNode;
           nodeName = el.nodeName;
       }

       return ( nodeName === 'instance' ) ? {} : {
           repeatPath: this.model.getXPath( el, 'instance' ),
           repeatIndex: this.model.determineIndex( $( el ) )
       };
   };

   /**
    * Remove a repeat node
    */
   Nodeset.prototype.remove = function() {
       var $dataNode;
       var allRemovedNodeNames;
       var $this;
       var repeatPath;
       var repeatIndex;
       var removalEventData;

       $dataNode = this.get();

       if ( $dataNode.length > 0 ) {

           allRemovedNodeNames = [ $dataNode.prop( 'nodeName' ) ];

           $dataNode.find( '*' ).each( function() {
               $this = $( this );
               allRemovedNodeNames.push( $this.prop( 'nodeName' ) );
           } );

           repeatPath = this.model.getXPath( $dataNode.get( 0 ), 'instance' );
           repeatIndex = this.model.determineIndex( $dataNode );
           removalEventData = this.model.getRemovalEventData( $dataNode.get( 0 ) );

           if ( !this.model.templates[ repeatPath ] ) {
               // This allows the model itself without requiring the controller to cal call .extractFakeTemplates()
               // to extract non-jr:templates by assuming that node.remove() would only called for a repeat.
               this.model.extractFakeTemplates( [ repeatPath ] );
           }

           $dataNode.remove();
           this.nodes = null;

           // For internal use
           this.model.$events.trigger( 'dataupdate', {
               nodes: allRemovedNodeNames,
               repeatPath: repeatPath,
               repeatIndex: repeatIndex
           } );

           // For external use, if required with custom data.
           this.model.$events.trigger( 'removed', removalEventData );

       } else {
           console.error( 'could not find node ' + this.selector + ' with index ' + this.index + ' to remove ' );
       }
   };

   /**
    * Convert a value to a specified data type( though always stringified )
    * @param  {?string=} x           value to convert
    * @param  {?string=} xmlDataType XML data type
    * @return {string}               string representation of converted value
    */
   Nodeset.prototype.convert = function( x, xmlDataType ) {
       if ( x.toString() === '' ) {
           return x;
       }
       if ( typeof xmlDataType !== 'undefined' && xmlDataType !== null &&
           typeof types[ xmlDataType.toLowerCase() ] !== 'undefined' &&
           typeof types[ xmlDataType.toLowerCase() ].convert !== 'undefined' ) {
           return types[ xmlDataType.toLowerCase() ].convert( x );
       }
       return x;
   };

   Nodeset.prototype.validate = function( constraintExpr, requiredExpr, xmlDataType ) {
       var that = this;
       var result = {};

       // Avoid checking constraint if required is invalid
       return this.validateRequired( requiredExpr )
           .then( function( passed ) {
               result.requiredValid = passed;
               return ( passed === false ) ? null : that.validateConstraintAndType( constraintExpr, xmlDataType );
           } )
           .then( function( passed ) {
               result.constraintValid = passed;

               return result;
           } );
   };

   /**
    * Validate a value with an XPath Expression and /or xml data type
    * @param  {?string=} expr        XPath expression
    * @param  {?string=} xmlDataType XML datatype
    * @return {Promise} wrapping a boolean indicating if the value is valid or not; error also indicates invalid field, or problem validating it
    */
   Nodeset.prototype.validateConstraintAndType = function( expr, xmlDataType ) {
       var that = this;
       var value;

       if ( !xmlDataType || typeof types[ xmlDataType.toLowerCase() ] === 'undefined' ) {
           xmlDataType = 'string';
       }

       // This one weird trick results in a small validation performance increase.
       // Do not obtain *the value* if the expr is empty and data type is string, select, select1, binary knowing that this will always return true.
       if ( !expr && ( xmlDataType === 'string' || xmlDataType === 'select' || xmlDataType === 'select1' || xmlDataType === 'binary' ) ) {
           return Promise.resolve( true );
       }

       value = that.getVal()[ 0 ];

       if ( value.toString() === '' ) {
           return Promise.resolve( true );
       }

       return Promise.resolve()
           .then( function() {
               return types[ xmlDataType.toLowerCase() ].validate( value );
           } )
           .then( function( typeValid ) {
               var exprValid = ( typeof expr !== 'undefined' && expr !== null && expr.length > 0 ) ? that.model.evaluate( expr, 'boolean', that.originalSelector, that.index ) : true;

               return ( typeValid && exprValid );
           } );
   };

   Nodeset.prototype.isRequired = function( expr ) {
       return !expr || expr.trim() === 'false()' ? false : expr.trim() === 'true()' || this.model.evaluate( expr, 'boolean', this.originalSelector, this.index );
   };

   Nodeset.prototype.validateRequired = function( expr ) {
       var that = this;

       // if the node has a value or there is no required expression
       if ( !expr || this.getVal()[ 0 ] ) {
           return Promise.resolve( true );
       }

       // if the node does not have a value and there is a required expression
       return Promise.resolve()
           .then( function() {
               // if the expression evaluates to true, the field is required, and the function returns false.
               return !that.isRequired( expr );
           } );
   };

   // Placeholder function meant to be overwritten
   FormModel.prototype.getUpdateEventData = function( node, type ) {};

   // Placeholder function meant to be overwritten
   FormModel.prototype.getRemovalEventData = function( node ) {};

   // Expose types to facilitate extending with custom types
   FormModel.prototype.types = types;

   module.exports = FormModel;


   // The deprecated methods below to be removed for version 5.0.0:
   /**
    * @deprecated
    */
   FormModel.prototype.getVersion = function() {
       console.warn( 'FormModel.getVersion() is deprecated, use model.version' );
       return this.version;
   };
   /**
    * @deprecated
    *
    * See Also:
    * Returns jQuery Data Object (obsolete?)
    * See also: <nodes.get()>, which is always (?) preferred except for debugging.
    *
    * @return {jQuery} JQuery Data Object
    */
   FormModel.prototype.get = function() {
       console.warn( 'model.get() is deprecated, use model.$' );
       return this.$ || null;
   };
   /**
    * @deprecated
    * @return {Element} data XML object (not sure if type is element actually)
    */
   FormModel.prototype.getXML = function() {
       console.warn( 'model.getXML() is deprecated, use model.xml' );
       return this.xml || null;
   };
   /**
    * @deprecated
    */
   FormModel.prototype.getInstanceID = function() {
       console.warn( 'model.getInstanceID() is deprecated, use model.instanceID' );
       return this.instanceID;
   };
   /**
    * @deprecated
    */
   FormModel.prototype.getDeprecatedID = function() {
       console.warn( 'model.getDeprecatedID() is deprecated, use model.deprecatedID' );
       return this.deprecatedID;
   };
   /**
    * @deprecated
    */
   FormModel.prototype.getInstanceName = function() {
       console.warn( 'model.getInstanceName() is deprecated, use model.instanceName' );
       return this.instanceName;
   };

   },{"mergexml/mergexml":"mergexml","./utils":"utils","jquery":"jquery","lie":"lie","./Form-logic-error":"Form-logic-error","enketo-config":"text!enketo-config","./types":"types","./plugins":"plugins","./extend":"extend","./xpath-evaluator-binding":"xpath-evaluator-binding"}],
   "input":[function(require,module,exports){
   'use strict';

   /**
    * Input helper functions.
    */

   module.exports = {
       // Multiple nodes are limited to ones of the same input type (better implemented as JQuery plugin actually)
       getWrapNodes: function( $inputNodes ) {
           var type = this.getInputType( $inputNodes.eq( 0 ) );
           return ( type === 'fieldset' ) ? $inputNodes : $inputNodes.closest( '.question, .calculation' );
       },
       /** very inefficient, should actually not be used **/
       getProps: function( $node ) {
           if ( $node.length !== 1 ) {
               return console.error( 'getProps(): no input node provided or multiple' );
           }
           return {
               path: this.getName( $node ),
               ind: this.getIndex( $node ),
               inputType: this.getInputType( $node ),
               xmlType: this.getXmlType( $node ),
               constraint: this.getConstraint( $node ),
               calculation: this.getCalculation( $node ),
               relevant: this.getRelevant( $node ),
               readonly: this.getReadonly( $node ),
               val: this.getVal( $node ),
               required: this.getRequired( $node ),
               enabled: this.isEnabled( $node ),
               multiple: this.isMultiple( $node )
           };
       },
       getInputType: function( $node ) {
           var nodeName;
           if ( $node.length !== 1 ) {
               return ''; //console.error('getInputType(): no input node provided or multiple');
           }
           nodeName = $node.prop( 'nodeName' ).toLowerCase();
           if ( nodeName === 'input' ) {
               if ( $node.attr( 'type' ).length > 0 ) {
                   return $node.attr( 'type' ).toLowerCase();
               } else {
                   return console.error( '<input> node has no type' );
               }
           } else if ( nodeName === 'select' ) {
               return 'select';
           } else if ( nodeName === 'textarea' ) {
               return 'textarea';
           } else if ( nodeName === 'fieldset' || nodeName === 'section' ) {
               return 'fieldset';
           } else {
               return console.error( 'unexpected input node type provided' );
           }
       },
       getConstraint: function( $node ) {
           return $node.attr( 'data-constraint' );
       },
       getRequired: function( $node ) {
           // only return value if input is not a table heading input
           if ( $node.parentsUntil( '.or', '.or-appearance-label' ).length === 0 ) {
               return $node.attr( 'data-required' );
           }
       },
       getRelevant: function( $node ) {
           return $node.attr( 'data-relevant' );
       },
       getReadonly: function( $node ) {
           return $node.is( '[readonly]' );
       },
       getCalculation: function( $node ) {
           return $node.attr( 'data-calculate' );
       },
       getXmlType: function( $node ) {
           if ( $node.length !== 1 ) {
               return console.error( 'getXMLType(): no input node provided or multiple' );
           }
           return $node.attr( 'data-type-xml' );
       },
       getName: function( $node ) {
           var name;
           if ( $node.length !== 1 ) {
               return console.error( 'getName(): no input node provided or multiple' );
           }
           name = $node.attr( 'data-name' ) || $node.attr( 'name' );
           return name || console.error( 'input node has no name' );
       },
       /**
        * Used to retrieve the index of a question amidst all questions with the same name.
        * The index that can be used to find the corresponding node in the model.
        * NOTE: this function should be used sparingly, as it is CPU intensive!
        * TODO: simplify this function by looking for nodes with same CLASS on wrapNode
        *
        * @param  {jQuery} $node The jQuery-wrapped input element
        * @return {number}       The index
        */
       getIndex: function( $node ) {
           var inputType;
           var name;
           var $wrapNode;
           var $wrapNodesSameName;

           if ( $node.length !== 1 ) {
               return console.error( 'getIndex(): no input node provided or multiple' );
           }

           inputType = this.getInputType( $node );
           name = this.getName( $node );
           $wrapNode = this.getWrapNodes( $node );

           if ( inputType === 'radio' && name !== $node.attr( 'name' ) ) {
               $wrapNodesSameName = this.getWrapNodes( this.form.view.$.find( '[data-name="' + name + '"]' ) );
           }
           // fieldset.or-group wraps fieldset.or-repeat and can have same name attribute!)
           else if ( inputType === 'fieldset' && $node.hasClass( 'or-repeat' ) ) {
               $wrapNodesSameName = this.getWrapNodes( this.form.view.$.find( '.or-repeat[name="' + name + '"]' ) );
           } else if ( inputType === 'fieldset' && $node.hasClass( 'or-group' ) ) {
               $wrapNodesSameName = this.getWrapNodes( this.form.view.$.find( '.or-group[name="' + name + '"]' ) );
           } else {
               $wrapNodesSameName = this.getWrapNodes( this.form.view.$.find( '[name="' + name + '"]' ) );
           }

           return $wrapNodesSameName.index( $wrapNode );
       },
       isMultiple: function( $node ) {
           return ( this.getInputType( $node ) === 'checkbox' || $node.attr( 'multiple' ) !== undefined ) ? true : false;
       },
       isEnabled: function( $node ) {
           return !( $node.prop( 'disabled' ) || $node.parentsUntil( '.or', '.disabled' ).length > 0 );
       },
       getVal: function( $node ) {
           var inputType;
           var values = [];
           var name;

           if ( $node.length !== 1 ) {
               return console.error( 'getVal(): no inputNode provided or multiple' );
           }
           inputType = this.getInputType( $node );
           name = this.getName( $node );

           if ( inputType === 'radio' ) {
               return this.getWrapNodes( $node ).find( 'input:checked' ).val() || '';
           }
           // checkbox values bug in jQuery as (node.val() should work)
           if ( inputType === 'checkbox' ) {
               this.getWrapNodes( $node ).find( 'input[name="' + name + '"]:checked' ).each( function() {
                   values.push( this.value );
               } );
               return values;
           }
           return ( !$node.val() ) ? '' : $node.val();
       },
       setVal: function( name, index, value ) {
           var $inputNodes;
           var type;
           var curVal;

           index = index || 0;

           if ( this.getInputType( this.form.view.$.find( '[data-name="' + name + '"]' ).eq( 0 ) ) === 'radio' ) {
               type = 'radio';
               $inputNodes = this.getWrapNodes( this.form.view.$.find( '[data-name="' + name + '"]' ) ).eq( index ).find( '[data-name="' + name + '"]' );
           } else {
               // why not use this.getIndex?
               $inputNodes = this.getWrapNodes( this.form.view.$.find( '[name="' + name + '"]' ) ).eq( index ).find( '[name="' + name + '"]' );
               type = this.getInputType( $inputNodes.eq( 0 ) );

               if ( type === 'file' ) {
                   $inputNodes.eq( 0 ).attr( 'data-loaded-file-name', value );
                   // console.error('Cannot set value of file input field (value: '+value+'). If trying to load '+
                   //  'this record for editing this file input field will remain unchanged.');
                   return false;
               }

               if ( type === 'date' || type === 'datetime' ) {
                   // convert current value (loaded from instance) to a value that a native datepicker understands
                   // TODO test for IE, FF, Safari when those browsers start including native datepickers
                   value = this.form.model.node( name, index ).convert( value, type );
               }
           }

           if ( this.isMultiple( $inputNodes.eq( 0 ) ) === true ) {
               value = value.split( ' ' );
           } else if ( type === 'radio' ) {
               value = [ value ];
           }

           // Trigger an 'inputupdate' event which can be used in widgets to update the widget when the value of its
           // original input element has changed **programmatically**.
           if ( $inputNodes.length ) {
               curVal = this.getVal( $inputNodes.eq( 0 ) );
               if ( curVal === undefined || curVal.toString() !== value.toString() ) {
                   $inputNodes.val( value );
                   // don't trigger on all radiobuttons/checkboxes
                   $inputNodes.eq( 0 ).trigger( 'inputupdate.enketo' );
               }
           }

           return;
       },
       validate: function( $input ) {
           return this.form.validateInput( $input );
       }
   };

   },{}],
   "itemset":[function(require,module,exports){
   'use strict';

   /**
    * Updates itemsets
    *
    * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
    */

   var $ = require( 'jquery' );
   var utils = require( './utils' );

   module.exports = {
       update: function( updated ) {
           var clonedRepeatsPresent;
           var insideRepeat;
           var insideRepeatClone;
           var $nodes;
           var that = this;
           var itemsCache = {};

           if ( !this.form ) {
               throw new Error( 'Output module not correctly instantiated with form property.' );
           }

           $nodes = this.form.getRelatedNodes( 'data-items-path', '.itemset-template', updated );

           clonedRepeatsPresent = ( this.form.repeatsPresent && this.form.view.$.find( '.or-repeat.clone' ).length > 0 ) ? true : false;

           $nodes.each( function() {
               var $htmlItem, $htmlItemLabels, /**@type {string}*/ value, currentValue, $instanceItems, index, context,
                   $template, newItems, prevItems, templateNodeName, $input, $labels, itemsXpath, labelType, labelRef, valueRef;
               var $list;

               $template = $( this );

               // nodes are in document order, so we discard any nodes in questions/groups that have a disabled parent
               if ( $template.parentsUntil( '.or', '.or-branch' ).parentsUntil( '.or', '.disabled' ).length ) {
                   return;
               }

               newItems = {};
               prevItems = $template.data();
               templateNodeName = $template.prop( 'nodeName' ).toLowerCase();
               $list = $template.parent( 'select, datalist' );

               if ( templateNodeName === 'label' ) {
                   $input = $template.children( 'input' ).eq( 0 );
               } else if ( $list.prop( 'nodeName' ).toLowerCase() === 'select' ) {
                   $input = $list;
               } else if ( $list.prop( 'nodeName' ).toLowerCase() === 'datalist' ) {
                   $input = $list.siblings( 'input:not(.widget)' );
               }
               $labels = $template.closest( 'label, select, datalist' ).siblings( '.itemset-labels' );
               itemsXpath = $template.attr( 'data-items-path' );
               labelType = $labels.attr( 'data-label-type' );
               labelRef = $labels.attr( 'data-label-ref' );
               valueRef = $labels.attr( 'data-value-ref' );

               /**
                * CommCare/ODK change the context to the *itemset* value (in the secondary instance), hence they need to use the current()
                * function to make sure that relative paths in the nodeset predicate refer to the correct primary instance node
                * Enketo does *not* change the context. It uses the context of the question, not the itemset. Hence it has no need for current().
                * I am not sure what is correct, but for now for XLSForm-style secondary instances with only one level underneath the <item>s that
                * the nodeset retrieves, Enketo's aproach works well.
                */
               context = that.form.input.getName( $input );

               /*
                * Determining the index is expensive, so we only do this when the itemset is inside a cloned repeat.
                * It can be safely set to 0 for other branches.
                */
               insideRepeat = ( clonedRepeatsPresent && $input.parentsUntil( '.or', '.or-repeat' ).length > 0 ) ? true : false;
               insideRepeatClone = ( clonedRepeatsPresent && $input.parentsUntil( '.or', '.or-repeat.clone' ).length > 0 ) ? true : false;

               index = ( insideRepeatClone ) ? that.form.input.getIndex( $input ) : 0;

               if ( typeof itemsCache[ itemsXpath ] !== 'undefined' ) {
                   $instanceItems = itemsCache[ itemsXpath ];
               } else {
                   var safeToTryNative = true;
                   $instanceItems = $( that.form.model.evaluate( itemsXpath, 'nodes', context, index, safeToTryNative ) );
                   if ( !insideRepeat ) {
                       itemsCache[ itemsXpath ] = $instanceItems;
                   }
               }

               // This property allows for more efficient 'itemschanged' detection
               newItems.length = $instanceItems.length;
               // This may cause problems for large itemsets. Use md5 instead?
               newItems.text = $instanceItems.text();

               if ( newItems.length === prevItems.length && newItems.text === prevItems.text ) {
                   return;
               }

               $template.data( newItems );

               /**
                * Remove current items before rebuilding a new itemset from scratch.
                */
               // the current <option> and <input> elements
               $template.closest( '.question' )
                   .find( templateNodeName ).not( $template ).remove();
               // labels for current <option> elements
               $template.parent( 'select' ).siblings( '.or-option-translations' ).empty();

               $instanceItems.each( function() {
                   var $item = $( this );
                   var $labelRefs;
                   var labelRefNodename;
                   var matches;

                   $htmlItem = $( '<root/>' );

                   // Create a single <option> or <input> element for the (single) instance item.
                   $template
                       .clone().appendTo( $htmlItem )
                       .removeClass( 'itemset-template' )
                       .addClass( 'itemset' )
                       .removeAttr( 'data-items-path' );

                   // Determine which labels belong to the <option> or <input> element.
                   matches = utils.parseFunctionFromExpression( labelRef, 'translate' );
                   labelRefNodename = matches.length ? matches[ 0 ][ 1 ][ 0 ] : labelRef + ':eq(0)';
                   $labelRefs = $item.children( labelRefNodename );
                   /**
                    * Note: $labelRefs could either be
                    * - a single itext reference
                    * - a collection of labels with different lang attributes
                    * - a single label
                    */
                   if ( labelType !== 'itext' && $labelRefs.length > 0 ) {
                       // labels with different lang attributes
                       labelType = 'langs';
                   }
                   switch ( labelType ) {
                       case 'itext':
                           // Search in the special .itemset-labels created in enketo-transformer for labels with itext ref.
                           $htmlItemLabels = $labels.find( '[data-itext-id="' + $labelRefs.eq( 0 ).text() + '"]' ).clone();
                           break;
                       case 'langs':
                           $htmlItemLabels = $();
                           // Turn the item elements into label spans that <option> and <input> uses.
                           $labelRefs.each( function() {
                               var lang = this.getAttribute( 'lang' );
                               var langAttr = lang ? ' lang="' + this.getAttribute( 'lang' ) + '"' : '';
                               var active = !lang || lang === that.form.langs.getCurrentLang() ? ' active' : '';
                               var span = '<span class="option-label' + active + '"' + langAttr + '>' + this.textContent + '</span>';
                               $htmlItemLabels = $htmlItemLabels.add( span );
                           } );
                           break;
                       default:
                           // Create a single span without language.
                           $htmlItemLabels = $( '<span class="option-label active" lang="">' + $labelRefs.eq( 0 ).text() + '</span>' );
                   }

                   // Obtain the value of the secondary instance item found.
                   value = $item.children( valueRef ).text();

                   // Set the value of the new <option> or <input>.
                   $htmlItem.find( '[value]' ).attr( 'value', value );

                   if ( templateNodeName === 'label' ) {
                       $htmlItem.find( 'input' )
                           .after( $htmlItemLabels );
                       // Add the <input> (which is the first child of <root>).
                       $labels.before( $htmlItem.find( ':first' ) );
                   } else if ( templateNodeName === 'option' ) {
                       //if ( $htmlItemLabels.length === 1 ) {
                       $htmlItem.find( 'option' ).text( $htmlItemLabels.filter( '.active' ).eq( 0 ).text() );
                       //}
                       $htmlItemLabels
                           .attr( 'data-option-value', value )
                           .attr( 'data-itext-id', '' )
                           .appendTo( $labels.siblings( '.or-option-translations' ) );
                       // Add the <option> (which is the first child of <root>).
                       $template.siblings().addBack().last().after( $htmlItem.find( ':first' ) );
                   }
               } );

               /**
                * Attempt to populate inputs with current value in model.
                * Note that if the current value is not empty and the new itemset does not
                * include (an) item(s) with this/se value(s), this will clear/update the model and
                * this will trigger a dataupdate event. This may call this update function again.
                */
               currentValue = that.form.model.node( context, index ).getVal()[ 0 ];
               if ( currentValue !== '' ) {
                   that.form.input.setVal( context, index, currentValue );
                   $input.trigger( 'change' );
               }

               if ( $list.length > 0 ) {
                   // populate labels (with current language)
                   // TODO: is this actually required?
                   // that.langs.setSelect( $list );
                   // update widget
                   $input.trigger( 'changeoption' );
               }

           } );
       }
   };

   },{"jquery":"jquery","./utils":"utils"}],
   "language":[function(require,module,exports){
   'use strict';

   /**
    * Form languages module.
    */

   var $ = require( 'jquery' );

   module.exports = {
       init: function() {
           var that = this;
           var $langSelector = $( '.form-language-selector' );
           var currentDirectionality;

           if ( !this.form ) {
               throw new Error( 'Language module not correctly instantiated with form property.' );
           }

           this.$formLanguages = this.form.view.$.find( '#form-languages' );
           this.currentLang = this.$formLanguages.attr( 'data-default-lang' ) || this.$formLanguages.find( 'option' ).eq( 0 ).attr( 'value' );
           currentDirectionality = this.$formLanguages.find( '[value="' + this.currentLang + '"]' ).attr( 'data-dir' ) || 'ltr';

           this.$formLanguages
               .detach()
               .appendTo( $langSelector )
               .val( this.currentLang );

           this.form.view.$
               .attr( 'dir', currentDirectionality );

           if ( this.$formLanguages.find( 'option' ).length < 2 ) {
               return;
           }

           $langSelector.removeClass( 'hide' );

           this.$formLanguages.change( function( event ) {
               event.preventDefault();
               that.currentLang = $( this ).val();
               that.setAll( that.currentLang );
           } );
       },
       getCurrentLang: function() {
           return this.currentLang;
       },
       getCurrentLangDesc: function() {
           return this.$formLanguages.find( '[value="' + this.currentLang + '"]' ).text();
       },
       setAll: function( lang ) {
           var that = this;
           var dir = this.$formLanguages.find( '[value="' + lang + '"]' ).attr( 'data-dir' ) || 'ltr';

           this.form.view.$
               .attr( 'dir', dir )
               .find( '[lang]' )
               .removeClass( 'active' )
               .filter( '[lang="' + lang + '"], [lang=""]' )
               .filter( function() {
                   var $this = $( this );
                   return !$this.hasClass( 'or-form-short' ) || ( $this.hasClass( 'or-form-short' ) && $this.siblings( '.or-form-long' ).length === 0 );
               } )
               .addClass( 'active' );

           // For use in locale-sensitive XPath functions.
           // Don't even check whether it's a proper subtag or not. It will revert to client locale if it is not recognized.
           window.enketoFormLocale = lang;

           this.form.view.$.find( 'select, datalist' ).each( function() {
               that.setSelect( $( this ) );
           } );

           this.form.view.$.trigger( 'changelanguage' );
       },
       // swap language of <select> and <datalist> <option>s
       setSelect: function( $select ) {
           var value;
           var /** @type {string} */ curLabel;
           var /** @type {string} */ newLabel;
           $select.children( 'option' ).not( '[value=""], [data-value=""]' ).each( function() {
               var $option = $( this );
               curLabel = $option.text();
               value = $option.attr( 'value' ) || $option[ 0 ].dataset.value;
               newLabel = $option.closest( '.question' ).find( '.or-option-translations' )
                   .children( '.active[data-option-value="' + value + '"]' ).text().trim();
               newLabel = ( typeof newLabel !== 'undefined' && newLabel.length > 0 ) ? newLabel : curLabel;
               $option.text( newLabel );
           } );
       }
   };

   },{"jquery":"jquery"}],
   "output":[function(require,module,exports){
   'use strict';

   /**
    * Updates output values, optionally filtered by those values that contain a changed node name
    *
    * @param  {{nodes:Array<string>=, repeatPath: string=, repeatIndex: number=}=} updated The object containing info on updated data nodes
    */

   var $ = require( 'jquery' );

   module.exports = {
       update: function( updated ) {
           var expr;
           var clonedRepeatsPresent;
           var insideRepeat;
           var insideRepeatClone;
           var $context;
           var $output;
           var context;
           var index;
           var $nodes;
           var outputCache = {};
           var val = '';
           var that = this;

           if ( !this.form ) {
               throw new Error( 'Output module not correctly instantiated with form property.' );
           }

           $nodes = this.form.getRelatedNodes( 'data-value', '.or-output', updated );

           clonedRepeatsPresent = ( this.form.repeatsPresent && this.form.view.$.find( '.or-repeat.clone' ).length > 0 );

           $nodes.each( function() {
               $output = $( this );

               // nodes are in document order, so we discard any nodes in questions/groups that have a disabled parent
               if ( $output.closest( '.or-branch' ).parent().closest( '.disabled' ).length ) {
                   return;
               }

               expr = $output.attr( 'data-value' );
               /*
                * Note that in XForms input is the parent of label and in HTML the other way around so an output inside a label
                * should look at the HTML input to determine the context.
                * So, context is either the input name attribute (if output is inside input label),
                * or the parent with a name attribute
                * or the whole document
                */
               $context = $output.closest( '.question, .note, .or-group' ).find( '[name]' ).eq( 0 );
               context = ( $context.length ) ? that.form.input.getName( $context ) : undefined;

               insideRepeat = ( clonedRepeatsPresent && $output.parentsUntil( '.or', '.or-repeat' ).length > 0 );
               insideRepeatClone = ( insideRepeat && $output.parentsUntil( '.or', '.or-repeat.clone' ).length > 0 );
               index = ( insideRepeatClone ) ? that.form.input.getIndex( $context ) : 0;

               if ( typeof outputCache[ expr ] !== 'undefined' ) {
                   val = outputCache[ expr ];
               } else {
                   val = that.form.model.evaluate( expr, 'string', context, index, true );
                   if ( !insideRepeat ) {
                       outputCache[ expr ] = val;
                   }
               }
               if ( $output.text() !== val ) {
                   $output.text( val );
               }
           } );
       }
   };

   },{"jquery":"jquery"}],
   "page":[function(require,module,exports){
   'use strict';

   /**
    * Pages module.
    */

   var $ = require( 'jquery' );
   var Promise = require( 'lie' );
   var config = require( 'enketo-config' );

   require( 'jquery-touchswipe' );

   module.exports = {
       active: false,
       $current: [],
       $activePages: $(),
       init: function() {
           if ( !this.form ) {
               throw new Error( 'Repeats module not correclty instantiated with form property.' );
           }
           if ( this.form.view.$.hasClass( 'pages' ) ) {
               var $allPages = this.form.view.$.find( ' .question:not([role="comment"]), .or-appearance-field-list' )
                   .filter( function() {
                       // something tells me there is a more efficient way to doing this
                       // e.g. by selecting the descendants of the .or-appearance-field-list and removing those
                       return $( this ).parent().closest( '.or-appearance-field-list' ).length === 0;
                   } )
                   .attr( 'role', 'page' );

               if ( $allPages.length > 0 || $allPages.eq( 0 ).hasClass( 'or-repeat' ) ) {
                   this.$formFooter = $( '.form-footer' );
                   this.$btnFirst = this.$formFooter.find( '.first-page' );
                   this.$btnPrev = this.$formFooter.find( '.previous-page' );
                   this.$btnNext = this.$formFooter.find( '.next-page' );
                   this.$btnLast = this.$formFooter.find( '.last-page' );

                   this.updateAllActive( $allPages );
                   this.toggleButtons( 0 );
                   this.setButtonHandlers();
                   this.setRepeatHandlers();
                   this.setBranchHandlers();
                   this.setSwipeHandlers();
                   this.active = true;
                   this.flipToFirst();
               }
               /*else {
                   form.view.$.removeClass( 'pages' );
               }*/
           }
       },
       setButtonHandlers: function() {
           var that = this;
           // Make sure eventhandlers are not duplicated after resetting form.
           this.$btnFirst.off( '.pagemode' ).on( 'click.pagemode', function() {
               if ( !that.form.pageNavigationBlocked ) {
                   that.flipToFirst();
               }
               return false;
           } );
           this.$btnPrev.off( '.pagemode' ).on( 'click.pagemode', function() {
               if ( !that.form.pageNavigationBlocked ) {
                   that.prev();
               }
               return false;
           } );
           this.$btnNext.off( '.pagemode' ).on( 'click.pagemode', function() {
               if ( !that.form.pageNavigationBlocked ) {
                   that.next();
               }
               return false;
           } );
           this.$btnLast.off( '.pagemode' ).on( 'click.pagemode', function() {
               if ( !that.form.pageNavigationBlocked ) {
                   that.flipToLast();
               }
               return false;
           } );
       },
       setSwipeHandlers: function() {
           var that = this;
           var $main = $( '.main' );

           $main.swipe( 'destroy' );
           $main.swipe( {
               allowPageScroll: 'vertical',
               threshold: 250,
               swipeLeft: function() {
                   that.$btnNext.click();
               },
               swipeRight: function() {
                   that.$btnPrev.click();
               },
               swipeStatus: function( evt, phase ) {
                   if ( phase === 'start' ) {
                       /*
                        * Triggering blur will fire a change event on the currently focused form control
                        * This will trigger validation and is required to block page navigation on swipe
                        * with form.pageNavigationBlocked
                        * The only potential problem with this approach is that the threshold (250ms)
                        * may theoretically not be sufficient to ensure validation is completed to
                        * set form.pageNavigationBlocked to true. The edge case will be very slow devices
                        * and/or amazingly complex constraint expressions.
                        */
                       that.getCurrent().find( ':focus' ).blur();
                   }
               }
           } );
       },
       setRepeatHandlers: function() {
           var that = this;
           // TODO: can be optimized by smartly updating the active pages
           this.form.view.$
               .off( 'addrepeat.pagemode' )
               .on( 'addrepeat.pagemode', function( event, index, byCountUpdate ) {
                   that.updateAllActive();
                   // Removing the class in effect avoids the animation
                   // It also prevents multiple .or-repeat[role="page"] to be shown on the same page
                   $( event.target ).removeClass( 'current contains-current' ).find( '.current' ).removeClass( 'current' );
                   // Don't flip if the user didn't create the repeat with the + button.
                   if ( !byCountUpdate ) {
                       that.flipToPageContaining( $( event.target ) );
                   }
               } )
               .off( 'removerepeat.pagemode' )
               .on( 'removerepeat.pagemode', function( event ) {
                   // if the current page is removed
                   // note that that.$current will have length 1 even if it was removed from DOM!
                   if ( that.$current.closest( 'html' ).length === 0 ) {
                       that.updateAllActive();
                       // is it best to go to previous page always?
                       that.flipToPageContaining( $( event.target ) );
                   }
               } );
       },
       setBranchHandlers: function() {
           var that = this;
           // TODO: can be optimized by smartly updating the active pages
           this.form.view.$
               .off( 'changebranch.pagemode' )
               .on( 'changebranch.pagemode', function() {
                   that.updateAllActive();
                   that.toggleButtons();
               } );
       },
       getCurrent: function() {
           return this.$current;
       },
       updateAllActive: function( $all ) {
           $all = $all || $( '.or [role="page"]' );
           this.$activePages = $all.filter( function() {
               return $( this ).closest( '.disabled' ).length === 0 &&
                   ( $( this ).is( '.question' ) || $( this ).find( '.question:not(.disabled)' ).length > 0 );
           } );
       },
       getAllActive: function() {
           return this.$activePages;
       },
       getPrev: function( currentIndex ) {
           return this.$activePages[ currentIndex - 1 ];
       },
       getNext: function( currentIndex ) {
           return this.$activePages[ currentIndex + 1 ];
       },
       getCurrentIndex: function() {
           return this.$activePages.index( this.$current );
       },
       /**
        * Changes the `pages.next()` function to return a `Promise`, wrapping one of the following values:
        *
        * @return {Promise} wrapping {boolean} or {number}.  If a {number}, this is the index into
        *         `$activePages` of the new current page; if a {boolean}, {false} means that validation
        *         failed, and {true} that validation passed, but the page did not change.
        */
       next: function() {
           var that = this;
           var currentIndex;
           var validate;
           this.updateAllActive();
           currentIndex = this.getCurrentIndex();
           validate = ( config.validatePage === false ) ? Promise.resolve( true ) : this.form.validateContent( this.$current );

           return validate
               .then( function( valid ) {
                   var next, newIndex;

                   if ( !valid ) {
                       return false;
                   }

                   next = that.getNext( currentIndex );

                   if ( next ) {
                       newIndex = currentIndex + 1;
                       that.flipTo( next, newIndex );
                       return newIndex;
                   }

                   return true;
               } );
       },
       prev: function() {
           var prev;
           var currentIndex;
           this.updateAllActive();
           currentIndex = this.getCurrentIndex();
           prev = this.getPrev( currentIndex );

           if ( prev ) {
               this.flipTo( prev, currentIndex - 1 );
           }
       },
       setToCurrent: function( pageEl ) {
           var $n = $( pageEl );
           $n.addClass( 'current hidden' );
           this.$current = $n.removeClass( 'hidden' )
               .parentsUntil( '.or', '.or-group, .or-group-data, .or-repeat' ).addClass( 'contains-current' ).end();
       },
       flipTo: function( pageEl, newIndex ) {
           // if there is a current page
           if ( this.$current.length > 0 && this.$current.closest( 'html' ).length === 1 ) {
               // if current page is not same as pageEl
               if ( this.$current[ 0 ] !== pageEl ) {
                   this.$current.removeClass( 'current fade-out' ).parentsUntil( '.or', '.or-group, .or-group-data, .or-repeat' ).removeClass( 'contains-current' );
                   this.setToCurrent( pageEl );
                   this.focusOnFirstQuestion( pageEl );
                   this.toggleButtons( newIndex );
                   $( pageEl ).trigger( 'pageflip.enketo' );
               }
           } else {
               this.setToCurrent( pageEl );
               this.focusOnFirstQuestion( pageEl );
               this.toggleButtons( newIndex );
               $( pageEl ).trigger( 'pageflip.enketo' );
           }
       },
       flipToFirst: function() {
           this.updateAllActive();
           this.flipTo( this.$activePages[ 0 ] );
       },
       flipToLast: function() {
           this.updateAllActive();
           this.flipTo( this.$activePages.last()[ 0 ] );
       },
       // flips to the page provided as jQueried parameter or the page containing
       // the jQueried element provided as parameter
       // alternatively, (e.g. if a top level repeat without field-list appearance is provided as parameter)
       // it flips to the page contained with the jQueried parameter;
       flipToPageContaining: function( $e ) {
           var $closest;
           $closest = $e.closest( '[role="page"]' );
           $closest = ( $closest.length === 0 ) ? $e.find( '[role="page"]' ) : $closest;

           //this.updateAllActive();
           this.flipTo( $closest[ 0 ] );
       },
       focusOnFirstQuestion: function( pageEl ) {
           //triggering fake focus in case element cannot be focused (if hidden by widget)
           $( pageEl )
               .find( '.question:not(.disabled)' )
               .addBack( '.question:not(.disabled)' )
               .filter( function() {
                   return $( this ).parentsUntil( '.or', '.disabled' ).length === 0;
               } )
               .eq( 0 )
               .find( 'input, select, textarea' )
               .eq( 0 )
               .trigger( 'fakefocus' );

           pageEl.scrollIntoView();
       },
       toggleButtons: function( index ) {
           var i = index || this.getCurrentIndex(),
               next = this.getNext( i ),
               prev = this.getPrev( i );
           this.$btnNext.add( this.$btnLast ).toggleClass( 'disabled', !next );
           this.$btnPrev.add( this.$btnFirst ).toggleClass( 'disabled', !prev );
           this.$formFooter.toggleClass( 'end', !next );
       }
   };

   },{"jquery":"jquery","lie":"lie","enketo-config":"text!enketo-config","jquery-touchswipe":"jquery-touchswipe"}],
   "plugins":[function(require,module,exports){
   'use strict';
   var $ = require( 'jquery' );

   /**
    * Clears form input fields and triggers events when doing this. If formelement is cloned but not yet added to DOM
    * (and not synchronized with data object), the desired event is probably 'edit' (default). If it is already added
    * to the DOM (and synchronized with data object) a regular change event should be fired
    *
    * @param  {string=} ev1 event to be triggered when a value is cleared
    * @param  {string=} ev2 event to be triggered when a value is cleared
    * @return { jQuery} [description]
    */
   $.fn.clearInputs = function( ev1, ev2 ) {
       ev1 = ev1 || 'edit';
       ev2 = ev2 || '';
       return this.each( function() {
           //remove media previews
           $( this ).find( '.file-preview' ).remove();
           //remove input values
           $( this ).find( 'input, select, textarea' ).not( '.ignore' ).each( function() {
               var $node = $( this ),
                   type = $node.attr( 'type' );
               if ( $node.prop( 'nodeName' ).toUpperCase() === 'SELECT' ) {
                   type = 'select';
               }
               if ( $node.prop( 'nodeName' ).toUpperCase() === 'TEXTAREA' ) {
                   type = 'textarea';
               }
               switch ( type ) {
                   case 'date':
                   case 'datetime':
                   case 'time':
                   case 'number':
                   case 'search':
                   case 'color':
                   case 'range':
                   case 'url':
                   case 'email':
                   case 'password':
                   case 'text':
                   case 'file':
                       $node.removeAttr( 'data-previous-file-name data-loaded-file-name' );
                       /* falls through */
                   case 'hidden':
                   case 'textarea':
                       if ( $node.val() !== '' ) {
                           $node.val( '' ).trigger( ev1 ).trigger( ev2 );
                       }
                       break;
                   case 'radio':
                   case 'checkbox':
                       if ( $node.prop( 'checked' ) ) {
                           $node.prop( 'checked', false );
                           $node.trigger( ev1 ).trigger( ev2 );
                       }
                       break;
                   case 'select':
                       if ( $node[ 0 ].selectedIndex > 0 ) {
                           $node[ 0 ].selectedIndex = 0;
                           $node.trigger( ev1 ).trigger( ev2 );
                       }
                       break;
                   default:
                       console.error( 'Unrecognized input type found when trying to reset', this );
               }
           } );
       } );
   };

   /**
    * Reverses a jQuery collection
    * @type {Array}
    */
   $.fn.reverse = [].reverse;

   },{"jquery":"jquery"}],
   "preload":[function(require,module,exports){
   'use strict';

   var $ = require( 'jquery' );

   /*
    * Preloader module.
    *
    * Note that preloaders may be deprecated in the future. This code is already prepared for a change
    * by using a (secret) "session" instance.
    *
    * Functions are designed to fail silently if unknown preloaders are called.
    */
   module.exports = {
       init: function() {
           var item;
           var param;
           var curVal;
           var newVal;
           var dataNode;
           var props;
           var $preload;
           var that = this;

           if ( !this.form ) {
               throw new Error( 'Preload module not correctly instantiated with form property.' );
           }

           //these initialize actual preload items
           this.form.view.$.find( 'input[data-preload], select[data-preload], textarea[data-preload]' ).each( function() {
               $preload = $( this );
               props = that.form.input.getProps( $preload );
               item = $preload.attr( 'data-preload' ).toLowerCase();
               param = $preload.attr( 'data-preload-params' ).toLowerCase();

               if ( typeof that[ item ] !== 'undefined' ) {
                   dataNode = that.form.model.node( props.path, props.index );
                   curVal = dataNode.getVal()[ 0 ];
                   newVal = that[ item ]( {
                       param: param,
                       curVal: curVal,
                       dataNode: dataNode
                   } );

                   dataNode.setVal( newVal, null, props.xmlType );
               } else {
                   console.log( 'Preload "' + item + '" not supported. May or may not be a big deal.' );
               }
           } );
       },
       'timestamp': function( o ) {
           var value;
           var that = this;
           // when is 'start' or 'end'
           if ( o.param === 'start' ) {
               return ( o.curVal.length > 0 ) ? o.curVal : this.form.model.evaluate( 'now()', 'string' );
           }
           if ( o.param === 'end' ) {
               //set event handler for each save event (needs to be triggered!)
               this.form.view.$.on( 'beforesave', function() {
                   value = that.form.model.evaluate( 'now()', 'string' );
                   o.dataNode.setVal( value, null, 'datetime' );
               } );
               //TODO: why populate this upon load?
               return this.form.model.evaluate( 'now()', 'string' );
           }
           return 'error - unknown timestamp parameter';
       },
       'date': function( o ) {
           var today;
           var year;
           var month;
           var day;

           if ( o.curVal.length === 0 ) {
               today = new Date( this.form.model.evaluate( 'today()', 'string' ) );
               year = today.getFullYear().toString().pad( 4 );
               month = ( today.getMonth() + 1 ).toString().pad( 2 );
               day = today.getDate().toString().pad( 2 );

               return year + '-' + month + '-' + day;
           }
           return o.curVal;
       },
       'property': function( o ) {
           var node;

           // 'deviceid', 'subscriberid', 'simserial', 'phonenumber'
           if ( o.curVal.length === 0 ) {
               node = this.form.model.node( 'instance("__session")/session/context/' + o.param );
               if ( node.get().length ) {
                   return node.getVal()[ 0 ];
               } else {
                   return 'no ' + o.param + ' property in enketo';
               }
           }
           return o.curVal;
       },
       'context': function( o ) {
           // 'application', 'user'??
           if ( o.curVal.length === 0 ) {
               return ( o.param === 'application' ) ? 'enketo' : o.param + ' not supported in enketo';
           }
           return o.curVal;
       },
       'patient': function( o ) {
           if ( o.curVal.length === 0 ) {
               return 'patient preload item not supported in enketo';
           }
           return o.curVal;
       },
       'user': function( o ) {
           if ( o.curVal.length === 0 ) {
               return 'user preload item not supported in enketo yet';
           }
           return o.curVal;
       },
       'uid': function( o ) {
           if ( o.curVal.length === 0 ) {
               return this.form.model.evaluate( 'concat("uuid:", uuid())', 'string' );
           }
           return o.curVal;
       }
   };

   },{"jquery":"jquery"}],
   "print":[function(require,module,exports){
   'use strict';

   /**
    * Deals with printing
    */

   var $ = require( 'jquery' );
   var dpi, printStyleSheet;
   var $printStyleSheetLink;

   // make sure setDpi is not called until DOM is ready
   $( document ).ready( function() {
       setDpi();
   } );

   /**
    * Calculates the dots per inch and sets the dpi property
    */
   function setDpi() {
       var dpiO = {};
       var e = document.body.appendChild( document.createElement( 'DIV' ) );
       e.style.width = '1in';
       e.style.padding = '0';
       dpiO.v = e.offsetWidth;
       e.parentNode.removeChild( e );
       dpi = dpiO.v;
   }

   /**
    * Gets print stylesheets
    * @return {Element} [description]
    */
   function getPrintStyleSheet() {
       var sheet;
       // document.styleSheets is an Object not an Array!
       for ( var i in document.styleSheets ) {
           if ( document.styleSheets.hasOwnProperty( i ) ) {
               sheet = document.styleSheets[ i ];
               if ( sheet.media.mediaText === 'print' ) {
                   return sheet;
               }
           }
       }
       return null;
   }

   function getPrintStyleSheetLink() {
       return $( 'link[media="print"]:eq(0)' );
   }

   /**
    * Applies the print stylesheet to the current view by changing stylesheets media property to 'all'
    */
   function styleToAll() {
       // sometimes, setStylesheet fails upon loading
       printStyleSheet = printStyleSheet || getPrintStyleSheet();
       $printStyleSheetLink = $printStyleSheetLink || getPrintStyleSheetLink();
       // Chrome:
       printStyleSheet.media.mediaText = 'all';
       // Firefox:
       $printStyleSheetLink.attr( 'media', 'all' );
   }

   /**
    * Resets the print stylesheet to only apply to media 'print'
    */
   function styleReset() {
       printStyleSheet.media.mediaText = 'print';
       $printStyleSheetLink.attr( 'media', 'print' );
       $( '.print-height-adjusted, .print-width-adjusted, .main' )
           .removeAttr( 'style' )
           .removeClass( 'print-height-adjusted print-width-adjusted' );
       $( '.back-to-screen-view' ).off( 'click' ).remove();
   }

   function isGrid() {
       return /theme-.*grid.*/.test( $( 'form.or' ).attr( 'class' ) );
   }

   function fixGrid( paper ) {
       var $row, $el, top, rowTop, maxWidth, diff;

       // to ensure cells grow correctly with text-wrapping before fixing heights and widths.
       $( '.main' ).css( 'width', getPaperPixelWidth( paper ) ).addClass( 'print-width-adjusted' );
       // wait for browser repainting after width change
       setTimeout( function() {
           // the -1px adjustment is necessary because the h3 element width is calc(100% + 1px)
           maxWidth = $( '#form-title' ).outerWidth() - 1;
           $( '.question, .note, .trigger' ).not( '.draft' ).each( function() {
               $el = $( this );
               top = $el.offset().top;
               rowTop = ( rowTop || rowTop === 0 ) ? rowTop : top;
               $row = $row || $el;

               if ( top === rowTop ) {
                   $row = $row.add( $el );
               } else if ( top > rowTop ) {
                   var height,
                       widths = [],
                       cumulativeWidth = 0,
                       maxHeight = 0;

                   $row.each( function() {
                       height = $( this ).outerHeight();
                       maxHeight = ( height > maxHeight ) ? height : maxHeight;
                       widths.push( Number( $( this ).css( 'width' ).replace( 'px', '' ) ) );
                   } );
                   $row.addClass( 'print-height-adjusted' ).css( 'height', maxHeight + 'px' );

                   // adjusts widths if w-values don't add up to 100%
                   widths.forEach( function( width ) {
                       cumulativeWidth += width;
                   } );

                   if ( cumulativeWidth < maxWidth ) {

                       diff = maxWidth - cumulativeWidth;
                       $row.each( function( index ) {
                           var width = widths[ index ] + ( widths[ index ] / cumulativeWidth ) * diff;
                           // round down to 2 decimals to avoid 100.001% totals
                           $( this )
                               .css( 'width', ( Math.floor( ( width * 100 / maxWidth ) * 100 ) / 100 ) + '%' )
                               .addClass( 'print-width-adjusted' );
                       } );
                   }
                   // start a new row
                   $row = $el;
                   rowTop = $el.offset().top;
               } else {
                   console.error( 'unexpected question top position: ', top, 'for element:', $el, 'expected >=', rowTop );
               }
           } );
           // Chrome 34 doesn't like the fact that main has an inline fixed width (see issue #99)
           // since we do not need it any more, after we have set the adjusted widths to a %-value, we can remove it.
           $( '.main' ).css( 'width', 'auto' ).removeClass( 'print-width-adjusted' );

           $( window ).trigger( 'printviewready' );
       }, 1000 );
   }

   function getPaperPixelWidth( paper ) {
       var printWidth;
       // the final margin is determined by the browser's print functionality
       // better too large than too small here
       var margin = 0.4;
       var formats = {
           A4: {
               width: 8.27,
               height: 11.69
           },
           letter: {
               width: 8.5,
               height: 11
           }
       };

       printWidth = ( paper.orientation === 'portrait' ) ? formats[ paper.format ].width : formats[ paper.format ].height;

       return ( ( printWidth - ( 2 * margin ) ) * dpi ) + 'px';
   }

   /**
    * Show print setting dialog and proceed upon user's direction.
    */
   function confirmPaperSettingsAndPrint( confirm ) {
       var texts = {
           dialog: 'print',
           heading: 'Select Print Settings'
       };
       var options = {
           posButton: 'Prepare',
           posAction: function( values ) {
               fixGrid( values );
               $( window ).one( 'printviewready', function() {
                   window.print();
               } );
           },
           negButton: 'Close',
           negAction: function() {
               styleReset();
           },
           afterAction: function() {
               setTimeout( function() {
                   styleReset();
               }, 1500 );
           }
       };

       // TODO: would be nice if fixGrid can become synchronous again or
       // a progress is shown when it is churning away.

       confirm( texts, options );
   }

   /**
    * Prints the form after first setting page breaks (every time it is called)
    */
   function printForm( confirm ) {
       if ( isGrid() ) {
           styleToAll();
           // add temp reset button, just in case somebody gets stuck in print view
           $( '<button class="btn back-to-screen-view">Back to Normal View</button>' ).prependTo( $( 'form.or' ) ).on( 'click', function() {
               styleReset();
           } );
           confirmPaperSettingsAndPrint( confirm );
       } else {
           window.print();
       }
   }

   module.exports = printForm;

   },{"jquery":"jquery"}],
   "progress":[function(require,module,exports){
   'use strict';

   /**
    * Progress module.
    */

   var $ = require( 'jquery' );

   /**
    * Maintains progress state of user traversing through form, using
    * currently focused input || last changed input as current location.
    */
   module.exports = {
       status: 0,
       lastChanged: null,
       $all: null,
       updateTotal: function() {
           this.$all = this.form.view.$.find( '.question' ).not( '.disabled, .or-appearance-comment, .or-appearance-dn' ).filter( function() {
               return $( this ).parentsUntil( '.or', '.disabled' ).length === 0;
           } );
       },
       // updates rounded % value of progress and triggers event if changed
       update: function( el ) {
           var status;

           if ( !this.$all || !el ) {
               this.updateTotal();
           }

           this.lastChanged = el || this.lastChanged;
           status = Math.round( ( ( this.$all.index( $( this.lastChanged ).closest( '.question' ) ) + 1 ) * 100 ) / this.$all.length );

           // if the current el was removed (inside removed repeat), the status will be 0 - leave unchanged
           if ( status > 0 && status !== this.status ) {
               this.status = status;
               this.form.view.$.trigger( 'progressupdate.enketo', status );
           }
       },
       get: function() {
           return this.status;
       }
   };

   },{"jquery":"jquery"}],
   "repeat":[function(require,module,exports){
   'use strict';

   /**
    * Repeats module.
    *
    * Two important concepts are used:
    * 1. The first XLST-added repeat view is cloned to serve as a template of that repeat.
    * 2. Each repeat series has a sibling .or-repeat-info element that stores info that is relevant to that series.
    *
    * Note that with nested repeats you may have many more series of repeats than templates, because a nested repeat
    * may have multiple series.
    */

   var $ = require( 'jquery' );
   var config = require( 'enketo-config' );

   module.exports = {
       /**
        * Initializes all Repeat Groups in form (only called once).
        * @param  {Form} form the parent form object
        */
       init: function() {
           var that = this;
           var $repeatInfos;

           if ( !this.form ) {
               throw new Error( 'Repeat module not correctly instantiated with form property.' );
           }

           $repeatInfos = this.form.view.$.find( '.or-repeat-info' );
           this.templates = {};
           $repeatInfos.siblings( '.or-repeat' )
               .prepend( '<span class="repeat-number"></span>' );
           $repeatInfos.filter( '*:not([data-repeat-fixed]):not([data-repeat-count])' ).siblings( '.or-repeat' )
               .append( '<div class="repeat-buttons"><button type="button" class="btn btn-default repeat"><i class="icon icon-plus"> </i></button>' +
                   '<button type="button" disabled class="btn btn-default remove"><i class="icon icon-minus"> </i></button></div>' );

           /**
            * The model also requires storing repeat templates for repeats that do not have a jr:template.
            * Since the model has no knowledge of which node is a repeat, we do this here.
            */
           this.form.model.extractFakeTemplates( $repeatInfos.map( function() {
               return this.dataset.name;
           } ).get() );

           /**
            * Clone all repeats to serve as templates
            * in reverse document order to properly deal with nested repeat templates
            *
            * Widgets not yet initialized. Values not yet set.
            */
           $repeatInfos.siblings( '.or-repeat' ).clone().reverse().each( function() {
               var $templateEl = $( this );
               var xPath = $templateEl.attr( 'name' );
               that.templates[ xPath ] = $templateEl;
           } );

           $repeatInfos.filter( '*:not([data-repeat-count])' ).each( function() {
               // If there is no repeat-count attribute, check how many repeat instances
               // are in the model, and update view if necessary.
               that.updateViewInstancesFromModel( $( this ) );

           } );

           // delegated handlers (strictly speaking not required, but checked for doubling of events -> OK)
           this.form.view.$.on( 'click', 'button.repeat:enabled', function() {
               // Create a clone
               that.clone( $( this ).closest( '.or-repeat' ).siblings( '.or-repeat-info' ).eq( 0 ) );
               // Prevent default
               return false;
           } );
           this.form.view.$.on( 'click', 'button.remove:enabled', function() {
               //remove clone
               that.remove( $( this ).closest( '.or-repeat.clone' ) );
               //prevent default
               return false;
           } );

           this.countUpdate();
       },
       updateViewInstancesFromModel: function( $repeatInfo ) {
           var that = this;
           var repeatPath = $repeatInfo.data( 'name' );
           // All we need is to find out in which series we are.
           var repeatSeriesIndex = this.form.view.$.find( '.or-repeat-info[data-name="' + repeatPath + '"]' ).index( $repeatInfo );
           var repInModelSeries = this.form.model.getRepeatSeries( repeatPath, repeatSeriesIndex );
           var repInViewSeries = $repeatInfo.siblings( '.or-repeat' );
           // First rep is already included (by XSLT transformation)
           if ( repInModelSeries.length > repInViewSeries.length ) {
               this.clone( $repeatInfo, repInModelSeries.length - repInViewSeries.length );
               // Now check the repeat counts of all the descendants of this repeat and its new siblings
               // Note: not tested with triple-nested repeats, but probably taking the better safe-than-sorry approach,
               // so should be okay except for performance.
               $repeatInfo.siblings( '.or-repeat' )
                   .find( '.or-repeat-info:not([data-repeat-count])' )
                   .each( function() {
                       that.updateViewInstancesFromModel( $( this ) );
                   } );
           }
       },
       updateRepeatInstancesFromCount: function( $info ) {
           var that = this;
           var $last = $info.siblings( '.or-repeat' ).last();
           var repCountPath = $info.data( 'repeatCount' ) || '';
           var name = $info.data( 'name' );
           var index = this.form.view.$.find( '.or-repeat[name="' + name + '"]' ).index( $last );
           var numRepsInView = $info.siblings( '.or-repeat[name="' + name + '"]' ).length;
           var numRepsInCount;
           var toCreate;
           // Don't pass context if the context is gone because all repeats in a series have been deleted.
           if ( index === -1 ) {
               name = null;
               index = null;
           }
           numRepsInCount = ( repCountPath.length > 0 ) ? this.form.model.evaluate( repCountPath, 'number', name, index, true ) : 0;
           numRepsInCount = isNaN( numRepsInCount ) ? 0 : numRepsInCount;
           toCreate = numRepsInCount - numRepsInView;

           if ( toCreate > 0 ) {
               that.clone( $info, toCreate );
           } else if ( toCreate < 0 ) {
               // temporary undocumented way to disable ability to remove first repeat
               toCreate = Math.abs( toCreate ) >= numRepsInView ? -numRepsInView + ( config.repeatOrdinals === true ? 1 : 0 ) : toCreate;
               for ( ; toCreate < 0; toCreate++ ) {
                   $last = $info.siblings( '.or-repeat' ).last();
                   this.remove( $last, 0 );
               }
           }
           // Now check the repeat counts of all the descendants of this repeat and its new siblings, level-by-level.
           // TODO: this does not find .or-repeat > .or-repeat (= unusual syntax)
           $info.siblings( '.or-repeat' )
               .children( '.or-group, .or-group-data' )
               .children( '.or-repeat-info[data-repeat-count]' )
               .each( function() {
                   that.updateRepeatInstancesFromCount( $( this ) );
               } );
       },
       /**
        * Checks whether repeat count value has been updated and updates repeat instances
        * accordingly.
        *
        * @param  {[type]} updated [description]
        * @return {[type]}         [description]
        */
       countUpdate: function( updated ) {
           var $repeatInfos;
           var that = this;

           updated = updated || {};
           $repeatInfos = this.form.getRelatedNodes( 'data-repeat-count', '.or-repeat-info', updated );

           $repeatInfos.each( function() {
               that.updateRepeatInstancesFromCount( $( this ) );
           } );
       },
       /**s
        * clone a repeat group/node
        * @param   {jQuery} $node node to clone
        * @param   {number=} count number of clones to create
        * @return  {boolean}       [description]
        */
       clone: function( $info, count ) {
           var $repeats;
           var $clone;
           var $repeatsToUpdate;
           var repeatIndex;
           var repeatSeriesIndex;
           var repeatPath;
           var i;
           var that = this;
           var byCountUpdate = !!count;
           var modelRepeatSeries;

           count = count || 1;

           if ( $info.length !== 1 ) {
               console.error( 'Nothing to clone' );
               return false;
           }

           repeatPath = $info.data( 'name' );
           $repeats = $info.siblings( '.or-repeat' );

           // Add clone class to allow some simplistic performance optimization elsewhere.
           $clone = this.templates[ repeatPath ].clone().addClass( 'clone' );
           // Determine the index of the repeat series.
           repeatSeriesIndex = this.form.view.$.find( '.or-repeat-info[data-name="' + repeatPath + '"]' ).index( $info );

           // Add required number of repeats
           for ( i = 0; i < count; i++ ) {
               // Fix names of radio button groups
               $clone.find( '.option-wrapper' ).each( this.fixRadioNames );
               // Insert the clone
               $clone.insertBefore( $info );
               // Update the variable containing the view repeats in the current series.
               $repeats = $repeats.add( $clone );
               // TODO: not efficient, could be incremental
               modelRepeatSeries = this.form.model.getRepeatSeries( repeatPath, repeatSeriesIndex );
               // Create a repeat in the model if it doesn't already exist
               if ( $repeats.length > modelRepeatSeries.length ) {
                   this.form.model.cloneRepeat( repeatPath, repeatSeriesIndex );
               }
               // This is the index of the new repeat in relation to all other repeats of the same name,
               // even if they are in different series.
               repeatIndex = repeatIndex || this.form.view.$.find( '.or-repeat[name="' + repeatPath + '"]' ).index( $clone );
               // This will trigger setting default values and automatic page flips.
               $clone.trigger( 'addrepeat', [ repeatIndex, byCountUpdate ] );
               // Initialize widgets in clone after default values have been set
               if ( this.form.widgetsInitialized ) {
                   this.form.widgets.init( $clone );
               } else {
                   // Upon inital formload the eventhandlers for calculated items have not yet been set.
                   // Calculations have already been initialized before the repeat clone(s) were created.
                   // Therefore, we manually trigger a calculation update for the cloned repeat.
                   that.form.calc.update( {
                       repeatPath: repeatPath,
                       repeatIndex: repeatIndex
                   } );
               }

               $clone = this.templates[ repeatPath ].clone().addClass( 'clone' );
               repeatIndex++;
           }

           $repeatsToUpdate = $repeats.add( $repeats.find( '.or-repeat' ) );
           // number the repeats
           this.numberRepeats( $repeatsToUpdate );
           // enable or disable + and - buttons
           this.toggleButtons( $repeatsToUpdate );

           return true;
       },
       remove: function( $repeat, delay ) {
           var that = this;
           var $prev = $repeat.prev( '.or-repeat' );
           var repeatPath = $repeat.attr( 'name' );
           var repeatIndex = this.form.view.$.find( '.or-repeat[name="' + repeatPath + '"]' ).index( $repeat );
           var $siblings = $repeat.siblings( '.or-repeat' );

           delay = typeof delay !== 'undefined' ? delay : 600;

           $repeat.hide( delay, function() {
               $repeat.remove();
               that.numberRepeats( $siblings );
               that.toggleButtons( $siblings );
               // Trigger the removerepeat on the previous repeat (always present)
               // so that removerepeat handlers know where the repeat was removed
               $prev.trigger( 'removerepeat' );
               // Now remove the data node
               that.form.model.node( repeatPath, repeatIndex ).remove();
           } );
       },
       fixRadioNames: function( index, element ) {
           $( element ).find( 'input[type="radio"]' )
               .attr( 'name', Math.floor( ( Math.random() * 10000000 ) + 1 ) );
       },
       toggleButtons: function( $repeats ) {
           var $repeat;
           var $repSiblingsAndSelf;

           $repeats = ( !$repeats || $repeats.length === 0 ) ? $() : $repeats;

           $repeats.each( function() {
               $repeat = $( this );
               $repSiblingsAndSelf = $repeat.siblings( '.or-repeat' ).addBack();
               //first switch everything off and remove hover state
               $repSiblingsAndSelf.children( '.repeat-buttons' ).find( 'button.repeat, button.remove' ).prop( 'disabled', true );

               //then enable the appropriate ones
               $repSiblingsAndSelf.last().children( '.repeat-buttons' ).find( 'button.repeat' ).prop( 'disabled', false );
               $repSiblingsAndSelf.children( '.repeat-buttons' ).find( 'button.remove' ).not( ':first' ).prop( 'disabled', false );
           } );
       },
       numberRepeats: function( $repeats ) {
           $repeats.each( function() {
               var $repSiblings;
               var qtyRepeats;
               var i;
               var $repeat = $( this );
               // if it is the first-of-type (not that ':first-of-type' does not have cross-browser support)
               if ( $repeat.prev( '.or-repeat' ).length === 0 ) {
                   $repSiblings = $( this ).siblings( '.or-repeat' );
                   qtyRepeats = $repSiblings.length + 1;
                   if ( qtyRepeats > 1 ) {
                       $repeat.find( '.repeat-number' ).text( '1' );
                       i = 2;
                       $repSiblings.each( function() {
                           $( this ).find( '.repeat-number' ).eq( 0 ).text( i );
                           i++;
                       } );
                   } else {
                       $repeat.find( '.repeat-number' ).eq( 0 ).empty();
                   }
               }
           } );
       }
   };

   },{"jquery":"jquery","enketo-config":"text!enketo-config"}],
   "support":[function(require,module,exports){
   'use strict';

   /**
    * Detects features. Replacement for Modernizr.
    */

   var features = {
           inputtypes: {}
       },
       inputTypesToTest = [ 'date', 'datetime', 'time' ];

   // test input types
   inputTypesToTest.forEach( function( inputType ) {
       var input = document.createElement( 'input' );
       input.setAttribute( 'type', inputType );
       features.inputtypes[ inputType ] = input.type !== 'text';
   } );

   // test touchscreen presence
   if ( ( 'ontouchstart' in window ) || window.DocumentTouch && document instanceof window.DocumentTouch ) {
       features.touch = true;
       document.documentElement.classList.add( 'touch' );
   } else {
       features.touch = false;
   }

   module.exports = features;

   },{}],
   "types":[function(require,module,exports){
   'use strict';

   var utils = require( './utils' );
   var types = {
       'string': {
           //max length of type string is 255 chars.Convert( truncate ) silently ?
           validate: function() {
               return true;
           }
       },
       'select': {
           validate: function() {
               return true;
           }
       },
       'select1': {
           validate: function() {
               return true;
           }
       },
       'decimal': {
           convert: function( x ) {
               var num = Number( x );
               if ( isNaN( num ) || num === Number.POSITIVE_INFINITY || num === Number.NEGATIVE_INFINITY ) {
                   // Comply with XML schema decimal type that has no special values. '' is our only option.
                   return '';
               }
               return num;
           },
           validate: function( x ) {
               var num = Number( x );
               return ( !isNaN( num ) && num !== Number.POSITIVE_INFINITY && num !== Number.NEGATIVE_INFINITY ) ? true : false;
           }
       },
       'int': {
           convert: function( x ) {
               var num = Number( x );
               if ( isNaN( num ) || num === Number.POSITIVE_INFINITY || num === Number.NEGATIVE_INFINITY ) {
                   // Comply with XML schema int type that has no special values. '' is our only option.
                   return '';
               }
               return ( num >= 0 ) ? Math.floor( num ) : -Math.floor( Math.abs( num ) );
           },
           validate: function( x ) {
               var num = Number( x );
               return ( !isNaN( num ) && num !== Number.POSITIVE_INFINITY && num !== Number.NEGATIVE_INFINITY && Math.round( num ) === num ) ? true : false;
           }
       },
       'date': {
           validate: function( x ) {
               var pattern = /([0-9]{4})([\-]|[\/])([0-9]{2})([\-]|[\/])([0-9]{2})/;
               var segments = pattern.exec( x );

               return ( segments && segments.length === 6 ) ? ( new Date( Number( segments[ 1 ] ), Number( segments[ 3 ] ) - 1, Number( segments[ 5 ] ) ).toString() !== 'Invalid Date' ) : false;
           },
           convert: function( x ) {
               var pattern = /([0-9]{4})([\-]|[\/])([0-9]{2})([\-]|[\/])([0-9]{2})/;
               var segments;
               var date;

               if ( utils.isNumber( x ) ) {
                   // The XPath expression "2012-01-01" + 2 returns a number of days in XPath.
                   date = new Date( x * 24 * 60 * 60 * 1000 );
               } else {
                   date = new Date( x );
                   if ( date.toString() === 'Invalid Date' ) {
                       segments = pattern.exec( x );
                       //this code is really only meant for the Rhino and PhantomJS engines, in browsers it may never be reached
                       if ( segments && Number( segments[ 1 ] ) > 0 && Number( segments[ 3 ] ) >= 0 && Number( segments[ 3 ] ) < 12 && Number( segments[ 5 ] ) < 32 ) {
                           date = new Date( Number( segments[ 1 ] ), ( Number( segments[ 3 ] ) - 1 ), Number( segments[ 5 ] ) );
                       }
                   }
               }

               return date.toString() === 'Invalid Date' ?
                   '' : date.getUTCFullYear().toString().pad( 4 ) + '-' + ( date.getUTCMonth() + 1 ).toString().pad( 2 ) + '-' + date.getUTCDate().toString().pad( 2 );
           }
       },
       'datetime': {
           validate: function( x ) {
               //the second part builds in some tolerance for slightly-off dates provides as defaults (e.g.: 2013-05-31T07:00-02)
               return ( new Date( x.toString() ).toString() !== 'Invalid Date' || new Date( this.convert( x.toString() ) ).toString() !== 'Invalid Date' );
           },
           convert: function( x ) {
               var date;
               var patternCorrect = /([0-9]{4}\-[0-9]{2}\-[0-9]{2})([T]|[\s])([0-9]){2}:([0-9]){2}([0-9:.]*)(\+|\-)([0-9]{2}):([0-9]{2})$/;
               var patternAlmostCorrect = /([0-9]{4}\-[0-9]{2}\-[0-9]{2})([T]|[\s])([0-9]){2}:([0-9]){2}([0-9:.]*)(\+|\-)([0-9]{2})$/;

               if ( utils.isNumber( x ) ) {
                   // The XPath expression "2012-01-01T01:02:03+01:00" + 2 returns a number of days in XPath.
                   date = new Date( x * 24 * 60 * 60 * 1000 );
               } else if ( new Date( x ).toString() !== 'Invalid Date' && patternCorrect.test( x ) ) {
                   // Do not risk changing the time zone by calling toISOLocalString()
                   return x;
               } else if ( new Date( x ).toString() === 'Invalid Date' && patternAlmostCorrect.test( x ) ) {
                   // Do not risk changing the time zone by calling toISOLocalString()
                   return x + ':00';
               } else {
                   date = new Date( x );
               }

               return ( date.toString() !== 'Invalid Date' ) ? date.toISOLocalString() : '';
           }
       },
       'time': {
           validate: function( x ) {
               var segments = x.toString().split( ':' );
               if ( segments.length < 2 ) {
                   return false;
               }
               segments[ 2 ] = ( segments[ 2 ] ) ? Number( segments[ 2 ].toString().split( '.' )[ 0 ] ) : 0;

               return ( segments[ 0 ] < 24 && segments[ 0 ] >= 0 && segments[ 1 ] < 60 && segments[ 1 ] >= 0 && segments[ 2 ] < 60 && segments[ 2 ] >= 0 );
           },
           convert: function( x ) {
               var date;
               var timeAppearsCorrect = /^[0-9]{2}:[0-9]{2}(:[0-9.]*)?$/;

               if ( !timeAppearsCorrect.test( x ) ) {
                   // An XPath expression would return a datetime string since there is no way to request a timeValue.
                   // We can test this by trying to convert to a date.
                   date = new Date( x );
                   if ( date.toString() !== 'Invalid Date' ) {
                       x = date.getHours() + ':' + date.getMinutes() + ':' + date.getSeconds();
                   }
               }

               // add padding
               x = x.toString()
                   .split( ':' )
                   .map( function( segment ) {
                       return segment.toString().pad( 2 );
                   } )
                   .join( ':' );

               return this.validate( x ) ? x : '';
           }
       },
       'barcode': {
           validate: function() {
               return true;
           }
       },
       'geopoint': {
           validate: function( x ) {
               var coords = x.toString().trim().split( ' ' );
               return ( coords[ 0 ] !== '' && coords[ 0 ] >= -90 && coords[ 0 ] <= 90 ) &&
                   ( coords[ 1 ] !== '' && coords[ 1 ] >= -180 && coords[ 1 ] <= 180 ) &&
                   ( typeof coords[ 2 ] === 'undefined' || !isNaN( coords[ 2 ] ) ) &&
                   ( typeof coords[ 3 ] === 'undefined' || ( !isNaN( coords[ 3 ] ) && coords[ 3 ] >= 0 ) );
           },
           convert: function( x ) {
               return x.toString().trim();
           }
       },
       'geotrace': {
           validate: function( x ) {
               var geopoints = x.toString().split( ';' );
               return geopoints.length >= 2 && geopoints.every( function( geopoint ) {
                   return types.geopoint.validate( geopoint );
               } );
           },
           convert: function( x ) {
               return x.toString().trim();
           }
       },
       'geoshape': {
           validate: function( x ) {
               var geopoints = x.toString().split( ';' );
               return geopoints.length >= 4 && ( geopoints[ 0 ] === geopoints[ geopoints.length - 1 ] ) && geopoints.every( function( geopoint ) {
                   return types.geopoint.validate( geopoint );
               } );
           },
           convert: function( x ) {
               return x.toString().trim();
           }
       },
       'binary': {
           validate: function() {
               return true;
           }
       }
   };

   module.exports = types;

   },{"./utils":"utils"}],
   "utils":[function(require,module,exports){
   'use strict';

   var cookies;

   /**
    * Parses an Expression to extract all function calls and theirs argument arrays.
    *
    * @param  {String} expr The expression to search
    * @param  {String} func The function name to search for
    * @return {<String, <String*>>} The result array, where each result is an array containing the function call and array of arguments.
    */
   function parseFunctionFromExpression( expr, func ) {
       var index;
       var result;
       var openBrackets;
       var start;
       var argStart;
       var args;
       var findFunc = new RegExp( func + '\\s*\\(', 'g' );
       var results = [];

       if ( !expr || !func ) {
           return results;
       }

       while ( ( result = findFunc.exec( expr ) ) !== null ) {
           openBrackets = 1;
           args = [];
           start = result.index;
           index = findFunc.lastIndex;
           argStart = index;
           while ( openBrackets !== 0 ) {
               index++;
               if ( expr[ index ] === '(' ) {
                   openBrackets++;
               } else if ( expr[ index ] === ')' ) {
                   openBrackets--;
               } else if ( expr[ index ] === ',' && openBrackets === 1 ) {
                   args.push( expr.substring( argStart, index ).trim() );
                   argStart = index + 1;
               }
           }
           // add last argument
           args.push( expr.substring( argStart, index ).trim() );

           // add [ 'function( a ,b)', ['a','b'] ] to result array
           results.push( [ expr.substring( start, index + 1 ), args ] );
       }

       return results;
   }

   function stripQuotes( str ) {
       if ( /^".+"$/.test( str ) || /^'.+'$/.test( str ) ) {
           return str.substring( 1, str.length - 1 );
       }
       return str;
   }

   // Because iOS gives any camera-provided file the same filename, we need to a
   // unique-ified filename.
   //
   // See https://github.com/kobotoolbox/enketo-express/issues/374
   function getFilename( file, postfix ) {
       var filenameParts;
       if ( typeof file === 'object' && file.name ) {
           postfix = postfix || '';
           filenameParts = file.name.split( '.' );
           if ( filenameParts.length > 1 ) {
               filenameParts[ filenameParts.length - 2 ] += postfix;
           } else if ( filenameParts.length === 1 ) {
               filenameParts[ 0 ] += postfix;
           }
           return filenameParts.join( '.' );
       }
       return '';
   }

   /**
    * Converts NodeLists or DOMtokenLists to an array
    * @param  {[type]} list [description]
    * @return {[type]}      [description]
    */
   function toArray( list ) {
       var array = [];
       // iterate backwards ensuring that length is an UInt32
       for ( var i = list.length >>> 0; i--; ) {
           array[ i ] = list[ i ];
       }
       return array;
   }

   function isNumber( n ) {
       return !isNaN( parseFloat( n ) ) && isFinite( n );
   }

   function readCookie( name ) {
       var c;
       var C;
       var i;

       if ( cookies ) {
           return cookies[ name ];
       }

       c = document.cookie.split( '; ' );
       cookies = {};

       for ( i = c.length - 1; i >= 0; i-- ) {
           C = c[ i ].split( '=' );
           // decode URI
           C[ 1 ] = decodeURIComponent( C[ 1 ] );
           // if cookie is signed (using expressjs/cookie-parser/), extract value
           if ( C[ 1 ].substr( 0, 2 ) === 's:' ) {
               C[ 1 ] = C[ 1 ].slice( 2 );
               C[ 1 ] = C[ 1 ].slice( 0, C[ 1 ].lastIndexOf( '.' ) );
           }
           cookies[ C[ 0 ] ] = decodeURIComponent( C[ 1 ] );
       }

       return cookies[ name ];
   }

   module.exports = {
       parseFunctionFromExpression: parseFunctionFromExpression,
       stripQuotes: stripQuotes,
       getFilename: getFilename,
       toArray: toArray,
       isNumber: isNumber,
       readCookie: readCookie
   };

   },{}],
   "Widget":[function(require,module,exports){
   'use strict';

   var $ = require( 'jquery' );

   /**
    * A Widget class that can be extended to provide some of the basic widget functionality out of the box.
    * pattern: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
    *
    * @constructor
    * @param {Element} element The DOM element the widget is applied on
    * @param {(boolean|{touch: boolean})} options Options passed to the widget during instantiation
    * @param {string} event Not sure, this may not be necessary but the desktopSelectpicker does something with it
    */
   var Widget = function( element, options, event ) {
       this.element = element;
       this.options = options || {};
       // Determining the namespace automatically from the name of the constructor will not work
       // in conjunction with function renaming by uglify2
       this.namespace = this.namespace || 'somewidget';
       this.options.touch = ( typeof this.options.touch !== 'undefined' ) ? this.options.touch : false;
       this.event = event || null;
   };

   Widget.prototype = {
       /**
        * Destroys a widget in order the reinstiate it. It is used by some widgets as a crude 'update' function.
        * It can be removed once all widgets are able to update elegantly.
        *
        * Known widgets that still use this:
        * - geopicker
        *
        * @param  {Element} element The element the widget is applied on. Note that if element was clone this.element applies to the origin.
        */
       destroy: function( element ) {
           $( element )
               //data is not used elsewhere by enketo
               .removeData( this.namespace )
               //remove all the event handlers that used this.namespace as the namespace
               .off( '.' + this.namespace )
               //show the original element
               .show()
               //remove elements immediately after the target that have the widget class
               .next( '.widget' ).remove();
       },
       /**
        * Do whatever necessary to ensure that the widget does not allow user input if its parent branch is disabled.
        * Most of the times this branch can remain empty.
        * Check with $('.or-branch').show() whether input is disabled in a disabled branch.
        */
       disable: function( element ) {
           $( element )
               .next( '.widget' ).addClass( 'readonly' );
       },
       /**
        * Does whatever necessary to enable the widget if its parent branch is enabled.
        * Most of the times this function can remain empty.
        */
       enable: function( element ) {
           if ( !element.readOnly ) {
               $( element )
                   .next( '.widget' ).removeClass( 'readonly' );
           }
       },
       /**
        * Updates languages, <option>s (cascading selects, and (calculated) values.
        * Most of the times, this function needs to be overridden in the widget.
        */
       update: function() {}

   };

   module.exports = Widget;

   },{"jquery":"jquery"}],
   "widgets":[function(require,module,exports){
   'use strict';

   module.exports = [
       require( '../widget/note/notewidget' ),
       require( '../widget/select-desktop/selectpicker' ),
       require( '../widget/select-mobile/selectpicker' ),
       require( '../widget/select-autocomplete/autocomplete' ),
       require( '../widget/geo/geopicker' ),
       require( '../widget/textarea/textarea' ),
       require( '../widget/table/tablewidget' ),
       require( '../widget/radio/radiopicker' ),
       require( '../widget/date/datepicker-extended' ),
       require( '../widget/time/timepicker-extended' ),
       require( '../widget/datetime/datetimepicker-extended' ),
       require( '../widget/compact/compactpicker' ),
       require( '../widget/file/filepicker' ),
       require( '../widget/select-likert/likertitem' ),
       require( '../widget/distress/distresspicker' ),
       require( '../widget/horizontal-choices/horizontalchoices' ),
       require( '../widget/analog-scale/analog-scalepicker' ),
       require( '../widget/big-image/image-viewer' ),
       require( '../widget/comment/commentwidget' ),
       require( '../widget/image-map/image-map' )
   ];

   },{"../widget/note/notewidget":"notewidget","../widget/select-desktop/selectpicker":"desktopselectpicker","../widget/select-mobile/selectpicker":"mobileselectpicker","../widget/select-autocomplete/autocomplete":"autocomplete","../widget/geo/geopicker":"geopicker","../widget/textarea/textarea":"textarea","../widget/table/tablewidget":"tablewidget","../widget/radio/radiopicker":"radiopicker","../widget/date/datepicker-extended":"datepicker-extended","../widget/time/timepicker-extended":"timepicker-extended","../widget/datetime/datetimepicker-extended":"datetimepicker-extended","../widget/compact/compactpicker":"compactpicker","../widget/file/filepicker":"filepicker","../widget/select-likert/likertitem":"likertitem","../widget/distress/distresspicker":"distresspicker","../widget/horizontal-choices/horizontalchoices":"horizontalchoices","../widget/analog-scale/analog-scalepicker":"analog-scalepicker","../widget/big-image/image-viewer":"image-viewer","../widget/comment/commentwidget":"commentwidget","../widget/image-map/image-map":"image-map"}],
   "widgets-controller":[function(require,module,exports){
   'use strict';

   var options;
   var $form;
   var init;
   var enable;
   var disable;
   var _getElements;
   var _instantiate;
   var _setLangChangeListener;
   var _setOptionChangeListener;
   var _setValChangeListener;
   var support = require( './support' );
   var $ = require( 'jquery' );
   var widgets = require( 'widgets' ).filter( function( widget ) {
       return widget.selector;
   } );

   /**
    * Initializes widgets
    *
    * @param  {jQuery} $group The element inside which the widgets have to be initialized.
    * @param { *} options Options (e.g. helper function of Form.js passed)
    */

   init = function( $group, opts ) {
       if ( !this.form ) {
           throw new Error( 'Widgets module not correclty instantiated with form property.' );
       }
       $form = this.form.view.$;
       $group = $group || $form;
       options = options || opts;

       widgets.forEach( function( widget ) {
           _instantiate( widget, $group );
       } );

       return true;
   };

   /**
    * Enables widgets if they weren't enabled already when the branch was enabled by the controller.
    * In most widgets, this function will do nothing because the disabled attribute was automatically removed from all
    * fieldsets, inputs, textareas and selects inside the branch element provided as parameter.
    * Note that this function can be called before the widgets have been initialized and will in that case do nothing. This is
    * actually preferable than waiting for create() to complete, because enable() will never do anything that isn't
    * done during create().
    *
    * @param  {jQuery} $group [description]
    */
   enable = function( $group ) {
       var widget, $els;

       for ( var i = 0; i < widgets.length; i++ ) {
           widget = widgets[ i ];
           if ( widget.name ) {
               $els = _getElements( $group, widget.selector );
               $els[ widget.name ]( 'enable' );
           }
       }
   };

   /**
    * Disables  widgets, if they aren't disabled already when the branch was disabled by the controller.
    * In most widgets, this function will do nothing because all fieldsets, inputs, textareas and selects will get
    * the disabled attribute automatically when the branch element provided as parameter becomes irrelevant.
    *
    * @param  { jQuery } $group The element inside which all widgets need to be disabled.
    */
   disable = function( $group ) {
       var widget, $els;

       for ( var i = 0; i < widgets.length; i++ ) {

           widget = widgets[ i ];
           if ( widget.name ) {
               $els = _getElements( $group, widget.selector );
               $els[ widget.name ]( 'disable' );
           }
       }
   };

   /**
    * Returns the elements on which to apply the widget
    *
    * @param  {jQuery} $group   a jQuery-wrapped element
    * @param  {string} selector if the selector is null, the form element will be returned
    * @return {jQuery}          a jQuery collection
    */
   _getElements = function( $group, selector ) {
       return ( selector ) ? ( selector === 'form' ? $form : $group.find( selector ) ) : $();
   };

   /**
    * Instantiate a widget on a group (whole form or newly cloned repeat)
    *
    * @param  widget The widget to instantiate
    * @param  {jQuery} $group The elements inside which widgets need to be created.
    */
   _instantiate = function( widget, $group ) {
       var $elements;
       widget.options = widget.options || {};
       widget.options.touch = support.touch;

       if ( !widget.name ) {
           return console.error( 'widget doesn\'t have a name' );
       }

       if ( widget.helpersRequired && widget.helpersRequired.length > 0 ) {
           widget.options.helpers = {};
           widget.helpersRequired.forEach( function( helper ) {
               widget.options.helpers[ helper ] = options[ helper ];
           } );
       }

       $elements = _getElements( $group, widget.selector );

       if ( !$elements.length ) {
           return;
       }

       $elements[ widget.name ]( widget.options );
       _setLangChangeListener( widget, $elements );
       _setOptionChangeListener( widget, $elements );
       _setValChangeListener( widget, $elements );
   };


   /**
    * Calls widget('update') when the language changes. This function is called upon initialization,
    * and whenever a new repeat is created. In the latter case, since the widget('update') is called upon
    * the elements of the repeat, there should be no duplicate eventhandlers.
    *
    * @param {{name: string}} widget The widget configuration object
    * @param {jQuery}         $els   The jQuery collection of elements that the widget has been instantiated on.
    */
   _setLangChangeListener = function( widget, $els ) {
       // call update for all widgets when language changes
       if ( $els.length > 0 ) {
           $form.on( 'changelanguage', function() {
               $els[ widget.name ]( 'update' );
           } );
       }
   };

   /**
    * Calls widget('update') on select-type widgets when the options change. This function is called upon initialization,
    * and whenever a new repeat is created. In the latter case, since the widget('update') is called upon
    * the elements of the repeat, there should be no duplicate eventhandlers.
    *
    * @param {{name: string}} widget The widget configuration object
    * @param {jQuery}         $els   The jQuery collection of elements that the widget has been instantiated on.
    */
   _setOptionChangeListener = function( widget, $els ) {
       if ( $els.length > 0 && widget.list ) {
           $els.on( 'changeoption', function() {
               // update (itemselect) picker on which event was triggered because the options changed
               $( this )[ widget.name ]( 'update' );
           } );
       }
   };

   /**
    * Calls widget('update') if the form input/select/textarea value changes due to an action outside
    * of the widget (e.g. a calculation).
    *
    * @param {{name: string}} widget The widget configuration object
    * @param {jQuery}         $els   The jQuery collection of elements that the widget has been instantiated on.
    */
   _setValChangeListener = function( widget, $els ) {
       var nodeName = $els.prop( 'nodeName' ).toLowerCase();
       // avoid adding eventhandlers on widgets that apply to the <form> element
       if ( $els.length > 0 && ( nodeName === 'input' || nodeName === 'select' || nodeName === 'textarea' ) ) {
           $els.on( 'inputupdate.enketo', function() {
               $( this )[ widget.name ]( 'update' );
           } );
       }
   };

   module.exports = {
       init: init,
       enable: enable,
       disable: disable
   };

   },{"./support":"support","jquery":"jquery","widgets":"widgets"}],
   "analog-scalepicker":[function(require,module,exports){
   'use strict';
   var Widget = require( '../../js/Widget' );
   var $ = require( 'jquery' );
   var pluginName = 'analogscalepicker';

   require( 'bootstrap-slider-basic' );

   /**
    * Creates an analog scale picker
    *
    * @constructor
    * @param {Element} element Element to apply widget to.
    * @param {(boolean|{touch: boolean})} options options
    */
   function Analogscalepicker( element, options ) {
       this.namespace = pluginName;
       Widget.call( this, element, options );
       this._init();
   }

   // copy the prototype functions from the Widget super class
   Analogscalepicker.prototype = Object.create( Widget.prototype );

   // ensure the constructor is the new one
   Analogscalepicker.prototype.constructor = Analogscalepicker;

   /**
    * Initialize
    */
   Analogscalepicker.prototype._init = function() {
       var $question = $( this.element ).closest( '.question' );
       var $input = $( this.element );
       var value = Number( this.element.value ) || -1;

       this.props = this._getProps( $question );

       $input
           .slider( {
               reversed: this.props.orientation === 'vertical',
               min: 0,
               max: 100,
               orientation: this.props.orientation,
               step: this.props.step,
               value: value,
               enabled: !this.props.readonly
           } );

       this.$widget = $input.next( '.widget' );
       this.$slider = this.$widget.find( '.slider' );
       this.$labelContent = $( '<div class="label-content widget" />' ).prependTo( $question );
       this.$originalLabels = $question.find( '.question-label, .or-hint, .or-required-msg, .or-constraint-msg' );
       this.$labelContent.append( this.$originalLabels );

       this._renderResetButton();
       this._renderLabels();
       this._renderScale();
       this._setChangeListener();
       this._setResizeListener();

       // update reset button and slider "empty" state
       $input.trigger( 'programmaticChange' + this.namespace );
   };

   Analogscalepicker.prototype._getProps = function( $question ) {
       var appearances = $question.attr( 'class' ).split( ' ' )
           .map( function( appearance, index ) {
               return appearance.substring( 14 );
           } );
       var type = this.element.attributes[ 'data-type-xml' ].value;

       return {
           touch: this.options.touch,
           readonly: this.element.readOnly,
           step: type === 'decimal' ? 0.1 : 1,
           orientation: appearances.indexOf( 'horizontal' ) !== -1 ? 'horizontal' : 'vertical'
       };
   };

   /**
    * (re-)Renders the widget labels based on the current content of .question-label.active
    */
   Analogscalepicker.prototype._renderLabels = function() {
       var $labelEl = this.$labelContent.find( '.question-label.active' );
       var labels = $labelEl.html().split( /\|/ ).map( function( label ) {
           return label.trim();
       } );

       this.$mainLabel = this.$mainLabel || $( '<span class="question-label widget active" />' ).insertAfter( $labelEl );
       this.$mainLabel.empty().append( labels[ 0 ] );

       this.$maxLabel = this.$maxLabel || $( '<div class="max-label" />' ).prependTo( this.$widget );
       this.$maxLabel.empty().append( labels[ 1 ] );

       this.$minLabel = this.$minLabel || $( '<div class="min-label" />' ).appendTo( this.$widget );
       this.$minLabel.empty().append( labels[ 2 ] );

       if ( labels[ 3 ] ) {
           this.$showValue = this.$showValue || $( '<div class="widget show-value" />' ).appendTo( this.$labelContent );
           this.$showValue.empty().append( '<div class="show-value__box">' + labels[ 3 ] +
               '<span class="show-value__value">' + this.element.value + '</span></div>' );
       } else if ( this.$showValue ) {
           this.$showValue.remove();
           this.$showValue = undefined;
       }
   };

   Analogscalepicker.prototype._renderScale = function() {
       var i;
       var $scale = $( '<div class="scale"></div>' );

       if ( this.props.orientation === 'vertical' ) {
           for ( i = 100; i >= 0; i -= 10 ) {
               $scale.append( this._getNumberHtml( i ) );
           }
       } else {
           for ( i = 0; i <= 100; i += 10 ) {
               $scale.append( this._getNumberHtml( i ) );
           }
       }

       this.$slider.prepend( $scale );
   };

   Analogscalepicker.prototype._getNumberHtml = function( num ) {
       return '<div class="scale__number"><div class="scale__ticks"></div><div class="scale__value">' + num + '</div></div>';
   };

   Analogscalepicker.prototype._renderResetButton = function() {
       var that = this;

       this.$resetBtn = $( '<button class="btn-icon-only btn-reset"><i class="icon icon-refresh"></i></button>' )
           .appendTo( this.$widget )
           .on( 'click', function() {
               $( that.element ).slider( 'setValue', 0, false );
               $( that.element ).val( '' ).trigger( 'programmaticChange' + that.namespace );
               return false;
           } )
           .prop( 'disabled', that.props.readonly );
   };

   Analogscalepicker.prototype._updateCurrentValueShown = function() {
       if ( this.$showValue ) {
           this.$showValue.find( '.show-value__value' ).text( this.element.value );
       }
   };

   Analogscalepicker.prototype._setChangeListener = function() {
       var that = this;

       $( this.element ).on( 'slideStop.' + this.namespace + ' programmaticChange' + this.namespace, function() {
           var empty = ( this.value === '' );
           $( this ).trigger( 'change' );
           that.$resetBtn.prop( 'disabled', empty || that.props.readonly );
           that.$slider.toggleClass( 'slider--empty', empty );
           that._updateCurrentValueShown();
       } );
   };

   /*
    * Stretch the question to full page height.
    * Doing this with pure css flexbox using "flex-direction: column" interferes with the Grid theme
    * because that theme relies on flexbox with "flex-direction: row".
    */
   Analogscalepicker.prototype._setResizeListener = function() {
       var $question = $( this.element ).closest( '.question' );

       if ( !$question.hasClass( 'or-appearance-horizontal' ) ) {
           // Will only be triggered if question by itself constitutes a page.
           // It will not be triggerd if question is contained inside a group with fieldlist appearance.
           $question.on( 'pageflip.enketo', this._stretchHeight );
       }
   };

   Analogscalepicker.prototype._stretchHeight = function() {
       var $question = $( this ).closest( '.question' ).css( 'min-height', 'auto' );
       var height = $question.outerHeight();
       var $form = $question.closest( '.or' );
       var diff = ( $form.offset().top + $form.height() ) - ( $question.offset().top + height ) - 10;
       if ( diff ) {
           // To somewhat avoid problems when a repeat is clone and height is set while the widget is detached
           // we use min-height instead of height.
           $question.css( 'min-height', height + diff + 'px' );
       }
   };

   Analogscalepicker.prototype.disable = function() {
       var value = ( this.element.value !== '' ) ? Number( this.element.value ) : 0;
       $( this.element )
           .slider( 'disable' )
           .slider( 'setValue', value, false );
   };

   Analogscalepicker.prototype.enable = function() {
       $( this.element )
           .slider( 'enable' );
   };

   Analogscalepicker.prototype.update = function() {
       // in case input value was changed (due to calculation update)
       var that = this;
       var value = ( this.element.value !== '' ) ? Number( this.element.value ) : 0;
       var $el = $( this.element );
       var sliderValue = $el.slider( 'getValue' );
       if ( value !== sliderValue ) {
           $( this.element )
               .slider( 'setValue', value, false )
               .trigger( 'programmaticChange' + that.namespace );
       }
       // in case language was changed
       this._renderLabels();
   };

   $.fn[ pluginName ] = function( options, event ) {
       return this.each( function() {
           var $this = $( this ),
               data = $( this ).data( pluginName );

           options = options || {};

           if ( !data && typeof options === 'object' ) {
               $this.data( pluginName, new Analogscalepicker( this, options, event ) );
           } else if ( data && typeof options === 'string' ) {
               //pass the context, used for destroy() as this method is called on a cloned widget
               data[ options ]( this );
           }
       } );
   };

   module.exports = {
       'name': pluginName,
       'selector': '.or-appearance-analog-scale input[type="number"]'
   };

   },{"../../js/Widget":"Widget","jquery":"jquery","bootstrap-slider-basic":"bootstrap-slider-basic"}],
   "image-viewer":[function(require,module,exports){
   'use strict';

   var Widget = require( '../../js/Widget' );
   var $ = require( 'jquery' );
   var pluginName = 'imageViewer';

   /**
    * Viewer for image labels that have set a big-image version.
    *
    * @constructor
    * @param {Element}                       element   Element to apply widget to.
    * @param {(boolean|{touch: boolean})}    options   options
    * @param {*=}                            event     event
    */
   function ImageViewer( element, options, event ) {
       this.namespace = pluginName;
       Widget.call( this, element, options );
       this._init();
   }

   ImageViewer.prototype = Object.create( Widget.prototype );
   ImageViewer.prototype.constructor = ImageViewer;

   // add your widget functions
   ImageViewer.prototype._init = function() {
       $( this.element ).on( 'click', function() {
           var $link = $( this );
           var href = $link.attr( 'href' );
           var $img = $link.find( 'img' );
           var src = $img.attr( 'src' );

           $link.attr( 'href', src );
           $img.attr( 'src', href );
           $link.toggleClass( 'open' );

           return false;
       } );
   };

   $.fn[ pluginName ] = function( options, event ) {

       options = options || {};

       return this.each( function() {
           var $this = $( this );
           var data = $this.data( pluginName );

           if ( !data && typeof options === 'object' ) {
               $this.data( pluginName, new ImageViewer( this, options, event ) );
           } else if ( data && typeof options == 'string' ) {
               data[ options ]( this );
           }
       } );
   };

   module.exports = {
       'name': pluginName,
       'selector': 'a.or-big-image'
   };

   },{"../../js/Widget":"Widget","jquery":"jquery"}],
   "commentwidget":[function(require,module,exports){
   'use strict';

   var Widget = require( '../../js/Widget' );
   var $ = require( 'jquery' );
   var pluginName = 'comment';
   var t = require( 'translator' ).t;

   /**
    * Visually transforms a question into a comment modal that can be shown on its linked question.
    *
    * @constructor
    * @param {Element}                       element   Element to apply widget to.
    * @param {(boolean|{touch: boolean})}    options   options
    * @param {*=}                            event     event
    */
   function Comment( element, options, event ) {
       this.namespace = pluginName;
       Widget.call( this, element, options );
       this._init();
   }

   Comment.prototype = Object.create( Widget.prototype );
   Comment.prototype.constructor = Comment;

   Comment.prototype._init = function() {
       this.$linkedQuestion = this._getLinkedQuestion( this.element );
       this.$commentQuestion = $( this.element ).closest( '.question' );

       if ( this.$linkedQuestion.length === 1 ) {
           // Adding role='comment' is for now only used to make sure that role is not 'page' as that messes things up
           this.$commentQuestion.addClass( 'hide' ).attr( 'role', 'comment' );

           // Any <button> inside a <label> receives click events if the <label> is clicked!
           // See http://codepen.io/MartijnR/pen/rWJeOG?editors=1111
           this.$commentButton = $( '<a class="btn-icon-only btn-comment" type="button" href="#"><i class="icon"> </i></a>' );
           this._setCommentButtonState( this.element.value );
           this.$linkedQuestion.find( '.question-label' ).last().after( this.$commentButton );
           this._setCommentButtonHandler();
           this._setValidationHandler();
           this._setFocusHandler();
       }
   };

   Comment.prototype._getLinkedQuestion = function( element ) {
       var $input = $( element );
       var contextPath = this.options.helpers.input.getName( $input );
       var targetPath = element.dataset.for.trim();
       var absoluteTargetPath = this.options.helpers.pathToAbsolute( targetPath, contextPath );
       // The root is nearest repeat or otherwise nearest form. This avoids having to calculate indices, without
       // diminishing the flexibility in any meaningful way,
       // as it e.g. wouldn't make sense to place a comment node for a top-level question, inside a repeat.
       var $root = $( element ).closest( 'form.or, .or-repeat' );

       return this.options.helpers.input
           .getWrapNodes( $root.find( '[name="' + absoluteTargetPath + '"], [data-name="' + absoluteTargetPath + '"]' ) )
           .eq( 0 );
   };

   Comment.prototype._commentHasError = function() {
       return this.$commentQuestion.hasClass( 'invalid-required' ) || this.$commentQuestion.hasClass( 'invalid-constraint' );
   };

   Comment.prototype._setCommentButtonState = function( value, error ) {
       value = ( typeof value === 'string' ) ? value.trim() : value;
       this.$commentButton.toggleClass( 'empty', !value );
       this.$commentButton.toggleClass( 'invalid', !!error );
   };

   Comment.prototype._setCommentButtonHandler = function() {
       var that = this;
       this.$commentButton.click( function() {
           if ( that._isCommentModalShown( that.$linkedQuestion ) ) {
               that._hideCommentModal( that.$linkedQuestion );
           } else {
               that._showCommentModal();
           }
           return false;
       } );
   };

   Comment.prototype._setValidationHandler = function() {
       var that = this;
       $( 'form.or' ).on( 'validationcomplete.enketo', function() {
           var error = that._commentHasError();
           var value = that.element.value;
           that._setCommentButtonState( value, error );
       } );
   };

   Comment.prototype._setFocusHandler = function() {
       var that = this;
       $( this.element ).on( 'applyfocus', function() {
           if ( that.$commentButton.is( ':visible' ) ) {
               that.$commentButton.click();
           } else {
               console.log( 'The linked question is not visible. Cannot apply focus to ' + that.element.getAttribute( 'name' ) );
           }
       } );
   };

   Comment.prototype._isCommentModalShown = function( $linkedQuestion ) {
       return $linkedQuestion.find( '.or-comment-widget' ).length === 1;
   };

   Comment.prototype._showCommentModal = function() {
       var $widget;
       var $content;
       var $input;
       var $overlay;
       var that = this;
       var $comment = $( this.element ).closest( '.question' ).clone( false );
       var updateText = t( 'widget.comment.update' ) || 'Update';
       var $updateButton = $( '<button class="btn btn-primary or-comment-widget__content__btn-update" type="button">' + updateText + '</button>' );
       var $closeButton = $( '<button class="btn-icon-only or-comment-widget__content__btn-close-x" type="button">&times;</button>' );

       $input = $comment
           .removeClass( 'hide' )
           .find( 'input, textarea' )
           .addClass( 'ignore' )
           .removeAttr( 'name data-for data-type-xml' )
           .removeData();
       $overlay = $( '<div class="or-comment-widget__overlay"></div>' );
       $content = $( '<div class="or-comment-widget__content"></div>' )
           .append( $comment ).append( $closeButton ).append( $updateButton );

       $widget = $(
           '<section class="widget or-comment-widget"></section>'
       ).append( $overlay ).append( $content );

       this.$linkedQuestion
           .find( '.or-comment-widget' ).remove().end()
           .prepend( $widget )
           .before( $overlay.clone( false ) );

       $input.focus();

       $widget.get( 0 ).scrollIntoView( false );

       $updateButton.on( 'click', function() {
           var error;
           var value = $input.val();
           $( that.element ).val( value ).trigger( 'change' );
           error = that._commentHasError();
           that._setCommentButtonState( value, error );
           that._hideCommentModal( that.$linkedQuestion );
           /*
            * Any current error state shown in the linked question will not automatically update.
            * It only updates when its **own** value changes.
            * See https://github.com/kobotoolbox/enketo-express/issues/608
            * Since a linked question and a comment belong so closely together, and likely have
            * a `required` or `constraint` dependency, it makes sense to
            * separately call a validate method on the linked question to update the error state if necessary.
            *
            * Note that with setting "validateContinously" set to "true" this means it will be validated twice.
            */
           that.options.helpers.input.validate( $( that.$linkedQuestion.get( 0 ).querySelector( 'input, select, textarea' ) ) );
           return false;
       } );

       $closeButton.add( $overlay ).on( 'click', function() {
           that._hideCommentModal( that.$linkedQuestion );
           return false;
       } );
   };

   Comment.prototype._hideCommentModal = function( $linkedQuestion ) {
       $linkedQuestion
           .find( '.or-comment-widget' ).remove().end()
           .prev( '.or-comment-widget__overlay' ).remove();
   };

   $.fn[ pluginName ] = function( options, event ) {

       options = options || {};

       return this.each( function() {
           var $this = $( this );
           var data = $this.data( pluginName );

           if ( !data && typeof options === 'object' ) {
               $this.data( pluginName, new Comment( this, options, event ) );
           } else if ( data && typeof options == 'string' ) {
               data[ options ]( this );
           }
       } );
   };

   module.exports = {
       'name': pluginName,
       'selector': '.or-appearance-comment input[type="text"][data-for], .or-appearance-comment textarea[data-for]',
       'helpersRequired': [ 'input', 'pathToAbsolute' ]
   };

   },{"../../js/Widget":"Widget","jquery":"jquery","translator":"fake-translator"}],
   "compactpicker":[function(require,module,exports){
   'use strict';
   var $ = require( 'jquery' );
   var Widget = require( '../../js/Widget' );

   var pluginName = 'compactpicker';

   /**
    * Compact Picker. Hides text labels if a media label is present.
    *
    * @constructor
    * @param {Element}                       element   Element to apply widget to.
    * @param {(boolean|{touch: boolean})}    options   options
    * @param {*=}                            event     event
    */

   function CompactPicker( element, options ) {
       // set the namespace (important!)
       this.namespace = pluginName;
       // call the Super constructor
       Widget.call( this, element, options );
       this._init();
   }

   // copy the prototype functions from the Widget super class
   CompactPicker.prototype = Object.create( Widget.prototype );

   //ensure the constructor is the new one
   CompactPicker.prototype.constructor = CompactPicker;

   //add your widget functions
   CompactPicker.prototype._init = function() {
       $( this.element ).find( '.option-label' ).each( function() {
           var $optionLabel = $( this );
           if ( $optionLabel.siblings( 'img, video, audio' ).length > 0 ) {
               $optionLabel.css( 'display', 'none' );
           }
       } );
   };

   $.fn[ pluginName ] = function( options, event ) {

       options = options || {};

       return this.each( function() {
           var $this = $( this ),
               data = $this.data( pluginName );

           //only instantiate if options is an object (i.e. not a string) and if it doesn't exist already
           if ( !data && typeof options === 'object' ) {
               $this.data( pluginName, new CompactPicker( this, options, event ) );
           }
           //only call method if widget was instantiated before
           else if ( data && typeof options === 'string' ) {
               //pass the element as a parameter as this is used in destroy() for cloned elements and widgets
               data[ options ]( this );
           }
       } );
   };


   module.exports = {
       'name': 'compactpicker',
       'selector': '.or-appearance-compact, .or-appearance-quickcompact, [class*="or-appearance-compact-"]'
   };

   },{"../../js/Widget":"Widget","jquery":"jquery"}],
   "datepicker-extended":[function(require,module,exports){
   'use strict';

   var Widget = require( '../../js/Widget' );
   var support = require( '../../js/support' );
   var $ = require( 'jquery' );
   require( 'bootstrap-datepicker' );
   require( '../../js/dropdown.jquery' );

   //It is very helpful to make this the same as widget class, except for converting the first character to lowercase.
   var pluginName = 'datepickerExtended';

   /**
    * Extends eternicode's bootstrap-datepicker without changing the original.
    * https://github.com/eternicode/bootstrap-datepicker
    *
    * @constructor
    * @param {Element}                       element   Element to apply widget to.
    * @param {(boolean|{touch: boolean})}    options   options
    * @param {*=}                            event     event
    */

   function DatepickerExtended( element, options ) {
       this.namespace = pluginName;
       //call the Super constructor
       Widget.call( this, element, options );
       this._init();
   }

   //copy the prototype functions from the Widget super class
   DatepickerExtended.prototype = Object.create( Widget.prototype );

   //ensure the constructor is the new one
   DatepickerExtended.prototype.constructor = DatepickerExtended;

   /**
    * Initialize datepicker widget
    */
   DatepickerExtended.prototype._init = function() {
       var that = this;
       var $p = $( this.element ).parent( 'label' );
       var settings = ( $p.hasClass( 'or-appearance-year' ) ) ? {
           format: 'yyyy',
           startView: 'decade',
           minViewMode: 'years'
       } : ( $p.hasClass( 'or-appearance-month-year' ) ) ? {
           format: 'yyyy-mm',
           startView: 'year',
           minViewMode: 'months'
       } : {
           format: 'yyyy-mm-dd',
           startView: 'month',
           minViewMode: 'days'
       };

       this.$fakeDateI = this._createFakeDateInput( settings.format );

       this._setManualHandler( this.$fakeDateI );
       this._setFocusHandler( this.$fakeDateI );
       this._setResetHandler( this.$fakeDateI );

       this.$fakeDateI.datepicker( {
           format: settings.format,
           autoclose: true,
           todayHighlight: true,
           startView: settings.startView,
           minViewMode: settings.minViewMode
       } ).on( 'changeDate', function() {
           // copy changes made by datepicker to original input field
           var value = $( this ).val();
           if ( settings.startView === 'decade' && value.length === 4 ) {
               value += '-01-01';
           } else if ( settings.startView === 'year' && value.length < 8 ) {
               value += '-01';
           }
           $( that.element ).val( value ).trigger( 'change' ); //.blur();
       } );
   };

   /**
    * Creates fake date input elements
    * @param  {string} format the date format
    * @return {jQuery}        the jQuery-wrapped fake date input element
    */
   DatepickerExtended.prototype._createFakeDateInput = function( format ) {
       var $dateI = $( this.element );
       var $fakeDate = $(
           '<div class="widget date"><input class="ignore input-small" type="text" value="' +
           $dateI.val() + '" placeholder="' + format + '" />' +
           '<button class="btn-icon-only btn-reset" type="button"><i class="icon icon-refresh"> </i></button></div>' );
       var $fakeDateI = $fakeDate.find( 'input' );

       $dateI.hide().after( $fakeDate );

       return $fakeDateI;
   };

   /**
    * copy manual changes to original date input field
    *
    * @param { jQuery } $fakeDateI Fake date input element
    */
   DatepickerExtended.prototype._setManualHandler = function( /* $fakeDateI*/) {
       //$fakeDateI.on( 'change', function( ) {
       //  var date,
       //    value = $dateI.val( );
       //  if ( value.length > 0 ) {
       //    value = ( format === 'yyyy-mm' ) ? value + '-01' : ( format === 'yyyy' ) ? value + '-01-01' : value;
       //    value = data.node( ).convert( value, 'date' );
       //  }
       //  if ( $dateI.val( ) !== value ) {
       //    $dateI.val( value ).trigger( 'change' ).blur( );
       //  }
       //  return false;
       //} );
   };

   /**
    * Reset button handler
    *
    * @param { jQuery } $fakeDateI Fake date input element
    */
   DatepickerExtended.prototype._setResetHandler = function( $fakeDateI ) {
       $fakeDateI.next( '.btn-reset' ).on( 'click', function() {
           $fakeDateI.val( '' ).trigger( 'changeDate' ).datepicker( 'update' );
       } );
   };

   /**
    * Handler for focus events.
    * These events on the original input are used to check whether to display the 'required' message
    *
    * @param { jQuery } $fakeDateI Fake date input element
    */
   DatepickerExtended.prototype._setFocusHandler = function( $fakeDateI ) {
       var that = this;
       // Handle focus on widget
       $fakeDateI.on( 'focus', function() {
           $( that.element ).trigger( 'fakefocus' );
       } );
       // Handle focus on original input (goTo functionality)
       $( this.element ).on( 'applyfocus', function() {
           $fakeDateI.focus();
       } );
   };

   DatepickerExtended.prototype.update = function() {
       this.$fakeDateI.val( this.element.value ).datepicker( 'update' );
   };

   $.fn[ pluginName ] = function( options, event ) {

       options = options || {};

       return this.each( function() {
           var $this = $( this ),
               data = $this.data( pluginName ),
               badSamsung = /GT-P31[0-9]{2}.+AppleWebKit\/534\.30/;

           /*
            * Samsung mobile browser (called "Internet") has a weird bug that appears sometimes (?) when an input field
            * already has a value and is edited. The new value YYYY-MM-DD prepends old or replaces the year of the old value and first hyphen. E.g.
            * existing: 2010-01-01, new value entered: 2012-12-12 => input field shows: 2012-12-1201-01.
            * This doesn't seem to effect the actual value of the input, just the way it is displayed. But if the incorrectly displayed date is then
            * attempted to be edited again, it does get the incorrect value and it's impossible to clear this and create a valid date.
            *
            * browser: "Mozilla/5.0 (Linux; U; Android 4.1.1; en-us; GT-P3113 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Safari/534.30";
            * webview: "Mozilla/5.0 (Linux; U; Android 4.1.2; en-us; GT-P3100 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Safari/534.30"
            */

           if ( !data && typeof options === 'object' && ( !options.touch || !support.inputtypes.date || badSamsung.test( navigator.userAgent ) ) ) {
               $this.data( pluginName, new DatepickerExtended( this, options, event ) );
           }
           //only call method if widget was instantiated before
           else if ( data && typeof options === 'string' ) {
               //pass the element as a parameter as this is used in fix()
               data[ options ]( this );
           }
       } );
   };

   module.exports = {
       'name': pluginName,
       'selector': 'input[type=\"date\"]:not([readonly])'
   };

   },{"../../js/Widget":"Widget","../../js/support":"support","jquery":"jquery","bootstrap-datepicker":"bootstrap-datepicker","../../js/dropdown.jquery":"dropdown.jquery"}],
   "datetimepicker-extended":[function(require,module,exports){
   'use strict';

   var Widget = require( '../../js/Widget' );
   var support = require( '../../js/support' );
   var $ = require( 'jquery' );
   var pluginName = 'datetimepickerExtended';
   require( '../../js/extend' );
   require( 'bootstrap-datepicker' );
   require( '../time/timepicker' );
   require( '../../js/dropdown.jquery' );

   /**
    *
    * @constructor
    * @param {Element}                       element   Element to apply widget to.
    * @param {(boolean|{touch: boolean})}    options   options
    * @param {*=}                            event     event
    */

   function DatetimepickerExtended( element, options ) {
       this.namespace = pluginName;
       //call the Super constructor
       Widget.call( this, element, options );
       this._init();
   }

   //copy the prototype functions from the Widget super class
   DatetimepickerExtended.prototype = Object.create( Widget.prototype );

   //ensure the constructor is the new one
   DatetimepickerExtended.prototype.constructor = DatetimepickerExtended;

   /**
    * Initialize timepicker widget
    */
   DatetimepickerExtended.prototype._init = function() {
       var that = this;
       var $dateTimeI = $( this.element );
       /*
         Loaded or default datetime values remain untouched until they are edited. This is done to preserve
         the timezone information (especially for instances-to-edit) if the values are not edited (the
         original entry may have been done in a different time zone than the edit). However,
         values shown in the widget should reflect the local time representation of that value.
        */
       var val = ( $dateTimeI.val().length > 0 ) ? new Date( $dateTimeI.val() ).toISOLocalString() : '';
       var vals = val.split( 'T' );
       var dateVal = vals[ 0 ];
       var timeVal = ( vals[ 1 ] && vals[ 1 ].length > 4 ) ? vals[ 1 ].substring( 0, 5 ) : '';
       this.$fakeDateI = this._createFakeDateInput( dateVal );
       this.$fakeTimeI = this._createFakeTimeInput( timeVal );

       $dateTimeI.hide().after( '<div class="datetimepicker widget" />' );
       $dateTimeI.siblings( '.datetimepicker' ).append( this.$fakeDateI.closest( '.date' ) ).append( this.$fakeTimeI.closest( '.timepicker' ) );

       this.$fakeDateI.datepicker( {
           format: 'yyyy-mm-dd',
           autoclose: true,
           todayHighlight: true
       } );

       this.$fakeTimeI
           .timepicker( {
               defaultTime: ( timeVal.length > 0 ) ? 'value' : false,
               showMeridian: false
           } )
           //.val( timeVal )
           //the time picker itself has input elements
           .closest( '.widget' ).find( 'input' ).addClass( 'ignore' );

       this._setManualHandler( this.$fakeDateI );
       this._setFocusHandler( this.$fakeDateI.add( this.$fakeTimeI ) );

       this.$fakeDateI.on( 'change changeDate', function() {
           changeVal();
           return false;
       } );

       this.$fakeTimeI.on( 'change', function() {
           changeVal();
           return false;
       } );

       //reset button
       this.$fakeTimeI.next( '.btn-reset' ).on( 'click', function() {
           that.$fakeDateI.val( '' ).trigger( 'change' ).datepicker( 'update' );
           that.$fakeTimeI.val( '' ).trigger( 'change' );
       } );

       function changeVal() {
           if ( that.$fakeDateI.val().length > 0 && that.$fakeTimeI.val().length > 3 ) {
               var d = that.$fakeDateI.val().split( '-' );
               var t = that.$fakeTimeI.val().split( ':' );
               $dateTimeI.val( new Date( d[ 0 ], d[ 1 ] - 1, d[ 2 ], t[ 0 ], t[ 1 ] ).toISOLocalString() ).trigger( 'change' );
           } else {
               $dateTimeI.val( '' ).trigger( 'change' );
           }
       }
   };

   /**
    * Creates fake date input elements
    * @param  {string} format the date format
    * @return {jQuery}        the jQuery-wrapped fake date input element
    */
   DatetimepickerExtended.prototype._createFakeDateInput = function( dateVal ) {
       var $fakeDate = $(
           '<div class="date">' +
           '<input class="ignore" type="text" value="' + dateVal + '" placeholder="yyyy-mm-dd"/>' +
           '</div>' );
       var $fakeDateI = $fakeDate.find( 'input' );

       return $fakeDateI;
   };

   /**
    * Creates fake time input elements
    * @param  {string} format the date format
    * @return {jQuery}        the jQuery-wrapped fake date input element
    */
   DatetimepickerExtended.prototype._createFakeTimeInput = function( timeVal ) {
       var $fakeTime = $(
           '<div class="timepicker">' +
           '<input class="ignore timepicker-default" type="text" value="' +
           timeVal + '" placeholder="hh:mm"/>' +
           '<button class="btn-icon-only btn-reset" type="button"><i class="icon icon-refresh"> </i></button>' +
           '</div>' );
       var $fakeTimeI = $fakeTime.find( 'input' );

       return $fakeTimeI;
   };

   /**
    * copy manual changes to original date input field
    *
    * @param { jQuery } $fakeDateI Fake date input element
    */
   DatetimepickerExtended.prototype._setManualHandler = function() {};


   DatetimepickerExtended.prototype.update = function() {
       var $dateTimeI = $( this.element );
       var val = ( $dateTimeI.val().length > 0 ) ? new Date( $dateTimeI.val() ).toISOLocalString() : '';
       var vals = val.split( 'T' );
       var dateVal = vals[ 0 ];
       var timeVal = ( vals[ 1 ] && vals[ 1 ].length > 4 ) ? vals[ 1 ].substring( 0, 5 ) : '';

       this.$fakeDateI.val( dateVal );
       this.$fakeTimeI.val( timeVal );

   };

   /**
    * Handler for focus events.
    * These events on the original input are used to check whether to display the 'required' message
    *
    * @param { jQuery } $fakeDateI Fake date input element
    */
   DatetimepickerExtended.prototype._setFocusHandler = function( $els ) {
       var that = this;
       // Handle focus on widget.
       $els.on( 'focus', function() {
           $( that.element ).trigger( 'fakefocus' );
       } );
       // Handle focus on original input (goTo functionality)
       $( this.element ).on( 'applyfocus', function() {
           $els.eq( 0 ).focus();
       } );
   };

   $.fn[ pluginName ] = function( options, event ) {

       options = options || {};

       return this.each( function() {
           var $this = $( this ),
               data = $this.data( pluginName ),
               badSamsung = /GT-P31[0-9]{2}.+AppleWebKit\/534\.30/;

           /*
               Samsung mobile browser (called "Internet") has a weird bug that appears sometimes (?) when an input field
               already has a value and is edited. The new value YYYY-MM-DD prepends old or replaces the year of the old value and first hyphen. E.g.
               existing: 2010-01-01, new value entered: 2012-12-12 => input field shows: 2012-12-1201-01.
               This doesn't seem to effect the actual value of the input, just the way it is displayed. But if the incorrectly displayed date is then
               attempted to be edited again, it does get the incorrect value and it's impossible to clear this and create a valid date.

               browser: "Mozilla/5.0 (Linux; U; Android 4.1.1; en-us; GT-P3113 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Safari/534.30";
               webview: "Mozilla/5.0 (Linux; U; Android 4.1.2; en-us; GT-P3100 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Safari/534.30"
               */
           if ( !data && typeof options === 'object' && ( !options.touch || !support.inputtypes.datetime || badSamsung.test( navigator.userAgent ) ) ) {
               $this.data( pluginName, new DatetimepickerExtended( this, options, event ) );
           }
           //only call method if widget was instantiated before
           else if ( data && typeof options === 'string' ) {
               //pass the element as a parameter as this is used in fix()
               data[ options ]( this );
           }
       } );
   };

   module.exports = {
       'name': pluginName,
       'selector': 'input[type="datetime"]:not([readonly])'
   };

   },{"../../js/Widget":"Widget","../../js/support":"support","jquery":"jquery","../../js/extend":"extend","bootstrap-datepicker":"bootstrap-datepicker","../time/timepicker":"timepicker","../../js/dropdown.jquery":"dropdown.jquery"}],
   "distresspicker":[function(require,module,exports){
   'use strict';

   var Widget = require( '../../js/Widget' );
   var $ = require( 'jquery' );
   require( 'bootstrap-slider-basic' );

   var pluginName = 'distresspicker';

   /**
    * Creates a distress picker.
    *
    * @constructor
    * @param {Element} element Element to apply widget to.
    * @param {(boolean|{touch: boolean})} options options
    * @param {*=} event     event
    */

   function Distresspicker( element, options, event ) {
       this.namespace = pluginName;
       Widget.call( this, element, options );
       this._init();
   }

   //copy the prototype functions from the Widget super class
   Distresspicker.prototype = Object.create( Widget.prototype );

   //ensure the constructor is the new one
   Distresspicker.prototype.constructor = Distresspicker;

   /**
    * Initialize
    */
   Distresspicker.prototype._init = function() {
       var value = Number( this.element.value ) || -1;

       this.props = this._getProps();

       $( this.element ).slider( {
           reversed: true,
           min: -1,
           max: 10,
           orientation: 'vertical',
           step: this.props.step,
           value: value,
           enabled: !this.props.readonly
       } );
       this.$widget = $( this.element ).next( '.widget' );
       this.$slider = this.$widget.find( '.slider' );
       this._addBulb();
       this._addScale();
       this._setChangeListener();
   };

   Distresspicker.prototype._getProps = function() {
       var type = this.element.attributes[ 'data-type-xml' ].value;

       return {
           touch: this.options.touch,
           readonly: this.element.readOnly,
           step: type === 'decimal' ? 0.1 : 1,
       };
   };

   Distresspicker.prototype._addBulb = function() {
       this.$slider.append(
           '<div class="bulb"><div class="inner"></div></div>'
       );
   };

   Distresspicker.prototype._addScale = function() {
       var $scale = $( '<div class="scale"></div>' );
       for ( var i = 10; i >= -1; i-- ) {
           $scale.append( '<div class="number"><div class="value">' + i + '</div></div>' );
       }
       this.$slider.prepend( $scale );
   };

   /**
    * Set delegated event handlers
    */
   Distresspicker.prototype._setChangeListener = function() {
       $( this.element ).on( 'slideStop.' + this.namespace, function() {
           // set to empty if value = -1
           if ( Number( this.value ) === -1 ) {
               this.value = '';
           }
           $( this ).trigger( 'change' );
       } );
   };

   Distresspicker.prototype.disable = function() {
       var value = ( this.element.value !== '' ) ? Number( this.element.value ) : -1;
       $( this.element )
           .slider( 'disable' )
           .slider( 'setValue', value, false );
   };

   Distresspicker.prototype.enable = function() {
       $( this.element )
           .slider( 'enable' );
   };

   Distresspicker.prototype.update = function() {
       var value = ( this.element.value !== '' ) ? Number( this.element.value ) : -1;
       var $el = $( this.element );
       var sliderValue = $el.slider( 'getValue' );

       if ( value !== sliderValue ) {
           $( this.element )
               .slider( 'setValue', value, false );
       }
   };

   $.fn[ pluginName ] = function( options, event ) {
       return this.each( function() {
           var $this = $( this ),
               data = $( this ).data( pluginName );

           options = options || {};

           if ( !data && typeof options === 'object' ) {
               $this.data( pluginName, new Distresspicker( this, options, event ) );
           } else if ( data && typeof options === 'string' ) {
               //pass the context, used for destroy() as this method is called on a cloned widget
               data[ options ]( this );
           }
       } );
   };

   module.exports = {
       'name': pluginName,
       'selector': '.or-appearance-distress input[type="number"]'
   };

   },{"../../js/Widget":"Widget","jquery":"jquery","bootstrap-slider-basic":"bootstrap-slider-basic"}],
   "filepicker":[function(require,module,exports){
   'use strict';
   var $ = require( 'jquery' );
   var Widget = require( '../../js/Widget' );
   var fileManager = require( '../../js/file-manager' );
   var utils = require( '../../js/utils' );
   var pluginName = 'filepicker';

   /**
    * FilePicker that works both offline and online. It abstracts the file storage/cache away
    * with the injected fileManager.
    *
    * @constructor
    * @param {Element} element [description]
    * @param {(boolean|{touch: boolean, maxlength:number})} options options
    * @param {*=} e     event
    */

   function Filepicker( element, options, e ) {
       if ( e ) {
           e.stopPropagation();
           e.preventDefault();
       }
       this.namespace = pluginName;
       Widget.call( this, element, options );
       this._init();
   }

   // copy the prototype functions from the Widget super class
   Filepicker.prototype = Object.create( Widget.prototype );

   // ensure the constructor is the new one
   Filepicker.prototype.constructor = Filepicker;

   /**
    * Initialize
    */
   Filepicker.prototype._init = function() {
       var $input = $( this.element );
       var existingFileName = $input.attr( 'data-loaded-file-name' );
       var that = this;

       this.props = this._getProps();

       $input
           .prop( 'disabled', true )
           .addClass( 'transparent' )
           .parent().addClass( 'with-media clearfix' );

       this.$widget = $(
               '<div class="widget file-picker">' +
               '<input class="ignore fake-file-input" type="button"/>' +
               '<div class="file-feedback"></div>' +
               '<div class="file-preview"></div>' +
               '</div>' )
           .insertAfter( $input );
       this.$feedback = this.$widget.find( '.file-feedback' );
       this.$preview = this.$widget.find( '.file-preview' );
       this.$fakeInput = this.$widget.find( '.fake-file-input' );
       // Focus listener needs to be added synchronously
       that._focusListener();

       // show loaded file name regardless of whether widget is supported
       if ( existingFileName ) {
           this._showFileName( existingFileName, this.props.mediaType );
       }

       if ( !fileManager || !fileManager.isSupported() ) {
           var advice = ( fileManager.notSupportedAdvisoryMsg ) ? fileManager.notSupportedAdvisoryMsg : '';
           this._showFeedback( 'Media questions are not supported in this browser. ' + advice, 'warning' );
           return;
       }

       if ( fileManager.isWaitingForPermissions() ) {
           this._showFeedback( 'Waiting for user permissions.', 'warning' );
       }

       fileManager.init()
           .then( function() {
               that._showFeedback();
               that._changeListener();
               $input.prop( 'disabled', false );
               if ( existingFileName ) {
                   fileManager.getFileUrl( existingFileName )
                       .then( function( url ) {
                           that._showPreview( url, that.props.mediaType );
                       } )
                       .catch( function() {
                           that._showFeedback( 'File "' + existingFileName + '" could not be found (leave unchanged if already submitted and you want to preserve it).', 'error' );
                       } );
               }
           } )
           .catch( function( error ) {
               that._showFeedback( error.message, 'error' );
           } );
   };

   Filepicker.prototype._getProps = function() {
       return {
           mediaType: this.element.getAttribute( 'accept' ),
           touch: this.options.touch,
           readonly: this.element.readOnly,
       };
   };

   Filepicker.prototype._getMaxSubmissionSize = function() {
       var maxSize = $( document ).data( 'maxSubmissionSize' );
       return maxSize || 5 * 1024 * 1024;
   };

   Filepicker.prototype._changeListener = function() {
       var that = this;

       $( this.element )
           .on( 'click', function( event ) {
               if ( that.props.readonly ) {
                   event.stopImmediatePropagation();
                   return false;
               }
           } ).on( 'change.propagate.' + this.namespace, function( event ) {
               var file;
               var fileName;
               var postfix;
               var $input = $( this );
               var loadedFileName = $input.attr( 'data-loaded-file-name' );
               var now = new Date();

               if ( event.namespace === 'propagate' ) {
                   // trigger eventhandler to update instance value
                   $input.trigger( 'change.file' );
                   return false;
               } else {
                   event.stopImmediatePropagation();
               }

               // get the file
               file = this.files[ 0 ];
               postfix = '-' + now.getHours() + '_' + now.getMinutes() + '_' + now.getSeconds();
               this.dataset.filenamePostfix = postfix;
               fileName = utils.getFilename( file, postfix );

               // process the file
               fileManager.getFileUrl( file, fileName )
                   .then( function( url ) {
                       // update UI
                       that._showPreview( url, that.props.mediaType );
                       that._showFeedback( '' );
                       that._showFileName( fileName );
                       if ( loadedFileName && loadedFileName !== fileName ) {
                           $input.removeAttr( 'data-loaded-file-name' );
                       }
                       // update record
                       $input.trigger( 'change.propagate' );
                   } )
                   .catch( function( error ) {
                       // update record to clear any existing valid value
                       $input.val( '' ).trigger( 'change.propagate' );
                       // update UI
                       that._showFileName( '' );
                       that._showPreview( null );
                       that._showFeedback( error.message, 'error' );
                   } );
           } );

       this.$fakeInput.on( 'click', function( e ) {
           e.preventDefault();
           $( that.element ).click();
       } );
   };

   Filepicker.prototype._focusListener = function() {
       var that = this;

       // Handle focus on widget input
       this.$fakeInput.on( 'focus', function( event ) {
           $( that.element ).trigger( 'fakefocus' );
       } );

       // Handle focus on original input (goTo functionality)
       $( this.element ).on( 'applyfocus', function() {
           that.$fakeInput.focus();
       } );
   };

   Filepicker.prototype._showFileName = function( fileName ) {
       this.$fakeInput.val( fileName );
   };

   Filepicker.prototype._showFeedback = function( message, status ) {
       message = message || '';
       status = status || '';
       // replace text and replace all existing classes with the new status class
       this.$feedback.text( message ).attr( 'class', 'file-feedback ' + status );
   };

   Filepicker.prototype._showPreview = function( url, mediaType ) {
       var $el;

       this.$widget.find( '.file-preview' ).empty();

       switch ( mediaType ) {
           case 'image/*':
               $el = $( '<img />' );
               break;
           case 'audio/*':
               $el = $( '<audio controls="controls"/>' );
               break;
           case 'video/*':
               $el = $( '<video controls="controls"/>' );
               break;
           default:
               $el = $( '<span>No preview for this mediatype</span>' );
               break;
       }

       if ( url ) {
           this.$preview.append( $el.attr( 'src', url ) );
       }
   };

   $.fn[ pluginName ] = function( options, event ) {

       options = options || {};

       return this.each( function() {
           var $this = $( this ),
               data = $this.data( pluginName );

           //only instantiate if options is an object (i.e. not a string) and if it doesn't exist already
           if ( !data && typeof options === 'object' ) {
               $this.data( pluginName, new Filepicker( this, options, event ) );
           }
           //only call method if widget was instantiated before
           else if ( data && typeof options === 'string' ) {
               //pass the element as a parameter as this is used in fix()
               data[ options ]( this );
           }
       } );
   };

   module.exports = {
       'name': pluginName,
       'selector': 'input[type="file"]'
   };

   },{"jquery":"jquery","../../js/Widget":"Widget","../../js/file-manager":"file-manager","../../js/utils":"utils"}],
   "geopicker":[function(require,module,exports){
   'use strict';

   var $ = require( 'jquery' );
   var Widget = require( '../../js/Widget' );
   var config = require( 'enketo-config' );
   var L = require( 'leaflet' );
   var Promise = require( 'lie' );
   var t = require( 'translator' ).t;

   var googleMapsScriptRequest;
   var pluginName = 'geopicker';
   var defaultZoom = 15;
   // MapBox TileJSON format
   var maps = ( config && config.maps && config.maps.length > 0 ) ? config.maps : [ {
       'name': 'streets',
       'maxzoom': 24,
       'tiles': [ 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png' ],
       'attribution': ' <a href=\"http://openstreetmap.org\">OpenStreetMap</a> | <a href=\"www.openstreetmap.org/copyright\">Terms</a>'
   } ];
   var searchSource = 'https://maps.googleapis.com/maps/api/geocode/json?address={address}&sensor=true&key={api_key}';
   var googleApiKey = config.googleApiKey || config.google_api_key;
   var iconSingle = L.divIcon( {
       iconSize: 24,
       className: 'enketo-geopoint-marker'
   } );
   var iconMulti = L.divIcon( {
       iconSize: 16,
       className: 'enketo-geopoint-circle-marker'
   } );
   var iconMultiActive = L.divIcon( {
       iconSize: 16,
       className: 'enketo-geopoint-circle-marker-active'
   } );

   /**
    * Geotrace widget Class
    * @constructor
    * @param {Element} element [description]
    * @param {(boolean|{touch: boolean, repeat: boolean})} options options
    * @param {*=} e     event
    */

   function Geopicker( element, options ) {
       this.namespace = pluginName;
       // call the super class constructor
       Widget.call( this, element, options );

       this._init();
   }

   // copy the prototype functions from the Widget super class
   Geopicker.prototype = Object.create( Widget.prototype );

   // ensure the constructor is the new one
   Geopicker.prototype.constructor = Geopicker;

   /**
    * Initializes the picker
    */
   Geopicker.prototype._init = function() {
       var loadedVal = $( this.element ).val().trim();
       var that = this;

       this.$form = $( this.element ).closest( 'form.or' );
       this.$question = $( this.element ).closest( '.question' );

       this.mapId = Math.round( Math.random() * 10000000 );
       this.props = this._getProps();

       this._addDomElements();
       this.currentIndex = 0;
       this.points = [];

       // load default value
       if ( loadedVal ) {
           $( this.element ).val().trim().split( ';' ).forEach( function( el, i ) {
               // console.debug( 'adding loaded point', el.trim().split( ' ' ) );
               that.points[ i ] = el.trim().split( ' ' );
               that.points[ i ].forEach( function( str, i, arr ) {
                   arr[ i ] = Number( str );
               } );
           } );
       }

       // handle point input changes
       this.$widget.find( '[name="lat"], [name="long"], [name="alt"], [name="acc"]' ).on( 'change change.bymap change.bysearch', function( event ) {
           var lat = that.$lat.val() ? Number( that.$lat.val() ) : '';
           var lng = that.$lng.val() ? Number( that.$lng.val() ) : '';
           // we need to avoid a missing alt in case acc is not empty!
           var alt = that.$alt.val() ? Number( that.$alt.val() ) : '';
           var acc = that.$acc.val() ? Number( that.$acc.val() ) : '';
           var latLng = {
               lat: lat,
               lng: lng
           };

           event.stopImmediatePropagation();

           // if the points array contains empty points, skip the intersection check, it will be done before closing the polygon
           if ( event.namespace !== 'bymap' && event.namespace !== 'bysearch' && that.polyline && !that.containsEmptyPoints( that.points, that.currentIndex ) && that.updatedPolylineWouldIntersect( latLng, that.currentIndex ) ) {
               that._showIntersectError();
               that._updateInputs( that.points[ that.currentIndex ], 'nochange' );
           } else {
               that._editPoint( [ lat, lng, alt, acc ] );

               if ( event.namespace !== 'bysearch' && that.$search ) {
                   that.$search.val( '' );
               }
           }
       } );

       // handle KML input changes
       this.$kmlInput.on( 'change', function( event ) {
           var $addPointBtn = that.$points.find( '.addpoint' );
           var $progress = $( this ).prev( '.paste-progress' ).removeClass( 'hide' );
           var value = event.target.value;
           var coords = that._convertKmlCoordinatesToLeafletCoordinates( value );

           // reset textarea
           event.target.value = '';

           setTimeout( function() {
               // mimic manual input point-by-point
               coords.forEach( function( latLng, index ) {
                   that._updateInputs( latLng );
                   if ( index < coords.length - 1 ) {
                       $addPointBtn.click();
                   }
               } );
               // remove progress bar;
               $progress.remove();
               // switch to points input mode
               that._switchInputType( 'points' );
           }, 10 );
       } );

       // handle input switcher
       this.$widget.find( '.toggle-input-type-btn' ).on( 'click', function() {
           var type = that.$inputGroup.hasClass( 'kml-input-mode' ) ? 'points' : 'kml';
           that._switchInputType( type );
           return false;
       } );

       // handle original input changes
       $( this.element )
           .on( 'change', function() {
               that.$kmlInput.prop( 'disabled', !!this.value );
           } )
           .on( 'applyfocus', function() {
               that.$widget[ 0 ].querySelector( 'input' ).focus();
           } );

       // handle point switcher
       this.$points.on( 'click', '.point', function() {
           that._setCurrent( that.$points.find( '.point' ).index( $( this ) ) );
           that._switchInputType( 'points' );
           return false;
       } );

       // handle addpoint button click
       this.$points.find( '.addpoint' ).on( 'click', function() {
           that._addPoint();
           return false;
       } );

       // handle polygon close button click
       this.$widget.find( '.close-chain-btn' ).on( 'click', function() {
           that._closePolygon();
           return false;
       } );

       // handle point remove click
       this.$widget.find( '.btn-remove' ).on( 'click', function() {
           if ( that.points.length < 2 ) {
               that._updateInputs( [] );
           } else if ( window.confirm( 'This will completely remove the current geopoint from the list of geopoints and cannot be undone. Are you sure you want to do this?' ) ) {
               that._removePoint();
           }
       } );

       // handle fullscreen map button click
       this.$map.find( '.show-map-btn' ).on( 'click', function() {
           that.$widget.find( '.search-bar' ).removeClass( 'hide-search' );
           that.$widget.addClass( 'full-screen' );
           that._updateMap();
           return false;
       } );

       // ensure all tiles are displayed when revealing page, https://github.com/kobotoolbox/enketo-express/issues/188
       // remove handler once it has been used
       this.$form.on( 'pageflip.enketo.map' + this.mapId, function( event ) {
           if ( that.map && $.contains( event.target, that.element ) ) {
               that.map.invalidateSize();
               that.$form.off( 'pageflip.enketo.map' + that.mapId );
           }
       } );

       // add wide class if question is wide
       if ( this.props.wide ) {
           this.$widget.addClass( 'wide' );
       }

       // copy hide-input class from question to widget and add show/hide input controller
       this.$widget
           .toggleClass( 'hide-input', this.$question.hasClass( 'or-appearance-hide-input' ) )
           .find( '.toggle-input-visibility-btn' ).on( 'click', function() {
               that.$widget.toggleClass( 'hide-input' );
               $( this ).toggleClass( 'open', that.$widget.hasClass( 'hide-input' ) );
               if ( that.map ) {
                   that.map.invalidateSize( false );
               }
           } ).toggleClass( 'open', that.$widget.hasClass( 'hide-input' ) );

       // hide map controller
       this.$widget.find( '.hide-map-btn' ).on( 'click', function() {
           that.$widget.find( '.search-bar' ).addClass( 'hide-search' );
           that.$widget.removeClass( 'full-screen' ).find( '.map-canvas' ).removeClass( 'leaflet-container' )
               .find( '.leaflet-google-layer' ).remove();
           if ( that.map ) {
               that.map.remove();
               that.map = null;
               that.polygon = null;
               that.polyline = null;
           }
           return false;
       } );

       // pass focus events on widget elements back to original input
       this.$widget.on( 'focus', 'input', function( event ) {
           $( that.element ).trigger( 'fakefocus' );
       } );

       // enable search
       if ( this.props.search ) {
           this._enableSearch();
       }

       // enable detection
       if ( this.props.detect ) {
           this._enableDetection();
       }

       if ( this.props.readonly ) {
           this.disable( this.element );
       }

       // create "point buttons"
       if ( loadedVal ) {
           this.points.forEach( function() {
               that._addPointBtn();
           } );
       } else {
           this._addPoint();
       }

       // set map location on load
       if ( !loadedVal ) {
           // set worldview in case permissions take too long (e.g. in FF);
           this._updateMap( [ 0, 0 ], 1 );
           if ( this.props.detect ) {
               navigator.geolocation.getCurrentPosition( function( position ) {
                   that._updateMap( [ position.coords.latitude, position.coords.longitude ], defaultZoom );
               } );
           }
       } else {
           // center map around first loaded geopoint value
           //this._updateMap( L.latLng( this.points[ 0 ][ 0 ], this.points[ 0 ][ 1 ] ) );
           this._updateMap();
           this._setCurrent( this.currentIndex );
       }
   };

   Geopicker.prototype._switchInputType = function( type ) {
       if ( type === 'kml' ) {
           this.$inputGroup.addClass( 'kml-input-mode' );
       } else if ( type === 'points' ) {
           this.$inputGroup.removeClass( 'kml-input-mode' );
       }
   };

   /**
    * Gets the widget properties and features.
    *
    * @return {{search: boolean, detect: boolean, map: boolean, updateMapFn: string, type: string}} The widget properties object
    */
   Geopicker.prototype._getProps = function() {
       var appearances = [];
       var map = this.options.touch !== true || ( this.options.touch === true && $( this.element ).closest( '.or-appearance-maps' ).length > 0 );

       if ( map ) {
           appearances = $( this.element ).closest( '.question' ).attr( 'class' ).split( ' ' )
               .filter( function( item ) {
                   return item !== 'or-appearance-maps' && /or-appearance-/.test( item );
               } );
           appearances.forEach( function( appearance, index ) {
               appearances[ index ] = appearance.substring( 14 );
           } );
       }

       return {
           detect: !!navigator.geolocation,
           map: map,
           search: map,
           appearances: appearances,
           type: this.element.attributes[ 'data-type-xml' ].value,
           touch: this.options.touch,
           wide: ( this.$question.width() / this.$question.closest( 'form.or' ).width() > 0.8 ),
           readonly: this.element.readOnly
       };
   };

   /**
    * Adds a point button in the point navigation bar
    */
   Geopicker.prototype._addPointBtn = function() {
       this.$points.find( '.addpoint' ).before( '<a href="#" class="point"> </a>' );
   };

   /**
    * Adds the DOM elements
    */
   Geopicker.prototype._addDomElements = function() {
       var map = '<div class="map-canvas-wrapper"><div class=map-canvas id="map' + this.mapId + '"></div></div>';
       var points = '<div class="points"><button type="button" class="addpoint">+</button></div>';
       var kmlPstTxt = t( 'geopicker.kmlpaste' );
       var kmlCrdsTxt = t( 'geopicker.kmlcoords' );
       var pntsTxt = t( 'geopicker.points' );
       var kml = '<a href="#" class="toggle-input-type-btn"><span class="kml-input">KML</span><span class="points-input">' + pntsTxt + '</span></a>' +
           '<label class="geo kml">' + kmlCrdsTxt +
           '<progress class="paste-progress hide"></progress>' +
           '<textarea class="ignore" name="kml" placeholder="' + kmlPstTxt + '"></textarea>' +
           '<span class="disabled-msg">remove all points to enable</span>' +
           '</label>';
       var closePlgnTxt = t( 'geopicker.closepolygon' );
       var close = '<button type="button" class="close-chain-btn btn btn-default btn-xs">' + closePlgnTxt + '</button>';
       var mapBtn = '<button type="button" class="show-map-btn btn btn-default">Map</button>';
       var latTxt = t( 'geopicker.latitude' );
       var lngTxt = t( 'geopicker.longitude' );
       var altTxt = t( 'geopicker.altitude' );
       var accTxt = t( 'geopicker.accuracy' );
       var srchTxt = t( 'geopicker.searchPlaceholder' );

       this.$widget = $(
           '<div class="geopicker widget">' +
           '<div class="search-bar hide-search no-map no-detect">' +
           '<button type="button" class="hide-map-btn btn btn-default"><span class="icon icon-arrow-left"> </span></button>' +
           '<button name="geodetect" type="button" class="btn btn-default" title="detect current location" data-placement="top">' +
           '<span class="icon icon-crosshairs"> </span></button>' +
           '<div class="input-group">' +
           '<input class="geo ignore" name="search" type="text" placeholder="' + srchTxt + '" disabled="disabled"/>' +
           '<button type="button" class="btn btn-default search-btn"><i class="icon icon-search"> </i></button>' +
           '</div>' +
           '</div>' +
           '<div class="geo-inputs">' +
           '<label class="geo lat">' + latTxt + '<input class="ignore" name="lat" type="number" step="0.000001" min="-90" max="90"/></label>' +
           '<label class="geo long">' + lngTxt + '<input class="ignore" name="long" type="number" step="0.000001" min="-180" max="180"/></label>' +
           '<label class="geo alt">' + altTxt + '<input class="ignore" name="alt" type="number" step="0.1" /></label>' +
           '<label class="geo acc">' + accTxt + '<input class="ignore" name="acc" type="number" step="0.1" /></label>' +
           '<button type="button" class="btn-icon-only btn-remove"><span class="icon icon-trash"> </span></button>' +
           '</div>' +
           '</div>'
       );

       // add the detection button
       if ( this.props.detect ) {
           this.$widget.find( '.search-bar' ).removeClass( 'no-detect' );
           this.$detect = this.$widget.find( 'button[name="geodetect"]' );
       }

       this.$search = this.$widget.find( '[name="search"]' );
       this.$inputGroup = this.$widget.find( '.geo-inputs' );

       // add the map canvas
       if ( this.props.map ) {
           this.$widget.find( '.search-bar' ).removeClass( 'no-map' ).after( map );
           this.$map = this.$widget.find( '.map-canvas' );
           // add the hide/show inputs button
           this.$map.parent().append( '<button type="button" class="toggle-input-visibility-btn"> </button>' );
       } else {
           this.$map = $();
       }

       // touchscreen maps
       if ( this.props.touch && this.props.map ) {
           this.$map.append( mapBtn );
       }

       // unhide search bar
       // TODO: can be done in CSS?
       if ( !this.props.touch ) {
           this.$widget.find( '.search-bar' ).removeClass( 'hide-search' );
       }

       // if geoshape or geotrace
       if ( this.props.type !== 'geopoint' ) {
           // add points bar
           this.$points = $( points );
           this.$widget.prepend( this.$points );
           // add polygon 'close' button
           if ( this.props.type === 'geoshape' ) {
               this.$inputGroup.append( close );
           }
           // add KML paste textarea;
           var $kml = $( kml );
           this.$kmlInput = $kml.find( '[name="kml"]' );
           this.$inputGroup.prepend( $kml );
       } else {
           this.$points = $();
           this.$kmlInput = $();
       }

       this.$lat = this.$widget.find( '[name="lat"]' );
       this.$lng = this.$widget.find( '[name="long"]' );
       this.$alt = this.$widget.find( '[name="alt"]' );
       this.$acc = this.$widget.find( '[name="acc"]' );


       $( this.element ).hide().after( this.$widget ).parent().addClass( 'clearfix' );
   };

   /**
    * Updates the value in the original input element.
    *
    * @return {Boolean} Whether the value was changed.
    */
   Geopicker.prototype._updateValue = function() {
       var oldValue = $( this.element ).val();
       var newValue = '';
       var that = this;

       this._markAsValid();

       // all points should be valid geopoints and only the last item may be empty
       this.points.forEach( function( point, index, array ) {
           var geopoint;
           var lat = typeof point[ 0 ] === 'number' ? point[ 0 ] : ( typeof point.lat === 'number' ? point.lat : null );
           var lng = typeof point[ 1 ] === 'number' ? point[ 1 ] : ( typeof point.lng === 'number' ? point.lng : null );
           var alt = typeof point[ 2 ] === 'number' ? point[ 2 ] : 0.0;
           var acc = typeof point[ 3 ] === 'number' ? point[ 3 ] : 0.0;

           geopoint = ( lat && lng ) ? lat + ' ' + lng + ' ' + alt + ' ' + acc : '';

           // only last item may be empty
           if ( !that._isValidGeopoint( geopoint ) && !( geopoint === '' && index === array.length - 1 ) ) {
               that._markAsInvalid( index );
           }
           // newGeoTraceValue += geopoint;
           if ( !( geopoint === '' && index === array.length - 1 ) ) {
               newValue += geopoint;
               if ( index !== array.length - 1 ) {
                   newValue += ';';
               }
           } else {
               // remove trailing semi-colon
               newValue = newValue.substring( 0, newValue.lastIndexOf( ';' ) );
           }
       } );

       // console.log( 'updating value by joining', this.points, 'old value', oldValue, 'new value', newValue );

       if ( oldValue !== newValue ) {
           $( this.element ).val( newValue ).trigger( 'change' );
           return true;
       } else {
           return false;
       }
   };

   /**
    * Checks an Openrosa geopoint for validity. This function is used to provide more detailed
    * error feedback than provided by the form controller. This can be used to pinpoint the exact
    * invalid geopoints in a list of geopoints (the form controller only validates the total list).
    *
    * @param  {string}  geopoint [description]
    * @return {Boolean}          [description]
    */
   Geopicker.prototype._isValidGeopoint = function( geopoint ) {
       var coords;

       if ( !geopoint ) {
           return false;
       }

       coords = geopoint.toString().split( ' ' );
       return (
           ( coords[ 0 ] !== '' && coords[ 0 ] >= -90 && coords[ 0 ] <= 90 ) &&
           ( coords[ 1 ] !== '' && coords[ 1 ] >= -180 && coords[ 1 ] <= 180 ) &&
           ( typeof coords[ 2 ] === 'undefined' || !isNaN( coords[ 2 ] ) ) &&
           ( typeof coords[ 3 ] === 'undefined' || ( !isNaN( coords[ 3 ] ) && coords[ 3 ] >= 0 ) )
       );
   };

   /**
    * Validates a list of latLng Arrays or Objects
    * @param  {Array.((Array.<number|string>|{lat: number, long:number}))}  latLngs Array of latLng objects or arrays
    * @return {Boolean}         Whether list is valid or not
    */
   Geopicker.prototype._isValidLatLngList = function( latLngs ) {
       var that = this;

       return latLngs.every( function( latLng, index, array ) {
           return that._isValidLatLng( latLng ) || ( latLng.join() === '' && index === array.length - 1 );
       } );
   };

   /**
    * Validates an individual latlng Array or Object
    * @param  {(Array.<number|string>|{lat: number, long:number})}  latLng latLng object or array
    * @return {Boolean}        Whether latLng is valid or not
    */
   Geopicker.prototype._isValidLatLng = function( latLng ) {
       var lat;
       var lng;

       lat = ( typeof latLng[ 0 ] === 'number' ) ? latLng[ 0 ] : ( typeof latLng.lat === 'number' ) ? latLng.lat : null;
       lng = ( typeof latLng[ 1 ] === 'number' ) ? latLng[ 1 ] : ( typeof latLng.lng === 'number' ) ? latLng.lng : null;

       return ( lat !== null && lng !== null && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180 );
   };

   /**
    * Marks a point as invalid in the points navigation bar
    * @param  {number} index Index of point
    */
   Geopicker.prototype._markAsInvalid = function( index ) {
       this.$points.find( '.point' ).eq( index ).addClass( 'has-error' );
   };

   /**
    * Marks all points as valid in the points navigation bar
    */
   Geopicker.prototype._markAsValid = function() {
       this.$points.find( '.point' ).removeClass( 'has-error' );
   };

   /**
    * Changes the current point in the list of points
    */
   Geopicker.prototype._setCurrent = function( index ) {
       this.currentIndex = index;
       this.$points.find( '.point' ).removeClass( 'active' ).eq( index ).addClass( 'active' );
       this._updateInputs( this.points[ index ], '' );
       // make sure that the current marker is marked as active
       if ( this.map && ( !this.props.touch || this._inFullScreenMode() ) ) {
           this._updateMarkers();
       }
       // console.debug( 'set current index to ', this.currentIndex );
   };

   /**
    * Enables geo detection using the built-in browser geoLocation functionality
    */
   Geopicker.prototype._enableDetection = function() {
       var that = this;
       var options = {
           enableHighAccuracy: true,
           maximumAge: 0
       };
       this.$detect.click( function( event ) {
           event.preventDefault();
           navigator.geolocation.getCurrentPosition( function( position ) {
               var latLng = {
                   lat: Math.round( position.coords.latitude * 1000000 ) / 1000000,
                   lng: Math.round( position.coords.longitude * 1000000 ) / 1000000
               };

               if ( that.polyline && that.updatedPolylineWouldIntersect( latLng, that.currentIndex ) ) {
                   that._showIntersectError();
               } else {
                   //that.points[that.currentIndex] = [ position.coords.latitude, position.coords.longitude ];
                   //that._updateMap( );
                   that._updateInputs( [ latLng.lat, latLng.lng, position.coords.altitude, position.coords.accuracy ] );
                   // if current index is last of points, automatically create next point
                   if ( that.currentIndex === that.points.length - 1 && that.props.type !== 'geopoint' ) {
                       that._addPoint();
                   }
               }
           }, function() {
               console.error( 'error occurred trying to obtain position' );
           }, options );
           return false;
       } );
   };

   /**
    * Enables search functionality using the Google Maps API v3
    * This only changes the map view. It does not record geopoints.
    */
   Geopicker.prototype._enableSearch = function() {
       var that = this;

       if ( googleApiKey ) {
           searchSource = searchSource.replace( '{api_key}', googleApiKey );
       } else {
           searchSource = searchSource.replace( '&key={api_key}', '' );
       }

       this.$search
           .prop( 'disabled', false )
           .on( 'change', function( event ) {
               var address = $( this ).val();
               event.stopImmediatePropagation();

               if ( address ) {
                   address = address.split( /\s+/ ).join( '+' );
                   $.get( searchSource.replace( '{address}', address ), function( response ) {
                           var latLng;
                           if ( response.results && response.results.length > 0 && response.results[ 0 ].geometry && response.results[ 0 ].geometry.location ) {
                               latLng = response.results[ 0 ].geometry.location;
                               that._updateMap( [ latLng.lat, latLng.lng ], defaultZoom );
                               that.$search.closest( '.input-group' ).removeClass( 'has-error' );
                           } else {
                               //TODO: add error message
                               that.$search.closest( '.input-group' ).addClass( 'has-error' );
                               console.log( 'Location "' + address + '" not found' );
                           }
                       }, 'json' )
                       .fail( function() {
                           //TODO: add error message
                           that.$search.closest( '.input-group' ).addClass( 'has-error' );
                           console.log( 'Error. Geocoding service may not be available or app is offline' );
                       } )
                       .always( function() {

                       } );
               } else {

               }
           } );
   };

   /**
    * Determines whether map is available for manipulation.
    */
   Geopicker.prototype._dynamicMapAvailable = function() {
       return !!this.map;
   };

   Geopicker.prototype._inFullScreenMode = function() {
       return this.$widget.hasClass( 'full-screen' );
   };

   /**
    * Updates the map to either show the provided coordinates (in the center), with the provided zoom level
    * or update any markers, polylines, or polygons.
    *
    * @param  @param  {Array.<number>|{lat: number, lng: number}} latLng  latitude and longitude coordinates
    * @param  {number=} zoom zoom level
    * @return {Function} Returns call to function
    */
   Geopicker.prototype._updateMap = function( latLng, zoom ) {
       var that = this;

       // check if the widget is supposed to have a map
       if ( !this.props.map ) {
           return;
       }

       // determine zoom level
       if ( !zoom ) {
           if ( this.map ) {
               // note: there are conditions where getZoom returns undefined!
               zoom = this.map.getZoom() || defaultZoom;
           } else {
               zoom = defaultZoom;
           }
       }

       // update last requested map coordinates to be used to initialize map in mobile fullscreen view
       if ( latLng ) {
           this.lastLatLng = latLng;
           this.lastZoom = zoom;
       }

       // update the map if it is visible
       if ( !this.props.touch || this._inFullScreenMode() ) {
           if ( !this.map ) {
               this._addDynamicMap()
                   .then( function() {
                       that._updateDynamicMapView( latLng, zoom );
                   } );
           } else {
               that._updateDynamicMapView( latLng, zoom );
           }
       }
   };

   Geopicker.prototype._addDynamicMap = function() {
       var that = this;

       return this._getLayers()
           .then( function( layers ) {
               var options = {
                   layers: that._getDefaultLayer( layers )
               };

               that.map = L.map( 'map' + that.mapId, options )
                   .on( 'click', function( e ) {
                       var latLng;
                       var indexToPlacePoint;

                       if ( that.props.readonly ) {
                           return false;
                       }

                       latLng = e.latlng;
                       indexToPlacePoint = ( that.$lat.val() && that.$lng.val() ) ? that.points.length : that.currentIndex;

                       // reduce precision to 6 decimals
                       latLng.lat = Math.round( latLng.lat * 1000000 ) / 1000000;
                       latLng.lng = Math.round( latLng.lng * 1000000 ) / 1000000;

                       // Skip intersection check if points contain empties. It will be done later, before the polygon is closed.
                       if ( that.props.type !== 'geopoint' && !that.containsEmptyPoints( that.points, indexToPlacePoint ) && that.updatedPolylineWouldIntersect( latLng, indexToPlacePoint ) ) {
                           that._showIntersectError();
                       } else {
                           if ( !that.$lat.val() || !that.$lng.val() || that.props.type === 'geopoint' ) {
                               that._updateInputs( latLng, 'change.bymap' );
                           } else if ( that.$lat.val() && that.$lng.val() ) {
                               that._addPoint();
                               that._updateInputs( latLng, 'change.bymap' );
                           } else {
                               // do nothing if the field has a current marker
                               // instead the user will have to drag to change it by map
                           }
                       }
                   } );

               // watch out, default "Leaflet" link clicks away from page, loosing all data
               that.map.attributionControl.setPrefix( '' );

               // add layer control
               if ( layers.length > 1 ) {
                   L.control.layers( that._getBaseLayers( layers ), null ).addTo( that.map );
               }

               // change default leaflet layer control button
               that.$widget.find( '.leaflet-control-layers-toggle' ).append( '<span class="icon icon-globe"></span>' );

               // Add ignore and option-label class to Leaflet-added input elements and their labels
               // something weird seems to happen. It seems the layercontrol is added twice (second replacing first)
               // which means the classes are not present in the final control.
               // Using the baselayerchange event handler is a trick that seems to work.
               that.map.on( 'baselayerchange', function() {
                   that.$widget.find( '.leaflet-control-container input' ).addClass( 'ignore no-unselect' ).next( 'span' ).addClass( 'option-label' );
               } );
           } );
   };

   Geopicker.prototype._updateDynamicMapView = function( latLng, zoom ) {

       if ( !latLng ) {
           this._updatePolyline();
           this._updateMarkers();
           if ( this.points.length === 1 && this.points[ 0 ].toString() === '' ) {
               if ( this.lastLatLng ) {
                   this.map.setView( this.lastLatLng, this.lastZoom || defaultZoom );
               } else {
                   this.map.setView( L.latLng( 0, 0 ), zoom || defaultZoom );
               }
           }
       } else {
           this.map.setView( latLng, zoom || defaultZoom );
       }
   };

   Geopicker.prototype._showIntersectError = function() {
       window.alert( 'Borders cannot intersect!' );
   };

   /**
    * Obtains the tile layers according to the definition in the app configuration.
    *
    * @return {Promise} [description]
    */
   Geopicker.prototype._getLayers = function() {
       var that = this;
       var tasks = [];

       maps.forEach( function( map, index ) {
           if ( typeof map.tiles === 'string' && /^GOOGLE_(SATELLITE|ROADMAP|HYBRID|TERRAIN)/.test( map.tiles ) ) {
               tasks.push( that._getGoogleTileLayer( map, index ) );
           } else
           if ( map.tiles ) {
               tasks.push( that._getLeafletTileLayer( map, index ) );
           } else {
               console.error( 'Configuration error for map tiles. Not a valid tile layer: ', map );
           }
       } );

       return Promise.all( tasks );
   };

   /**
    * Asynchronously (fake) obtains a Leaflet/Mapbox tilelayer
    *
    * @param  {{}}     map   map layer as defined in the apps configuration
    * @param  {number} index the index of the layer
    * @return {Promise}
    */
   Geopicker.prototype._getLeafletTileLayer = function( map, index ) {
       var url;
       var options = this._getTileOptions( map, index );

       // randomly pick a tile source from the array and store it in the maps config
       // so it will be re-used when the form is reset or multiple geo widgets are created
       map.tileIndex = ( map.tileIndex === undefined ) ? Math.round( Math.random() * 100 ) % map.tiles.length : map.tileIndex;
       url = map.tiles[ map.tileIndex ];
       return Promise.resolve( L.tileLayer( url, options ) );
   };

   /**
    * Asynchronously obtains a Google Maps tilelayer
    *
    * @param  {{}}     map   map layer as defined in the apps configuration
    * @param  {number} index the index of the layer
    * @return {Promise}
    */
   Geopicker.prototype._getGoogleTileLayer = function( map, index ) {
       var options = this._getTileOptions( map, index );
       var type = map.tiles.substring( 7 );

       return this._loadGoogleMapsScript()
           .then( function() {
               return new L.Google( type, options );
           } );
   };

   /**
    * Creates the tile layer options object from the maps configuration and defaults.
    *
    * @param  {{}}     map   map layer as defined in the apps configuration
    * @param  {[type]} index the index of the layer
    * @return {{id: string, maxZoom: number, minZoom: number, name: string, attribution: string}}   Tilelayer options object
    */
   Geopicker.prototype._getTileOptions = function( map, index ) {
       var name = map.name || 'map-' + ( index + 1 );

       return {
           id: map.id || name,
           maxZoom: map.maxzoom || 18,
           minZoom: map.minzoom || 0,
           name: name,
           attribution: map.attribution || ''
       };
   };

   /**
    * Loader for the Google Maps script that can be called multiple times, but will ensure the
    * script is only requested once.
    *
    * @return {Promise} [description]
    */
   Geopicker.prototype._loadGoogleMapsScript = function() {
       // request Google maps script only once, using a variable outside of the scope of the current widget
       // in case multiple widgets exist in the same form
       if ( !googleMapsScriptRequest ) {
           // create deferred object, also outside of the scope of the current widget
           googleMapsScriptRequest = new Promise( function( resolve, reject ) {
               var apiKeyQueryParam, loadUrl;

               // create a global callback to be called by the Google Maps script once this has loaded
               window.gmapsLoaded = function() {
                   // clean up the global function
                   delete window.gmapsLoaded;
                   // resolve the deferred object
                   resolve();
               };
               // make the request for the Google Maps script asynchronously
               apiKeyQueryParam = ( googleApiKey ) ? '&key=' + googleApiKey : '';
               loadUrl = 'https://maps.google.com/maps/api/js?v=3.exp' + apiKeyQueryParam + '&libraries=places&callback=gmapsLoaded';
               $.getScript( loadUrl );
           } );
       }

       // return the promise of the deferred object outside of the scope of the current widget
       return googleMapsScriptRequest;
   };

   Geopicker.prototype._getDefaultLayer = function( layers ) {
       var defaultLayer;
       var that = this;

       layers.reverse().some( function( layer ) {
           defaultLayer = layer;
           return that.props.appearances.some( function( appearance ) {
               return appearance === layer.options.name;
           } );
       } );

       return defaultLayer;
   };

   Geopicker.prototype._getBaseLayers = function( layers ) {
       var baseLayers = {};

       layers.forEach( function( layer ) {
           baseLayers[ layer.options.name ] = layer;
       } );

       return baseLayers;
   };

   /**
    * Updates the markers on the dynamic map from the current list of points.
    */
   Geopicker.prototype._updateMarkers = function() {
       var coords = [];
       var markers = [];
       var that = this;

       // console.debug( 'updating markers', this.points );

       if ( this.markerLayer ) {
           this.markerLayer.clearLayers();
       }

       if ( this.points.length < 2 && this.points[ 0 ].join() === '' ) {
           return;
       }

       this.points.forEach( function( latLng, index ) {
           var icon = that.props.type === 'geopoint' ? iconSingle : ( index === that.currentIndex ? iconMultiActive : iconMulti );
           if ( that._isValidLatLng( latLng ) ) {
               coords.push( latLng );
               markers.push( L.marker( latLng, {
                   icon: icon,
                   clickable: !that.props.readonly,
                   draggable: !that.props.readonly,
                   alt: index,
                   opacity: 0.9
               } ).on( 'click', function( e ) {
                   if ( e.target.options.alt === 0 && that.props.type === 'geoshape' ) {
                       that._closePolygon();
                   } else {
                       that._setCurrent( e.target.options.alt );
                   }
               } ).on( 'dragend', function( e ) {
                   var latLng = e.target.getLatLng(),
                       index = e.target.options.alt;

                   // reduce precision to 6 decimals
                   latLng.lat = Math.round( latLng.lat * 1000000 ) / 1000000;
                   latLng.lng = Math.round( latLng.lng * 1000000 ) / 1000000;

                   if ( that.polyline && that.updatedPolylineWouldIntersect( latLng, index ) ) {
                       that._showIntersectError();
                       that._updateMarkers();
                   } else {
                       // first set the current index the point dragged
                       that._setCurrent( index );
                       that._updateInputs( latLng, 'change.bymap' );
                       that._updateMap();
                   }
               } ) );
           } else {
               console.debug( 'this latLng was not considered valid', latLng );
           }
       } );

       // console.log( 'markers to update', markers );

       if ( markers.length > 0 ) {
           this.markerLayer = L.layerGroup( markers ).addTo( this.map );
           // change the view to fit all the markers
           // don't use this for multiple markers, it messed up map clicks to place points
           if ( this.points.length === 1 || !this._isValidLatLngList( this.points ) ) {
               // center the map, keep zoom level unchanged
               this.map.setView( coords[ 0 ], this.lastZoom || defaultZoom );
           }
       }
   };

   /**
    * Updates the polyline on the dynamic map from the current list of points
    */
   Geopicker.prototype._updatePolyline = function() {
       var polylinePoints;
       var that = this;

       if ( this.props.type === 'geopoint' ) {
           return;
       }

       // console.log( 'updating polyline' );
       if ( this.points.length < 2 || !this._isValidLatLngList( this.points ) ) {
           // remove quirky line remainder
           if ( this.map ) {
               if ( this.polyline ) {
                   this.map.removeLayer( this.polyline );
               }
               if ( this.polygon ) {
                   this.map.removeLayer( this.polygon );
               }
           }
           this.polyline = null;
           this.polygon = null;
           // console.log( 'list of points invalid' );
           return;
       }

       if ( this.props.type === 'geoshape' ) {
           this._updatePolygon();
       }

       polylinePoints = ( this.points[ this.points.length - 1 ].join( '' ) !== '' ) ? this.points : this.points.slice( 0, this.points.length - 1 );

       if ( !this.polyline ) {
           this.polyline = L.polyline( polylinePoints, {
               color: 'red'
           } );
           this.map.addLayer( this.polyline );
       } else {
           this.polyline.setLatLngs( polylinePoints );
       }

       // possible bug in Leaflet, using timeout to work around
       setTimeout( function() {
           that.map.fitBounds( that.polyline.getBounds() );
       }, 0 );
   };


   /**
    * Updates the polygon on the dynamic map from the current list of points.
    * A polygon is a type of polyline. This function is ALWAYS called by _updatePolyline.
    */
   Geopicker.prototype._updatePolygon = function() {
       var polygonPoints;

       if ( this.props.type === 'geopoint' || this.props.type === 'geotrace' ) {
           return;
       }

       // console.log( 'updating polygon' );
       polygonPoints = ( this.points[ this.points.length - 1 ].join( '' ) !== '' ) ? this.points : this.points.slice( 0, this.points.length - 1 );

       if ( !this.polygon ) {
           // console.log( 'creating new polygon' );
           this.polygon = L.polygon( polygonPoints, {
               color: 'red',
               stroke: false
           } );
           this.map.addLayer( this.polygon );
       } else {
           // console.log( 'updating existing polygon', this.points );
           this.polygon.setLatLngs( polygonPoints );
       }

       this._updateArea( polygonPoints );
   };

   /**
    * Updates the area in m2 shown inside a polygon.
    * @type {[type]}
    */
   Geopicker.prototype._updateArea = function( points ) {
       var area;
       var readableArea;

       if ( points.length > 2 ) {
           area = L.GeometryUtil.geodesicArea( points );
           readableArea = L.GeometryUtil.readableArea( area );

           L.popup( {
                   className: 'enketo-area-popup'
               } )
               .setLatLng( this.polygon.getBounds().getCenter() )
               .setContent( readableArea )
               .openOn( this.map );
       } else {
           this.map.closePopup();
       }

   };

   Geopicker.prototype._addPoint = function() {
       this._addPointBtn();
       this.points.push( [] );
       this._setCurrent( this.points.length - 1 );
       this._updateValue();
   };

   /**
    * Edits a point in the list of points
    * @param  {Array.<number>|{lat: number, lng: number, alt: number, acc: number}} latLng LatLng object or array
    * @return {Boolean]}        Whether point changed.
    */
   Geopicker.prototype._editPoint = function( latLng ) {
       var changed;

       this.points[ this.currentIndex ] = latLng;

       changed = this._updateValue();

       if ( changed ) {
           this._updateMap();
       }

       return changed;
   };

   /**
    * Removes the current point
    */
   Geopicker.prototype._removePoint = function() {
       var newIndex = this.currentIndex;
       this.points.splice( this.currentIndex, 1 );
       this._updateValue();
       this.$points.find( '.point' ).eq( this.currentIndex ).remove();
       if ( typeof this.points[ this.currentIndex ] === 'undefined' ) {
           newIndex = this.currentIndex - 1;
       }
       this._setCurrent( newIndex );
       // this will call updateMarkers for the second time which is not so efficient
       this._updateMap();
   };

   Geopicker.prototype._closePolygon = function() {
       var lastPoint = this.points[ this.points.length - 1 ];
       // console.debug( 'closing polygon' );

       // check if chain can be closed
       if ( this.points.length < 3 || ( this.points.length === 3 && !this._isValidLatLng( this.points[ 2 ] ) ) || ( JSON.stringify( this.points[ 0 ] ) === JSON.stringify( lastPoint ) ) ) {
           return;
       }

       // determine which point the make the closing point
       // if the last point is not a valid point, assume the user wants to use this to close
       // otherwise create a new point.
       if ( !this._isValidLatLng( lastPoint ) ) {
           console.log( 'current last point is not a valid point, so will use this as closing point' );
           this.currentIndex = this.points.length - 1;
       } else {
           console.log( 'current last point is valid, so will create a new one to use to close' );
           this._addPoint();
       }

       // final check to see if there are intersections
       if ( this.polyline && !this.containsEmptyPoints( this.points, this.points.length ) && this.updatedPolylineWouldIntersect( this.points[ 0 ], this.currentIndex ) ) {
           return this._showIntersectError();
       }

       this._updateInputs( this.points[ 0 ] );
   };

   /**
    * Updates the (fake) input element for latitude, longitude, altitude and accuracy
    *
    * @param  @param  {Array.<number>|{lat: number, lng: number, alt: number, acc: number}} coords latitude, longitude, altitude and accuracy
    * @param  {string=} ev  [description]
    */
   Geopicker.prototype._updateInputs = function( coords, ev ) {
       var lat = coords[ 0 ] || coords.lat || '';
       var lng = coords[ 1 ] || coords.lng || '';
       var alt = coords[ 2 ] || coords.alt || '';
       var acc = coords[ 3 ] || coords.acc || '';

       ev = ( typeof ev !== 'undefined' ) ? ev : 'change';

       this.$lat.val( lat || '' );
       this.$lng.val( lng || '' );
       this.$alt.val( alt || '' );
       this.$acc.val( acc || '' ).trigger( ev );
   };

   /**
    * Converts the contents of a single KML <coordinates> element (may inlude the coordinates tags as well) to an array
    * of geopoint coordinates used in the ODK XForm format. Note that the KML format does not allow spaces within a tuple of coordinates
    * only between. Separator between KML tuples can be newline, space or a combination.
    * It only extracts the value of the first <coordinates> element or, if <coordinates> are not included from the whole string.
    *
    * @param  {string} kmlCoordinates [description]
    * @return {Array.<Array<Number>>} Array of geopoint coordinates
    */
   Geopicker.prototype._convertKmlCoordinatesToLeafletCoordinates = function( kmlCoordinates ) {
       var coordinates = [];
       var reg = /<\s?coordinates>(([^<]|\n)*)<\/\s?coordinates\s?>/;
       var tags = reg.test( kmlCoordinates );

       kmlCoordinates = ( tags ) ? kmlCoordinates.match( reg )[ 1 ] : kmlCoordinates;
       kmlCoordinates.trim().split( /\s+/ ).forEach( function( item ) {
           var coordinate = [];

           item.split( ',' ).forEach( function( c, index ) {
               var value = Number( c );
               if ( index === 0 ) {
                   coordinate[ 1 ] = value;
               } else if ( index === 1 ) {
                   coordinate[ 0 ] = value;
               } else if ( index === 2 ) {
                   coordinate[ 2 ] = value;
               }
           } );

           coordinates.push( coordinate );
       } );

       return coordinates;
   };

   /**
    * Check if a polyline created from the current collection of points
    * where one point is added or edited would have intersections.
    * @param  {[type]} latLng [description]
    * @param  {[type]} index  [description]
    * @return {[type]} [description]
    */
   Geopicker.prototype.updatedPolylineWouldIntersect = function( latLng, index ) {
       var pointsToTest = [];
       var polylinePoints;
       var polylineToTest;
       var intersects;

       if ( this.points < 3 ) {
           return false;
       }

       // create a deep copy of the current points
       $.extend( true, pointsToTest, this.points );

       // edit/add one point
       pointsToTest[ index ] = [ latLng[ 0 ] || latLng.lat, latLng[ 1 ] || latLng.lng ];

       // check whether last point is empty and remove it if so
       polylinePoints = ( pointsToTest[ pointsToTest.length - 1 ].join( '' ) !== '' ) ? pointsToTest : pointsToTest.slice( 0, pointsToTest.length - 1 );

       // remove last one if closed
       // This introduces a bug as it enables creating a spiral that is closed
       // with an intersection.
       if ( polylinePoints[ 0 ][ 0 ] === polylinePoints[ polylinePoints.length - 1 ][ 0 ] &&
           polylinePoints[ 0 ][ 1 ] === polylinePoints[ polylinePoints.length - 1 ][ 1 ] ) {
           polylinePoints = polylinePoints.slice( 0, polylinePoints.length - 1 );
       }

       // create polyline
       polylineToTest = L.polyline( polylinePoints, {
           color: 'white'
       } );

       // add to map because the Polyline draw extension expects this
       this.map.addLayer( polylineToTest );

       // check for intersection
       intersects = polylineToTest.intersects();

       // clean up
       this.map.removeLayer( polylineToTest );

       return intersects;
   };

   /**
    * Checks whether the array of points contains empty ones.
    *
    * @allowedIndex {number=} The index in which an empty value is allowed
    * @return {[type]} [description]
    */
   Geopicker.prototype.containsEmptyPoints = function( points, allowedIndex ) {
       return points.some( function( point, index ) {
           return index !== allowedIndex && ( !point[ 0 ] || !point[ 1 ] );
       } );
   };


   /**
    * Disables the widget
    */
   Geopicker.prototype.disable = function( element ) {
       $( element )
           .next( '.widget' )
           .addClass( 'readonly' )
           .find( 'input, select, textarea' ).prop( 'disabled', true )
           .end()
           .find( '.btn:not(.show-map-btn):not(.hide-map-btn), .btn-icon-only, .addpoint' ).prop( 'disabled', true );
   };

   /**
    * Enables a disabled widget
    */
   Geopicker.prototype.enable = function( element ) {
       $( element )
           .next( '.widget' )
           .removeClass( 'readonly' )
           .find( 'input, select, textarea' ).prop( 'disabled', false )
           .end()
           .find( '.btn:not(.show-map-btn):not(.hide-map-btn), .btn-icon-only, .addpoint' ).prop( 'disabled', false );

       // ensure all tiles are displayed, https://github.com/kobotoolbox/enketo-express/issues/188
       if ( this.map ) {
           this.map.invalidateSize();
       }
   };

   /**
    * Updates the widget if the value has updated programmatically (e.g. due to a calculation)
    */
   Geopicker.prototype.update = function( element ) {
       /**
        * It is somewhat complex to properly update, especially when the widget is currently
        * showing a list of geotrace/geoshape points. Hence we use the inefficient but robust
        * method to re-initialize instead.
        */
       this.destroy( element );
       $( element ).data( pluginName, new Geopicker( element, this.options, this.event ) );
   };

   $.fn[ pluginName ] = function( options, event ) {

       return this.each( function() {
           try {
               var $this = $( this );
               var data = $( this ).data( pluginName );

               options = options || {};

               if ( !data && typeof options === 'object' ) {
                   $this.data( pluginName, new Geopicker( this, options, event ) );
               } else if ( data && typeof options === 'string' ) {
                   //pass the context, used for destroy() as this method is called on a cloned widget
                   data[ options ]( this );
               }
           } catch ( e ) {
               console.log( 'Failed to initialise geopicker for ' + this + ': ' + e );
           }
       } );
   };

   // extend Leaflet
   // From https://github.com/Leaflet/Leaflet.draw/blob/master/src/ext/GeometryUtil.js
   L.GeometryUtil = L.extend( L.GeometryUtil || {}, {
       // Ported from the OpenLayers implementation. See https://github.com/openlayers/openlayers/blob/master/lib/OpenLayers/Geometry/LinearRing.js#L270
       geodesicArea: function( latLngs ) {
           var EARTH_RADIUS = 6378100,
               pointsCount = latLngs.length,
               area = 0.0,
               d2r = L.LatLng.DEG_TO_RAD, // Math.PI / 180
               p1, p2;

           if ( pointsCount > 2 ) {
               for ( var i = 0; i < pointsCount; i++ ) {
                   p1 = {
                       lat: latLngs[ i ][ 0 ],
                       lng: latLngs[ i ][ 1 ]
                   };
                   p2 = {
                       lat: latLngs[ ( i + 1 ) % pointsCount ][ 0 ],
                       lng: latLngs[ ( i + 1 ) % pointsCount ][ 1 ]
                   };

                   area += ( ( p2.lng - p1.lng ) * d2r ) *
                       ( 2 + Math.sin( p1.lat * d2r ) + Math.sin( p2.lat * d2r ) );
               }
               area = area * EARTH_RADIUS * EARTH_RADIUS / 2.0;
           }

           return Math.abs( area );
       },

       readableArea: function( area ) {
           var areaStr;

           if ( area >= 10000 ) {
               areaStr = ( area * 0.0001 ).toFixed( 2 ) + ' ha';
           } else {
               areaStr = area.toFixed( 0 ) + ' m&sup2;';
           }

           return areaStr;
       }
   } );
   // From  https://github.com/Leaflet/Leaflet.draw/blob/master/src/ext/Polyline.Intersect.js
   L.Polyline.include( {
       // Check to see if this polyline has any linesegments that intersect.
       // NOTE: does not support detecting intersection for degenerate cases.
       intersects: function() {
           var points = this._originalPoints,
               len = points ? points.length : 0,
               i, p, p1;

           if ( this._tooFewPointsForIntersection() ) {
               return false;
           }

           for ( i = len - 1; i >= 3; i-- ) {
               p = points[ i - 1 ];
               p1 = points[ i ];


               if ( this._lineSegmentsIntersectsRange( p, p1, i - 2 ) ) {
                   return true;
               }
           }
           return false;
       },

       // Polylines with 2 sides can only intersect in cases where points are collinear (we don't support detecting these).
       // Cannot have intersection when < 3 line segments (< 4 points)
       _tooFewPointsForIntersection: function( extraPoints ) {
           var points = this._originalPoints,
               len = points ? points.length : 0;
           // Increment length by extraPoints if present
           len += extraPoints || 0;

           return !this._originalPoints || len <= 3;
       },

       // Checks a line segment intersections with any line segments before its predecessor.
       // Don't need to check the predecessor as will never intersect.
       _lineSegmentsIntersectsRange: function( p, p1, maxIndex, minIndex ) {
           var points = this._originalPoints,
               p2, p3;

           minIndex = minIndex || 0;

           // Check all previous line segments (beside the immediately previous) for intersections
           for ( var j = maxIndex; j > minIndex; j-- ) {
               p2 = points[ j - 1 ];
               p3 = points[ j ];

               if ( L.LineUtil.segmentsIntersect( p, p1, p2, p3 ) ) {
                   // console.debug( 'intersection found between', p, p1, p2, p3 );
                   return true;
               }
           }

           return false;
       }
   } );
   L.Util.extend( L.LineUtil, {
       // Checks to see if two line segments intersect. Does not handle degenerate cases.
       // http://compgeom.cs.uiuc.edu/~jeffe/teaching/373/notes/x06-sweepline.pdf
       segmentsIntersect: function( /*Point*/ p, /*Point*/ p1, /*Point*/ p2, /*Point*/ p3 ) {
           return this._checkCounterclockwise( p, p2, p3 ) !==
               this._checkCounterclockwise( p1, p2, p3 ) &&
               this._checkCounterclockwise( p, p1, p2 ) !==
               this._checkCounterclockwise( p, p1, p3 );
       },

       // check to see if points are in counterclockwise order
       _checkCounterclockwise: function( /*Point*/ p, /*Point*/ p1, /*Point*/ p2 ) {
           return ( p2.y - p.y ) * ( p1.x - p.x ) > ( p1.y - p.y ) * ( p2.x - p.x );
       }
   } );


   /*
    * Google layer using Google Maps API
    * from https://github.com/shramov/leaflet-plugins/blob/master/layer/tile/Google.js
    */

   /* global google: true */

   L.Google = L.Class.extend( {
       includes: L.Mixin.Events,

       options: {
           minZoom: 0,
           maxZoom: 18,
           tileSize: 256,
           subdomains: 'abc',
           errorTileUrl: '',
           attribution: '',
           opacity: 1,
           continuousWorld: false,
           noWrap: false,
           mapOptions: {
               backgroundColor: '#dddddd'
           }
       },

       // Possible types: SATELLITE, ROADMAP, HYBRID, TERRAIN
       initialize: function( type, options ) {
           L.Util.setOptions( this, options );

           this._ready = google.maps.Map !== undefined;
           if ( !this._ready ) {
               L.Google.asyncWait.push( this );
           }

           this._type = type || 'SATELLITE';
       },

       onAdd: function( map, insertAtTheBottom ) {
           this._map = map;
           this._insertAtTheBottom = insertAtTheBottom;

           // create a container div for tiles
           this._initContainer();
           this._initMapObject();

           // set up events
           map.on( 'viewreset', this._resetCallback, this );

           this._limitedUpdate = L.Util.limitExecByInterval( this._update, 150, this );
           map.on( 'move', this._update, this );

           map.on( 'zoomanim', this._handleZoomAnim, this );

           //20px instead of 1em to avoid a slight overlap with google's attribution
           map._controlCorners.bottomright.style.marginBottom = '20px';

           this._reset();
           this._update();
       },

       onRemove: function( map ) {
           map._container.removeChild( this._container );

           map.off( 'viewreset', this._resetCallback, this );

           map.off( 'move', this._update, this );

           map.off( 'zoomanim', this._handleZoomAnim, this );

           map._controlCorners.bottomright.style.marginBottom = '0em';
       },

       getAttribution: function() {
           return this.options.attribution;
       },

       setOpacity: function( opacity ) {
           this.options.opacity = opacity;
           if ( opacity < 1 ) {
               L.DomUtil.setOpacity( this._container, opacity );
           }
       },

       setElementSize: function( e, size ) {
           e.style.width = size.x + 'px';
           e.style.height = size.y + 'px';
       },

       _initContainer: function() {
           var tilePane = this._map._container,
               first = tilePane.firstChild;

           if ( !this._container ) {
               this._container = L.DomUtil.create( 'div', 'leaflet-google-layer leaflet-top leaflet-left' );
               this._container.id = '_GMapContainer_' + L.Util.stamp( this );
               this._container.style.zIndex = 'auto';
           }

           tilePane.insertBefore( this._container, first );

           this.setOpacity( this.options.opacity );
           this.setElementSize( this._container, this._map.getSize() );
       },

       _initMapObject: function() {
           if ( !this._ready ) {
               return;
           }
           this._google_center = new google.maps.LatLng( 0, 0 );
           var map = new google.maps.Map( this._container, {
               center: this._google_center,
               zoom: 0,
               tilt: 0,
               mapTypeId: google.maps.MapTypeId[ this._type ],
               disableDefaultUI: true,
               keyboardShortcuts: false,
               draggable: false,
               disableDoubleClickZoom: true,
               scrollwheel: false,
               streetViewControl: false,
               styles: this.options.mapOptions.styles,
               backgroundColor: this.options.mapOptions.backgroundColor
           } );

           var _this = this;
           this._reposition = google.maps.event.addListenerOnce( map, 'center_changed',
               function() {
                   _this.onReposition();
               } );
           this._google = map;

           google.maps.event.addListenerOnce( map, 'idle',
               function() {
                   _this._checkZoomLevels();
               } );
           //Reporting that map-object was initialized.
           this.fire( 'MapObjectInitialized', {
               mapObject: map
           } );
       },

       _checkZoomLevels: function() {
           //setting the zoom level on the Google map may result in a different zoom level than the one requested
           //(it won't go beyond the level for which they have data).
           // verify and make sure the zoom levels on both Leaflet and Google maps are consistent
           if ( this._google.getZoom() !== this._map.getZoom() ) {
               //zoom levels are out of sync. Set the leaflet zoom level to match the google one
               this._map.setZoom( this._google.getZoom() );
           }
       },

       _resetCallback: function( e ) {
           this._reset( e.hard );
       },

       _reset: function() {
           this._initContainer();
       },

       _update: function() {
           if ( !this._google ) {
               return;
           }
           this._resize();

           var center = this._map.getCenter();
           var _center = new google.maps.LatLng( center.lat, center.lng );

           this._google.setCenter( _center );
           this._google.setZoom( Math.round( this._map.getZoom() ) );

           this._checkZoomLevels();
       },

       _resize: function() {
           var size = this._map.getSize();
           if ( this._container.style.width === size.x &&
               this._container.style.height === size.y ) {
               return;
           }
           this.setElementSize( this._container, size );
           this.onReposition();
       },


       _handleZoomAnim: function( e ) {
           var center = e.center;
           var _center = new google.maps.LatLng( center.lat, center.lng );

           this._google.setCenter( _center );
           this._google.setZoom( Math.round( e.zoom ) );
       },


       onReposition: function() {
           if ( !this._google ) {
               return;
           }
           google.maps.event.trigger( this._google, 'resize' );
       }
   } );

   L.Google.asyncWait = [];
   L.Google.asyncInitialize = function() {
       var i;
       for ( i = 0; i < L.Google.asyncWait.length; i++ ) {
           var o = L.Google.asyncWait[ i ];
           o._ready = true;
           if ( o._container ) {
               o._initMapObject();
               o._update();
           }
       }
       L.Google.asyncWait = [];
   };

   module.exports = {
       'name': pluginName,
       'selector': 'input[data-type-xml="geopoint"], input[data-type-xml="geotrace"], input[data-type-xml="geoshape"]'
   };

   },{"jquery":"jquery","../../js/Widget":"Widget","enketo-config":"text!enketo-config","leaflet":"leaflet","lie":"lie","translator":"fake-translator"}],
   "horizontalchoices":[function(require,module,exports){
   'use strict';
   /**
    * Horizontal Choices Widget
    *
    */


   var $ = require( 'jquery' );
   var Widget = require( '../../js/Widget' );

   var pluginName = 'horizontalChoices';

   /**
    * Horizontal Choices Widgets. Adds a filler if the last row contains two elements.
    * The filler avoids the last radiobutton or checkbox to not be lined up correctly below the second column.
    *
    * @constructor
    * @param {Element}                       element   Element to apply widget to.
    * @param {(boolean|{touch: boolean})}    options   options
    * @param {*=}                            event     event
    */

   function HorizontalChoices( element, options ) {
       // set the namespace (important!)
       this.namespace = pluginName;
       // call the Super constructor
       Widget.call( this, element, options );
       this._init();
   }

   HorizontalChoices.prototype = Object.create( Widget.prototype );

   HorizontalChoices.prototype.constructor = HorizontalChoices;

   HorizontalChoices.prototype._init = function() {
       $( this.element ).find( '.option-wrapper' ).each( function() {
           var $wrapper = $( this ),
               $options = $wrapper.find( 'label' );

           if ( ( $options.length % 3 ) === 2 ) {
               $wrapper.append( '<label class="filler"></label>' );
           }
       } );
   };


   $.fn[ pluginName ] = function( options, event ) {

       options = options || {};

       return this.each( function() {
           var $this = $( this ),
               data = $this.data( pluginName );

           //only instantiate if options is an object (i.e. not a string) and if it doesn't exist already
           if ( !data && typeof options === 'object' ) {
               $this.data( pluginName, new HorizontalChoices( this, options, event ) );
           }
           //only call method if widget was instantiated before
           else if ( data && typeof options === 'string' ) {
               //pass the element as a parameter as this is used in destroy() for cloned elements and widgets
               data[ options ]( this );
           }
       } );
   };

   module.exports = {
       'name': pluginName,
       'selector': '.or-appearance-horizontal'
   };

   },{"jquery":"jquery","../../js/Widget":"Widget"}],
   "image-map":[function(require,module,exports){
   'use strict';

   var Widget = require( '../../js/Widget' );
   var $ = require( 'jquery' );
   var pluginName = 'imageMap';

   /**
    * Image Map widget that turns an SVG image into a clickable map
    * by matching radiobutton/checkbox values with id attribute values in the SVG
    *
    * @constructor
    * @param {Element}                       element   Element to apply widget to.
    * @param {(boolean|{touch: boolean})}    options   options
    * @param {*=}                            event     event
    */
   function ImageMap( element, options, event ) {
       this.namespace = pluginName;
       Widget.call( this, element, options );
       this.options = options;
       this._init();
   }

   ImageMap.prototype = Object.create( Widget.prototype );

   ImageMap.prototype.constructor = ImageMap;

   ImageMap.prototype._init = function() {
       var that = this;
       var img = this.element.querySelector( 'img' );
       this.$inputs = $( this.element ).find( 'input' );
       this.props = this._getProps();

       /*
        * To facilitate Enketo Express' offline webforms,
        * where the img source is populated after form loading, we initialize upon image load
        * if the src attribute is not yet populated.
        *
        * We could use the same with online-only forms, but that would cause a loading delay.
        */
       if ( img.getAttribute( 'src' ) ) {
           this._addMarkup( img ).then( this._addFunctionality.bind( this ) );
       } else {
           $( img )
               .on( 'load', function() {
                   that._addMarkup( img ).then( that._addFunctionality.bind( that ) );
               } );
       }

   };

   ImageMap.prototype._addFunctionality = function( $widget ) {
       this.$svg = $widget.find( 'svg' );
       this.$tooltip = $widget.find( '.image-map__ui__tooltip' );
       if ( this.props.readonly ) {
           this.disable();
       }
       this._setSvgClickHandler();
       this._setChangeHandler();
       this._setHoverHandler();
       this._updateImage();
   };

   ImageMap.prototype._getProps = function() {
       return {
           readonly: this.$inputs[ 0 ].readOnly
       };
   };

   ImageMap.prototype._addMarkup = function( img ) {
       var that = this;
       var src = img.getAttribute( 'src' );

       /**
        * For translated forms, we now discard everything except the first image,
        * since we're assuming the images will be the same in all languages.
        */
       return $.get( src ).then( function( data ) {
           var $svg;
           var $widget;
           var width;
           var height;
           if ( that._isSvgDoc( data ) ) {
               $svg = that._removeUnmatchedIds( $( data.querySelector( 'svg' ) ) );
               $widget = $( '<div class="widget image-map"/>' )
                   .append( '<div class="image-map__ui"><span class="image-map__ui__tooltip"></span></div>' )
                   .append( $svg );
               // remove images in all languages
               $( that.element ).find( 'img' ).remove();
               $( that.element ).find( '.option-wrapper' ).before( $widget );
               // Resize, using original unscaled SVG dimensions
               // svg.getBBox() only works after SVG has been added to DOM.
               width = $svg.attr( 'width' ) || $svg[ 0 ].getBBox().width;
               height = $svg.attr( 'height' ) || $svg[ 0 ].getBBox().height;
               $svg.attr( 'viewBox', [ 0, 0, width, height ].join( ' ' ) );

               return $widget;
           }
       } );
   };

   /**
    * Removes id attributes from unmatched path elements in order to prevent hover effect (and click listener).
    *
    * @return {jQuery} [description]
    */
   ImageMap.prototype._removeUnmatchedIds = function( $svg ) {
       var that = this;
       $svg.find( 'path[id]' ).each( function() {
           if ( !that._getInput( this.id ) ) {
               this.removeAttribute( 'id' );
           }
       } );

       return $svg;
   };

   ImageMap.prototype._getInput = function( id ) {
       return this.element.querySelector( 'input[value="' + id + '"]' );
   };

   ImageMap.prototype._setSvgClickHandler = function() {
       var that = this;

       this.$svg.not( '[or-readonly]' ).on( 'click', 'path[id]', function( event ) {

           var input = that._getInput( event.target.id );
           if ( input ) {
               $( input ).prop( 'checked', !input.checked ).trigger( 'change' );
           }
       } );
   };

   ImageMap.prototype._setChangeHandler = function() {
       this.$inputs.on( 'change inputupdate.enketo', this._updateImage.bind( this ) );
   };

   ImageMap.prototype._setHoverHandler = function() {
       var that = this;

       this.$svg
           .on( 'mouseenter', 'path[id]', function( event ) {
               var optionLabel = $( that._getInput( event.target.id ) ).siblings( '.option-label.active' ).text();
               that.$tooltip.text( optionLabel );
           } )
           .on( 'mouseleave', 'path[id]', function( event ) {
               that.$tooltip.text( '' );
           } );
   };

   ImageMap.prototype._isSvgDoc = function( data ) {
       return typeof data === 'object' && data.querySelector( 'svg' );
   };

   /**
    * Updates 'selected' attributes in SVG
    * Always update the map after the value has changed in the original input elements
    */
   ImageMap.prototype._updateImage = function() {
       var that = this;
       var values = this.options.helpers.input.getVal( this.$inputs.eq( 0 ) );

       this.$svg.find( 'path[or-selected]' ).removeAttr( 'or-selected' );

       if ( typeof values === 'string' ) {
           values = [ values ];
       }

       values.forEach( function( value ) {
           if ( value ) {
               // if multiple values have the same id, change all of them (e.g. a province that is not contiguous)
               that.$svg.find( 'path#' + value ).attr( 'or-selected', '' );
           }
       } );
   };

   ImageMap.prototype.disable = function() {
       this.$svg.attr( 'or-readonly', '' );
   };

   ImageMap.prototype.enable = function() {
       if ( !this.props.readonly ) {
           this.$svg.removeAttr( 'or-readonly' );
       }
   };

   $.fn[ pluginName ] = function( options, event ) {

       options = options || {};

       return this.each( function() {
           var $this = $( this );
           var data = $this.data( pluginName );

           if ( !data && typeof options === 'object' ) {
               $this.data( pluginName, new ImageMap( this, options, event ) );
           } else if ( data && typeof options == 'string' ) {
               data[ options ]( this );
           }
       } );
   };

   module.exports = {
       'name': pluginName,
       'selector': '.simple-select.or-appearance-image-map',
       'helpersRequired': [ 'input' ]
   };

   },{"jquery":"jquery","../../js/Widget":"Widget"}],
   "notewidget":[function(require,module,exports){
   'use strict';

   var pluginName = 'notewidget';

   module.exports = {
       'name': pluginName
   };

   },{}],
   "radiopicker":[function(require,module,exports){
   'use strict';
   var Widget = require( '../../js/Widget' );
   var $ = require( 'jquery' );
   require( '../../js/plugins' );
   var pluginName = 'radiopicker';

   /**
    * Enhances radio buttons
    *
    * @constructor
    * @param {Element} element Element to apply widget to.
    * @param {(boolean|{touch: boolean})} options options
    * @param {*=} event     event
    */

   function Radiopicker( element, options ) {
       this.namespace = pluginName;
       Widget.call( this, element, options );
       this._init();
   }

   Radiopicker.prototype = Object.create( Widget.prototype );

   Radiopicker.prototype.constructor = Radiopicker;

   /**
    * Initialize
    */
   Radiopicker.prototype._init = function() {
       this._setDelegatedHandlers();
   };

   /**
    * Set delegated event handlers
    */
   Radiopicker.prototype._setDelegatedHandlers = function() {
       var $label, $input;
       var $form = $( this.element );
       // Applies a data-checked attribute to the parent label of a checked checkbox and radio button
       $form.on( 'click', 'input[type="radio"]:checked', function() {
           $( this ).parent( 'label' ).siblings().removeAttr( 'data-checked' ).end().attr( 'data-checked', 'true' );
       } );

       // Readonly buttons/checkboxes will not respond to clicks
       $form.on( 'click', 'input[type="checkbox"][readonly],input[type="radio"][readonly]', function( event ) {
           event.stopImmediatePropagation();
           return false;
       } );

       $form.on( 'click', 'input[type="checkbox"]', function() {
           $input = $( this );
           $label = $input.parent( 'label' );
           if ( $input.is( ':checked' ) ) {
               $label.attr( 'data-checked', 'true' );
           } else {
               $label.removeAttr( 'data-checked' );
           }
       } );

       // Defaults
       $form.find( 'input[type="radio"]:checked, input[type="checkbox"]:checked' ).parent( 'label' ).attr( 'data-checked', 'true' );

       // Add unselect functionality
       $form.on( 'click', '[data-checked]>input[type="radio"]:not(.no-unselect)', function() {
           $( this ).prop( 'checked', false ).trigger( 'change' ).parent().removeAttr( 'data-checked' );
       } );
   };



   $.fn[ pluginName ] = function( options, event ) {
       //this widget works globally, and only needs to be instantiated once per form
       var $this = $( this ),
           data = $this.data( pluginName );

       options = options || {};

       if ( !data && typeof options === 'object' ) {
           $this.data( pluginName, new Radiopicker( $this[ 0 ], options, event ) );
       } else if ( data && typeof options === 'string' ) {
           data[ options ]( this );
       }

       return this;
   };

   module.exports = {
       'name': pluginName,
       'selector': 'form'
   };

   },{"jquery":"jquery","../../js/Widget":"Widget","../../js/plugins":"plugins"}],
   "autocomplete":[function(require,module,exports){
   'use strict';

   var $ = require( 'jquery' );
   var Widget = require( '../../js/Widget' );
   var pluginName = 'autocomplete';
   var sadExcuseForABrowser = !( 'list' in document.createElement( 'input' ) &&
       'options' in document.createElement( 'datalist' ) &&
       typeof window.HTMLDataListElement !== 'undefined' );

   require( './jquery.relevant-dropdown' );

   /**
    *  Autocomplete select1 picker for modern browsers.
    *
    * @constructor
    * @param {Element} element [description]
    * @param {(boolean|{touch: boolean, btnStyle: string, noneSelectedText: string, maxlength:number})} options options
    * @param {*=} e     event
    */

   function Selectpicker( element, options, e ) {
       this.namespace = pluginName;
       Widget.call( this, element, options );
       if ( e ) {
           e.stopPropagation();
           e.preventDefault();
       }
       this._init();
   }

   Selectpicker.prototype = Object.create( Widget.prototype );

   Selectpicker.prototype.constructor = Selectpicker;

   Selectpicker.prototype._init = function() {
       var $input = $( this.element );
       var listId = $input.attr( 'list' );

       this.props = this._getProps();
       this.$options = $input.closest( '.question' ).find( 'datalist#' + listId + ' > option' );

       // This value -> data-value change is not slow, so no need to move to enketo-xslt as that would
       // increase itemset complexity even further.
       this.$options.each( function( index, item ) {
           var value = item.getAttribute( 'value' );
           /**
            * We're changing the original datalist here, so have to make sure we don't do anything
            * if dataset.value is already populated.
            *
            * However, for some reason !item.dataset.value is failing in Safari, which as a result sets all dataset.value attributes to "null"
            * To workaround this, we check for the value attribute instead.
            */
           if ( !item.classList.contains( 'itemset-template' ) && value !== undefined && value !== null ) {
               item.dataset.value = value;
               item.removeAttribute( 'value' );
           }
       } );

       this.$fakeInput = $( '<input type="text" class="ignore widget autocomplete" list="' + listId + '" />' );
       if ( this.props.readonly ) {
           this.$fakeInput.attr( 'readonly', 'readonly' );
       }
       if ( this.props.disabled ) {
           this.$fakeInput.attr( 'disabled', 'disabled' );
       }

       $input.hide().after( this.$fakeInput );

       if ( sadExcuseForABrowser ) {
           console.debug( 'Polyfill required' );
           this.$fakeInput.relevantDropdown();
       }

       this._setFakeInputListener();
       this._setFocusListener();
       this._showCurrentLabel(); // after setting fakeInputListener!
   };

   Selectpicker.prototype._getProps = function() {
       return {
           readonly: this.element.readOnly,
           disabled: this.element.disabled
       };
   };

   Selectpicker.prototype._showCurrentLabel = function() {
       var value = this.element.value;
       var label = this._findLabel( value );

       this.$fakeInput.val( label );

       // If a corresponding label cannot be found the value is invalid,
       // and should be cleared. For this we trigger an 'input' event.
       if ( value && !label ) {
           this.$fakeInput.trigger( 'input' );
       }
   };

   Selectpicker.prototype._setFakeInputListener = function() {
       var that = this;

       this.$fakeInput.on( 'input.' + this.namespace, function( e ) {
           var input = e.target;
           var label = input.value.trim();
           var value = that._findValue( label ) || '';

           $( that.element ).val( value ).trigger( 'change' );
           $( input ).toggleClass( 'notfound', label && !value );
       } );
   };

   Selectpicker.prototype._findValue = function( label ) {
       var value = '';

       if ( !label ) {
           return '';
       }

       this.$options.each( function( i, option ) {
           if ( option.innerText === label ) {
               value = option.getAttribute( 'data-value' );
               return false;
           }
       } );

       return value;
   };

   Selectpicker.prototype._findLabel = function( value ) {
       var label = '';

       if ( !value ) {
           return '';
       }

       this.$options.each( function( i, option ) {
           if ( option.dataset.value === value ) {
               label = option.value;
               return false;
           }
       } );
       return label;
   };

   Selectpicker.prototype._setFocusListener = function() {
       var _this = this;

       // Handle widget focus
       this.$fakeInput.on( 'focus', function() {
           $( _this.element ).trigger( 'fakefocus' );
           return true;
       } );

       // Handle original input focus
       $( this.element ).on( 'applyfocus', function() {
           $( _this.$fakeInput ).focus();
       } );
   };

   // override super method
   Selectpicker.prototype.disable = function() {
       this.$fakeInput.find( 'li' ).addClass( 'disabled' );
   };

   // override super method
   Selectpicker.prototype.enable = function() {
       this.$fakeInput.find( 'li' ).removeClass( 'disabled' );
   };

   // override super method
   Selectpicker.prototype.update = function() {
       /*
        * There are 3 scenarios for which method is called:
        * 1. The options change (dynamic itemset)
        * 2. The language changed. (just this._showCurrentLabel() would be more efficient)
        * 3. The value of the underlying original input changed due a calculation. (same as #2?)
        *
        * For now we just dumbly reinstantiate it (including the polyfill).
        */
       $( this.element ).siblings( '.widget' ).remove();
       this._init();
   };

   /**
    * Register jQuery plugin
    *
    * @param {*} option options
    * @param {*=} event       [description]
    */
   $.fn[ pluginName ] = function( options, event ) {

       options = options || {};

       return this.each( function() {

           var $this = $( this ),
               data = $this.data( pluginName );

           //only instantiate if options is an object
           if ( !data && typeof options === 'object' ) {
               $this.data( pluginName, ( data = new Selectpicker( this, options, event ) ) );
           } else if ( data && typeof options === 'string' ) {
               data[ options ]( this );
           }
       } );
   };


   module.exports = {
       'name': pluginName,
       'list': true,
       'selector': 'input[list]'
   };

   },{"jquery":"jquery","../../js/Widget":"Widget","./jquery.relevant-dropdown":"jquery.relevant-dropdown"}],
   "jquery.relevant-dropdown":[function(require,module,exports){
   // from: https://github.com/CSS-Tricks/Relevant-Dropdowns/blob/master/js/jquery.relevant-dropdown.js

   var $ = require( 'jquery' );
   var pluginName = 'relevantDropdown';

   // Make jQuery's :contains case insensitive (like HTML5 datalist)
   // Changed the name to prevent overriding original functionality
   $.expr[ ':' ].RD_contains = $.expr.createPseudo( function( arg ) {
       return function( elem ) {
           return $( elem ).text().toUpperCase().indexOf( arg.toUpperCase() ) >= 0;
       };
   } );

   function RelevantDropdown( element, options, e ) {
       this.namespace = pluginName;
       //Widget.call( this, element, options );
       this.element = element;
       this.options = $.extend( {
           fadeOutSpeed: 'normal', // speed to fade out the dataList Popup
           change: null
       }, options );
       if ( e ) {
           e.stopPropagation();
           e.preventDefault();
       }
       this._init();
   }

   RelevantDropdown.prototype._init = function() {
       var $input = $( this.element );
       this.listId = $input.attr( 'list' );

       // Insert home for new fake datalist
       this.$fakeDatalist = $( '<ul />', {
           'class': 'datalist widget',
           'id': this.listId
       } ).appendTo( $input.parent() );

       this._updateFakeDatalist();
       this._setEventListeners();
   };

   RelevantDropdown.prototype._updateFakeDatalist = function() {
       //console.log( 'changing options' );
       var $datalist = $( '#' + this.listId );
       // Used to prevent reflow
       var tempItems = document.createDocumentFragment();
       var tempitem = null;

       this.$fakeDatalist.empty();

       // Fill empty fake datalist
       $datalist.find( 'option' ).each( function() {
           tempItem = $( '<li />', {
               // .val is required here, not .text or .html
               // HTML *needs* to be <option value='xxx'> not <option>xxx</option>  (IE)
               'text': $( this ).val()
           } )[ 0 ];
           tempItems.appendChild( tempItem );
       } );
       this.$fakeDatalist.append( tempItems );

       // Update pointer
       this.$fakeDatalistItems = this.$fakeDatalist.find( 'li' );

       // console.debug( 'new items', this.$fakeDatalistItems.get() );
   };

   RelevantDropdown.prototype._setEventListeners = function() {
       var that = this;
       var $input = $( this.element );

       var searchPosition;
       var scrollValue = 0;
       // Typey type type
       $input
           .on( 'focus', function() {
               //console.debug( 'focus', this );
               // Reset scroll
               that.$fakeDatalist.scrollTop( 0 );
               scrollValue = 0;
           } )
           .on( 'blur', function() {
               //console.debug( 'blur', this );
               // If this fires immediately, it prevents click-to-select from working
               setTimeout( function() {
                   that.$fakeDatalist.fadeOut( that.options.fadeOutSpeed );
                   that.$fakeDatalistItems.removeClass( 'active' );
               }, 500 );
           } )
           .on( 'keyup', function( e ) {
               searchPosition = $input.position();
               //console.log( 'keyup or focus', searchPosition );
               // Build datalist
               that.$fakeDatalist
                   .show()
                   .css( {
                       top: searchPosition.top + $( this ).outerHeight(),
                       left: searchPosition.left,
                       width: $input.outerWidth()
                   } );

               that.$fakeDatalistItems.hide();
               // console.log( 'finding items containing', $input.val() ) );
               that.$fakeDatalist.find( 'li:RD_contains("' + $input.val() + '")' ).show();
           } );

       // Don't want to use :hover in CSS so doing this instead
       // really helps with arrow key navigation
       this.$fakeDatalist
           .on( 'mouseenter', 'li', function() {
               // console.debug( 'mouseenter', this );
               $( this ).addClass( 'active' ).siblings().removeClass( 'active' );
           } )
           .on( 'mouseleave', 'li', function() {
               // console.debug( 'mouseleave', this );
               $( this ).removeClass( 'active' );
           } );

       // Window resize
       $( window ).resize( function() {
           // console.debug( 'resize' );
           searchPosition = $input.position();
           that.$fakeDatalist
               .css( {
                   top: searchPosition.top + $( this ).outerHeight(),
                   left: searchPosition.left,
                   width: $input.outerWidth()
               } );
       } );

       // Watch arrow keys for up and down
       $input.on( 'keydown', function( e ) {
           // console.debug( 'keydown' );
           var active = that.$fakeDatalist.find( 'li.active' );
           var datalistHeight = that.$fakeDatalist.outerHeight();
           var datalistItemsHeight = that.$fakeDatalistItems.outerHeight();

           // up arrow
           if ( e.keyCode == 38 ) {
               if ( active.length ) {
                   prevAll = active.prevAll( 'li:visible' );
                   if ( prevAll.length > 0 ) {
                       active.removeClass( 'active' );
                       prevAll.eq( 0 ).addClass( 'active' );
                   }

                   if ( prevAll.length && prevAll.position().top < 0 && scrollValue > 0 ) {
                       that.$fakeDatalist.scrollTop( scrollValue -= datalistItemsHeight );
                   }
               }
           }

           // down arrow
           if ( e.keyCode == 40 ) {
               if ( active.length ) {
                   var nextAll = active.nextAll( 'li:visible' );
                   if ( nextAll.length > 0 ) {
                       active.removeClass( 'active' );
                       nextAll.eq( 0 ).addClass( 'active' );
                   }

                   if ( nextAll.length && ( nextAll.position().top + datalistItemsHeight ) >= datalistHeight ) {
                       that.$fakeDatalist.stop().animate( {
                           scrollTop: scrollValue += datalistItemsHeight
                       }, 200 );
                   }
               } else {
                   that.$fakeDatalistItems.removeClass( 'active' );
                   that.$fakeDatalist.find( 'li:visible:first' ).addClass( 'active' );
               }
           }

           // return or tab key
           if ( e.keyCode == 13 || e.keyCode == 9 ) {
               if ( active.length ) {
                   $input.val( active.text() ).trigger( 'input' );
               }
               that.$fakeDatalist.fadeOut( that.options.fadeOutSpeed );
               that.$fakeDatalistItems.removeClass( 'active' );
           }

           // keys
           if ( e.keyCode != 13 && e.keyCode != 38 && e.keyCode != 40 ) {
               // Reset active class
               that.$fakeDatalistItems.removeClass( 'active' );
               that.$fakeDatalist.find( 'li:visible:first' ).addClass( 'active' );

               // Reset scroll
               that.$fakeDatalist.scrollTop( 0 );
               scrollValue = 0;
           }

       } );

       // When choosing from dropdown
       this.$fakeDatalist.on( 'click', 'li', function() {
           // console.debug( 'click', this );
           var active = $( 'li.active' );
           if ( active.length ) {
               $input.val( $( this ).text() ).trigger( 'input' );
           }
           that.$fakeDatalist.fadeOut( that.options.fadeOutSpeed );
           that.$fakeDatalistItems.removeClass( 'active' );
       } );

   };

   RelevantDropdown.prototype.update = function() {
       this._updateFakeDatalist();
   };

   $.fn[ pluginName ] = function( options, event ) {

       options = options || {};

       return this.each( function() {
           var $this = $( this );
           var data = $this.data( pluginName );

           //only instantiate if options is an object
           if ( !data && typeof options === 'object' ) {
               $this.data( pluginName, ( data = new RelevantDropdown( this, options, event ) ) );
           } else if ( data && typeof options === 'string' ) {
               data[ options ]( this );
           }
       } );
   };

   },{"jquery":"jquery"}],
   "desktopselectpicker":[function(require,module,exports){
   'use strict';
   /**
    * This widget is one gigantic mess. It should be replaced entirely.
    */

   /**
    * Copyright 2012 Silvio Moreto, Martijn van de Rijdt & Modilabs
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */

   var $ = require( 'jquery' );
   var Widget = require( '../../js/Widget' );
   var t = require( 'translator' ).t;
   var pluginName = 'desktopSelectpicker';
   require( '../../js/dropdown.jquery' );

   /**
    * Bootstrap Select picker that supports single and multiple selects
    * A port of https://github.com/silviomoreto/bootstrap-select
    *
    * @constructor
    * @param {Element} element [description]
    * @param {(boolean|{touch: boolean, btnStyle: string, noneSelectedText: string, maxlength:number})} options options
    * @param {*=} e     event
    */

   function DesktopSelectpicker( element, options, e ) {
       this.namespace = pluginName;
       Widget.call( this, element, options );
       if ( e ) {
           e.stopPropagation();
           e.preventDefault();
       }

       this.$picker = null;
       this.noneSelectedText = t( 'selectpicker.noneselected' );

       this.multiple = ( typeof $( element ).attr( 'multiple' ) !== 'undefined' && $( element ).attr( 'multiple' ) !== false );
       this._init();
   }

   DesktopSelectpicker.prototype = Object.create( Widget.prototype );

   DesktopSelectpicker.prototype.constructor = DesktopSelectpicker;

   DesktopSelectpicker.prototype._init = function() {
       var $template = this._getTemplate();
       var $select = $( this.element );
       // beware readonly is not a property on a <select>!
       this.readonly = !!$select.attr( 'readonly' );
       $select.css( 'display', 'none' );
       $template = this._createLi( $template );
       this.$picker = $template.insertAfter( $select );
       this.$picker.find( '> a' ).addClass( this.selectClass );
       this._clickListener();
       this._focusListener();
   };

   DesktopSelectpicker.prototype._getTemplate = function() {
       var template =
           '<div class="btn-group bootstrap-select widget clearfix">' +
           '<button type="button" class="btn btn-default dropdown-toggle clearfix" data-toggle="dropdown">' +
           '<span class="selected">__SELECTED_OPTIONS</span><span class="caret"></span>' +
           '</button>' +
           '<ul class="dropdown-menu" role="menu">' +
           '__ADD_LI' +
           '</ul>' +
           '</div>';

       return template;
   };

   DesktopSelectpicker.prototype._createLi = function( template ) {
       var li = [];
       var liHtml = '';
       var inputAttr = ( this.multiple ) ? 'type="checkbox"' : 'type="radio" name="' + Math.random() * 100000 + '"';
       var _this = this;
       var readonlyAttr = ( this.readonly ) ? ' readonly="readonly"' : '';
       var disabledAttr = ( this.readonly ) ? ' disabled="disabled"' : '';
       var disabledClass = ( this.readonly ) ? ' class="disabled"' : '';
       var checkedInputAttr;
       var checkedLiAttr;

       $( this.element ).find( 'option' ).each( function() {
           li.push( {
               label: $( this ).text(),
               selected: $( this ).is( ':selected' ),
               value: $( this ).attr( 'value' )
           } );
       } );

       if ( li.length > 0 ) {
           template = template.replace( '__SELECTED_OPTIONS', this._createSelectedStr() );
           for ( var i = 0; i < li.length; i++ ) {
               if ( li[ i ].value ) {
                   checkedInputAttr = ( li[ i ].selected ) ? ' checked="checked"' : '';
                   checkedLiAttr = ( li[ i ].selected && !_this.multiple ) ? 'class="active"' : '';
                   /**
                    * e.g.:
                    * <li checked="checked">
                    *   <a class="option-wrapper" tabindex="-1" href="#">
                    *         <label>
                    *           <input class="ignore" type="checkbox" checked="checked" value="a"/>
                    *         </label>
                    *       </a>
                    *    </li>
                    */
                   liHtml +=
                       '<li ' + disabledClass + checkedLiAttr + '>' +
                       '<a class="option-wrapper" tabindex="-1" href="#">' +
                       '<label>' +
                       '<input class="ignore" ' + inputAttr + checkedInputAttr + readonlyAttr + disabledAttr + ' value="' + li[ i ].value + '" />' +
                       '<span class="option-label">' + li[ i ].label + '</span></label>' +
                       '</a>' +
                       '</li>';
               }
           }
       }

       template = template.replace( '__ADD_LI', liHtml );

       return $( template );
   };


   /**
    * create text to show in closed picker
    * @param  {jQuery=} $select  jQuery-wrapped select element
    * @return {string}
    */
   DesktopSelectpicker.prototype._createSelectedStr = function() {
       var selectedLabels = [];
       var $select = $( this.element );
       $select.find( 'option:selected' ).each( function() {
           if ( $( this ).attr( 'value' ).length > 0 ) {
               selectedLabels.push( $( this ).text() );
           }
       } );

       if ( selectedLabels.length === 0 ) {
           return this.noneSelectedText;
       } else if ( selectedLabels.length === 1 ) {
           return selectedLabels[ 0 ];
       } else {
           return t( 'selectpicker.numberselected', {
               number: selectedLabels.length
           } );
       }
   };

   DesktopSelectpicker.prototype._clickListener = function() {
       var _this = this;

       this.$picker
           .on( 'click', 'li:not(.disabled)', function( e ) {
               var $li = $( this );
               var $input = $li.find( 'input' );
               var $select = $( _this.element );
               var $option = $select.find( 'option[value="' + $input.val() + '"]' );
               var selectedBefore = $option.is( ':selected' );

               // We need to prevent default unless click was on on input
               // Without this 'fix', clicks on radiobuttons/checkboxes themselves will update the value
               // but will not show checked status.
               if ( e.target.nodeName.toLowerCase() !== 'input' ) {
                   e.preventDefault();
               }

               if ( !_this.multiple ) {
                   _this.$picker.find( 'li' ).removeClass( 'active' );
                   $option.siblings( 'option' ).prop( 'selected', false );
                   _this.$picker.find( 'input' ).prop( 'checked', false );
               } else {
                   //don't close dropdown for multiple select
                   e.stopPropagation();
               }

               if ( selectedBefore ) {
                   $li.removeClass( 'active' );
                   $input.prop( 'checked', false );
                   $option.prop( 'selected', false );
               } else {
                   if ( !_this.multiple ) {
                       $li.addClass( 'active' );
                   }
                   $input.prop( 'checked', true );
                   $option.prop( 'selected', true );
               }

               _this.$picker.find( '.selected' ).html( _this._createSelectedStr() );

               $select.trigger( 'change' );
           } )
           // Enter/Space keys
           .on( 'keydown', 'li:not(.disabled)', function( e ) {
               if ( /(13|32)/.test( e.keyCode.toString( 10 ) ) ) {
                   if ( !/(32)/.test( e.keyCode.toString( 10 ) ) ) {
                       e.preventDefault();
                   }
                   var elem = $( ':focus' );
                   elem.click();
                   // Bring back focus for multiselects
                   elem.focus();
                   // Prevent screen from scrolling if the user hit the spacebar
                   e.preventDefault();
               }
           } )
           .on( 'click', 'li.disabled', function( e ) {
               e.stopPropagation();
               return false;
           } );
   };

   DesktopSelectpicker.prototype._focusListener = function() {
       var _this = this;

       // Focus on original element (form.goTo functionality)
       $( this.element ).on( 'applyfocus', function() {
           _this.$picker.find( '.dropdown-toggle' ).focus();
       } );

       // focus on widget
       this.$picker.on( 'shown.bs.dropdown', function() {
           $( _this.element ).trigger( 'fakefocus' );
           return true;
       } );
   };

   //override super method
   DesktopSelectpicker.prototype.disable = function() {
       this.$picker.find( 'li' ).addClass( 'disabled' );
   };

   //override super method
   DesktopSelectpicker.prototype.enable = function() {
       this.$picker.find( 'li' ).removeClass( 'disabled' );
   };

   //override super method
   DesktopSelectpicker.prototype.update = function() {
       this.$picker.remove();
       this._init();
   };

   /**
    * [selectpicker description]
    * @param {({btnStyle: string, noneSelectedText: string}|string)=} option options
    * @param {*=} event       [description]
    */
   $.fn[ pluginName ] = function( options, event ) {

       options = options || {};

       return this.each( function() {

           var $this = $( this ),
               data = $this.data( pluginName );

           //only instantiate if options is an object AND if options.touch is falsy
           if ( !data && typeof options === 'object' && !options.touch ) {
               $this.data( pluginName, ( data = new DesktopSelectpicker( this, options, event ) ) );
           } else if ( data && typeof options === 'string' ) {
               data[ options ]( this );
           }
       } );
   };


   module.exports = {
       'name': pluginName,
       'list': true,
       'selector': 'select:not(#form-languages)'
   };

   },{"jquery":"jquery","../../js/Widget":"Widget","translator":"fake-translator","../../js/dropdown.jquery":"dropdown.jquery"}],
   "likertitem":[function(require,module,exports){
   'use strict';

   module.exports = {
       'name': 'likertitem'
   };

   },{}],
   "mobileselectpicker":[function(require,module,exports){
   'use strict';

   var $ = require( 'jquery' );
   var Widget = require( '../../js/Widget' );
   var pluginName = 'mobileSelectpicker';

   /**
    * An enhancement for the native multi-selectpicker found on most mobile devices,
    * that shows the selected values next to the select box
    *
    * @constructor
    * @param {Element} element Element to apply widget to.
    * @param {(boolean|{touch: boolean})} options options
    * @param {*=} e     event
    */

   function MobileSelectpicker( element, options, e ) {
       this.namespace = pluginName;
       Widget.call( this, element, options );
       this._init();
   }

   //copy the prototype functions from the Widget super class
   MobileSelectpicker.prototype = Object.create( Widget.prototype );

   //ensure the constructor is the new one
   MobileSelectpicker.prototype.constructor = MobileSelectpicker;

   /**
    * initialize
    */
   MobileSelectpicker.prototype._init = function() {
       var that = this;

       //show values on change
       $( this.element ).on( 'change.' + pluginName, function() {
           that._showSelectedValues();
           return true;
       } );

       //show defaults
       this._showSelectedValues();
   };

   /**
    * display the selected values
    */
   MobileSelectpicker.prototype._showSelectedValues = function() {
       var i;
       var valueText = [];
       var template = '<span class="widget mobileselect"></span>';
       var $select = $( this.element );
       var $widget = ( $select.next( '.widget' ).length > 0 ) ? $select.next( '.widget' ) : $( template ).insertAfter( $select );
       var values = ( $.isArray( $select.val() ) ) ? $select.val() : [ $select.val() ];

       for ( i = 0; i < values.length; i++ ) {
           valueText.push( $( this ).find( 'option[value="' + values[ i ] + '"]' ).text() );
       }

       $widget.text( values.join( ', ' ) );
   };

   MobileSelectpicker.prototype.update = function() {
       this._showSelectedValues();
   };

   $.fn[ pluginName ] = function( options, event ) {

       options = options || {};

       return this.each( function() {
           var $this = $( this ),
               data = $this.data( pluginName );

           //only instantiate if options is an object AND if options.touch is truthy
           if ( !data && typeof options === 'object' && options.touch ) {
               $this.data( pluginName, new MobileSelectpicker( this, options, event ) );
           }
           if ( data && typeof options === 'string' ) {
               data[ options ]( this );
           }
       } );
   };

   module.exports = {
       'name': pluginName,
       'selector': 'select[multiple]'
   };

   },{"jquery":"jquery","../../js/Widget":"Widget"}],
   "tablewidget":[function(require,module,exports){
   'use strict';

   module.exports = {
       'name': 'tablewidget'
   };

   },{}],
   "textarea":[function(require,module,exports){
   'use strict';

   var Widget = require( '../../js/Widget' );
   var $ = require( 'jquery' );
   var pluginName = 'textareaWidget';

   /**
    * Auto-resizes textarea elements.
    *
    * @constructor
    * @param {Element} element Element to apply widget to.
    * @param {(boolean|{touch: boolean})} options options
    * @param {*=} event     event
    */

   function TextareaWidget( element, options ) {
       this.namespace = pluginName;
       Widget.call( this, element, options );
       this._init();
   }

   TextareaWidget.prototype = Object.create( Widget.prototype );

   TextareaWidget.prototype.constructor = TextareaWidget;

   /**
    * Initialize
    */
   TextareaWidget.prototype._init = function() {
       this._setDelegatedHandlers();
   };

   /**
    * Set delegated event handlers
    */
   TextareaWidget.prototype._setDelegatedHandlers = function() {
       var $form = $( this.element );
       var textarea = $form[ 0 ].querySelector( 'textarea' );
       var defaultHeight = textarea ? textarea.clientHeight : 20;
       $form.on( 'input', 'textarea', function( event ) {
           if ( this.scrollHeight > this.clientHeight && this.scrollHeight > defaultHeight ) {
               // setting min-height instead of height, as height doesn't work in Grid Theme.
               this.style[ 'min-height' ] = this.scrollHeight + 'px';
           }
       } );

   };

   $.fn[ pluginName ] = function( options, event ) {
       //this widget works globally, and only needs to be instantiated once per form
       var $this = $( this );
       var data = $this.data( pluginName );

       options = options || {};

       if ( !data && typeof options === 'object' ) {
           $this.data( pluginName, new TextareaWidget( $this[ 0 ], options, event ) );
       } else if ( data && typeof options === 'string' ) {
           data[ options ]( this );
       }

       return this;
   };

   module.exports = {
       'name': pluginName,
       'selector': 'form'
   };

   },{"jquery":"jquery","../../js/Widget":"Widget"}],
   "timepicker":[function(require,module,exports){
   /*!
    * Timepicker
    *
    * Forked from https://github.com/jdewit/bootstrap-timepicker:
    *
    * Copyright 2013 Joris de Wit and timepicker contributors
    *
    * Contributors https://github.com/jdewit/bootstrap-timepicker/graphs/contributors
    * Contributors https://github.com/enketo/timepicker-basic/graphs/contributors
    *
    * For the full copyright and license information, please view the LICENSE
    * file that was distributed with this source code.
    */
   ( function( $, window, document ) {
       'use strict';

       // TIMEPICKER PUBLIC CLASS DEFINITION
       var Timepicker = function( element, options ) {
           this.widget = '';
           this.$element = $( element );
           this.defaultTime = options.defaultTime;
           this.disableFocus = options.disableFocus;
           this.disableMousewheel = options.disableMousewheel;
           this.isOpen = options.isOpen;
           this.minuteStep = options.minuteStep;
           this.orientation = options.orientation;
           this.secondStep = options.secondStep;
           this.snapToStep = options.snapToStep;
           this.showInputs = options.showInputs;
           this.showMeridian = options.showMeridian;
           this.showSeconds = options.showSeconds;
           this.template = options.template;
           this.appendWidgetTo = options.appendWidgetTo;
           this.showWidgetOnAddonClick = options.showWidgetOnAddonClick;
           this.icons = options.icons;
           this.maxHours = options.maxHours;
           this.explicitMode = options.explicitMode; // If true 123 = 1:23, 12345 = 1:23:45, else invalid.

           this.handleDocumentClick = function( e ) {
               var self = e.data.scope;
               // This condition was inspired by datepicker.
               // The element the timepicker is invoked on is the input but it has a sibling for addon/button.
               if ( !( self.$element.parent().find( e.target ).length ||
                       self.$widget.is( e.target ) ||
                       self.$widget.find( e.target ).length ) ) {
                   self.hideWidget();
               }
           };

           this._init();
       };

       Timepicker.prototype = {

           constructor: Timepicker,
           _init: function() {
               var self = this;

               if ( this.showWidgetOnAddonClick && ( this.$element.parent().hasClass( 'input-group' ) && this.$element.parent().hasClass( 'timepicker' ) ) ) {
                   this.$element.parent( '.input-group.timepicker' ).find( '.input-group-addon' ).on( {
                       'click.timepicker': $.proxy( this.showWidget, this )
                   } );
                   this.$element.on( {
                       'focus.timepicker': $.proxy( this.highlightUnit, this ),
                       'click.timepicker': $.proxy( this.highlightUnit, this ),
                       'keydown.timepicker': $.proxy( this.elementKeydown, this ),
                       'blur.timepicker': $.proxy( this.blurElement, this ),
                       'mousewheel.timepicker DOMMouseScroll.timepicker': $.proxy( this.mousewheel, this )
                   } );
               } else {
                   if ( this.template ) {
                       this.$element.on( {
                           'focus.timepicker': $.proxy( this.showWidget, this ),
                           'click.timepicker': $.proxy( this.showWidget, this ),
                           'blur.timepicker': $.proxy( this.blurElement, this ),
                           'mousewheel.timepicker DOMMouseScroll.timepicker': $.proxy( this.mousewheel, this )
                       } );
                   } else {
                       this.$element.on( {
                           'focus.timepicker': $.proxy( this.highlightUnit, this ),
                           'click.timepicker': $.proxy( this.highlightUnit, this ),
                           'keydown.timepicker': $.proxy( this.elementKeydown, this ),
                           'blur.timepicker': $.proxy( this.blurElement, this ),
                           'mousewheel.timepicker DOMMouseScroll.timepicker': $.proxy( this.mousewheel, this )
                       } );
                   }
               }

               if ( this.template !== false ) {
                   this.$widget = $( this.getTemplate() ).on( 'click', $.proxy( this.widgetClick, this ) );
               } else {
                   this.$widget = false;
               }

               if ( this.showInputs && this.$widget !== false ) {
                   this.$widget.find( 'input' ).each( function() {
                       $( this ).on( {
                           'click.timepicker': function() {
                               $( this ).select();
                           },
                           'keydown.timepicker': $.proxy( self.widgetKeydown, self ),
                           'keyup.timepicker': $.proxy( self.widgetKeyup, self )
                       } );
                   } );
               }

               this.setDefaultTime( this.defaultTime );
           },

           blurElement: function() {
               this.highlightedUnit = null;
               this.updateFromElementVal();
           },

           clear: function() {
               this.hour = '';
               this.minute = '';
               this.second = '';
               this.meridian = '';

               this.$element.val( '' );
           },

           decrementHour: function() {
               // If value is empty, make sure that first shown value is current hour.
               if ( this.hour === '' ) {
                   this.hour = this.getCurrentHour();
                   this.incrementHour();
               }

               if ( this.showMeridian ) {
                   if ( this.hour === 1 ) {
                       this.hour = 12;
                   } else if ( this.hour === 12 ) {
                       this.hour--;

                       return this.toggleMeridian();
                   } else if ( this.hour === 0 ) {
                       this.hour = 11;

                       return this.toggleMeridian();
                   } else {
                       this.hour--;
                   }
               } else {
                   if ( this.hour <= 0 ) {
                       this.hour = this.maxHours - 1;
                   } else {
                       this.hour--;
                   }
               }
           },

           decrementMinute: function( step ) {
               var newVal;

               // If value is empty, make sure that first shown value is current minutes.
               if ( this.minute === '' ) {
                   this.minute = this.getCurrentMinute();
                   this.incrementMinute();
               }

               if ( step ) {
                   newVal = this.minute - step;
               } else {
                   newVal = this.minute - this.minuteStep;
               }

               if ( newVal < 0 ) {
                   this.decrementHour();
                   this.minute = newVal + 60;
               } else {
                   this.minute = newVal;
               }
           },

           decrementSecond: function() {
               var newVal = this.second - this.secondStep;

               if ( newVal < 0 ) {
                   this.decrementMinute( true );
                   this.second = newVal + 60;
               } else {
                   this.second = newVal;
               }
           },

           elementKeydown: function( e ) {
               switch ( e.which ) {
                   case 9: //tab
                       if ( e.shiftKey ) {
                           if ( this.highlightedUnit === 'hour' ) {
                               this.hideWidget();
                               break;
                           }
                           this.highlightPrevUnit();
                       } else if ( ( this.showMeridian && this.highlightedUnit === 'meridian' ) || ( this.showSeconds && this.highlightedUnit === 'second' ) || ( !this.showMeridian && !this.showSeconds && this.highlightedUnit === 'minute' ) ) {
                           this.hideWidget();
                           break;
                       } else {
                           this.highlightNextUnit();
                       }
                       e.preventDefault();
                       this.updateFromElementVal();
                       break;
                   case 27: // escape
                       this.updateFromElementVal();
                       break;
                   case 37: // left arrow
                       e.preventDefault();
                       this.highlightPrevUnit();
                       this.updateFromElementVal();
                       break;
                   case 38: // up arrow
                       e.preventDefault();
                       switch ( this.highlightedUnit ) {
                           case 'hour':
                               this.incrementHour();
                               this.highlightHour();
                               break;
                           case 'minute':
                               this.incrementMinute();
                               this.highlightMinute();
                               break;
                           case 'second':
                               this.incrementSecond();
                               this.highlightSecond();
                               break;
                           case 'meridian':
                               this.toggleMeridian();
                               this.highlightMeridian();
                               break;
                       }
                       this.update();
                       break;
                   case 39: // right arrow
                       e.preventDefault();
                       this.highlightNextUnit();
                       this.updateFromElementVal();
                       break;
                   case 40: // down arrow
                       e.preventDefault();
                       switch ( this.highlightedUnit ) {
                           case 'hour':
                               this.decrementHour();
                               this.highlightHour();
                               break;
                           case 'minute':
                               this.decrementMinute();
                               this.highlightMinute();
                               break;
                           case 'second':
                               this.decrementSecond();
                               this.highlightSecond();
                               break;
                           case 'meridian':
                               this.toggleMeridian();
                               this.highlightMeridian();
                               break;
                       }

                       this.update();
                       break;
               }
           },

           getCursorPosition: function() {
               var input = this.$element.get( 0 );

               if ( 'selectionStart' in input ) { // Standard-compliant browsers

                   return input.selectionStart;
               } else if ( document.selection ) { // IE fix
                   input.focus();
                   var sel = document.selection.createRange(),
                       selLen = document.selection.createRange().text.length;

                   sel.moveStart( 'character', -input.value.length );

                   return sel.text.length - selLen;
               }
           },

           getTemplate: function() {
               var template,
                   hourTemplate,
                   minuteTemplate,
                   secondTemplate,
                   meridianTemplate,
                   templateContent;

               if ( this.showInputs ) {
                   hourTemplate = '<input type="text" class="timepicker-hour" maxlength="2"/>';
                   minuteTemplate = '<input type="text" class="timepicker-minute" maxlength="2"/>';
                   secondTemplate = '<input type="text" class="timepicker-second" maxlength="2"/>';
                   meridianTemplate = '<input type="text" class="timepicker-meridian" maxlength="2"/>';
               } else {
                   hourTemplate = '<span class="timepicker-hour"></span>';
                   minuteTemplate = '<span class="timepicker-minute"></span>';
                   secondTemplate = '<span class="timepicker-second"></span>';
                   meridianTemplate = '<span class="timepicker-meridian"></span>';
               }

               templateContent = '<table>' +
                   '<tr>' +
                   '<td><a href="#" data-action="incrementHour"><span class="' + this.icons.up + '"></span></a></td>' +
                   '<td class="separator">&nbsp;</td>' +
                   '<td><a href="#" data-action="incrementMinute"><span class="' + this.icons.up + '"></span></a></td>' +
                   ( this.showSeconds ?
                       '<td class="separator">&nbsp;</td>' +
                       '<td><a href="#" data-action="incrementSecond"><span class="' + this.icons.up + '"></span></a></td>' : '' ) +
                   ( this.showMeridian ?
                       '<td class="separator">&nbsp;</td>' +
                       '<td class="meridian-column"><a href="#" data-action="toggleMeridian"><span class="' + this.icons.up + '"></span></a></td>' : '' ) +
                   '</tr>' +
                   '<tr>' +
                   '<td>' + hourTemplate + '</td> ' +
                   '<td class="separator">:</td>' +
                   '<td>' + minuteTemplate + '</td> ' +
                   ( this.showSeconds ?
                       '<td class="separator">:</td>' +
                       '<td>' + secondTemplate + '</td>' : '' ) +
                   ( this.showMeridian ?
                       '<td class="separator">&nbsp;</td>' +
                       '<td>' + meridianTemplate + '</td>' : '' ) +
                   '</tr>' +
                   '<tr>' +
                   '<td><a href="#" data-action="decrementHour"><span class="' + this.icons.down + '"></span></a></td>' +
                   '<td class="separator"></td>' +
                   '<td><a href="#" data-action="decrementMinute"><span class="' + this.icons.down + '"></span></a></td>' +
                   ( this.showSeconds ?
                       '<td class="separator">&nbsp;</td>' +
                       '<td><a href="#" data-action="decrementSecond"><span class="' + this.icons.down + '"></span></a></td>' : '' ) +
                   ( this.showMeridian ?
                       '<td class="separator">&nbsp;</td>' +
                       '<td><a href="#" data-action="toggleMeridian"><span class="' + this.icons.down + '"></span></a></td>' : '' ) +
                   '</tr>' +
                   '</table>';

               switch ( this.template ) {
                   case 'dropdown':
                       template = '<div class="timepicker-widget dropdown-menu">' + templateContent + '</div>';
                       break;
               }

               return template;
           },

           getTime: function() {
               if ( this.hour === '' ) {
                   return '';
               }
               //return this.hour +                                                           ':' + ( this.minute.toString().length === 1 ? '0' + this.minute : this.minute ) + ( this.showSeconds ? ':' + ( this.second.toString().length === 1 ? '0' + this.second : this.second ) : '' ) + ( this.showMeridian ? ' ' + this.meridian : '' );
               return ( this.hour.toString().length === 1 ? '0' + this.hour : this.hour ) + ':' + ( this.minute.toString().length === 1 ? '0' + this.minute : this.minute ) + ( this.showSeconds ? ':' + ( this.second.toString().length === 1 ? '0' + this.second : this.second ) : '' ) + ( this.showMeridian ? ' ' + this.meridian : '' );
           },

           hideWidget: function() {
               if ( this.isOpen === false ) {
                   return;
               }

               this.$element.trigger( {
                   'type': 'hide.timepicker',
                   'time': {
                       'value': this.getTime(),
                       'hours': this.hour,
                       'minutes': this.minute,
                       'seconds': this.second,
                       'meridian': this.meridian
                   }
               } );

               this.$widget.removeClass( 'open' );

               $( document ).off( 'mousedown.timepicker, touchend.timepicker', this.handleDocumentClick );

               this.isOpen = false;
               // show/hide approach taken by datepicker
               this.$widget.detach();
           },

           highlightUnit: function() {
               this.position = this.getCursorPosition();
               if ( this.position >= 0 && this.position <= 2 ) {
                   this.highlightHour();
               } else if ( this.position >= 3 && this.position <= 5 ) {
                   this.highlightMinute();
               } else if ( this.position >= 6 && this.position <= 8 ) {
                   if ( this.showSeconds ) {
                       this.highlightSecond();
                   } else {
                       this.highlightMeridian();
                   }
               } else if ( this.position >= 9 && this.position <= 11 ) {
                   this.highlightMeridian();
               }
           },

           highlightNextUnit: function() {
               switch ( this.highlightedUnit ) {
                   case 'hour':
                       this.highlightMinute();
                       break;
                   case 'minute':
                       if ( this.showSeconds ) {
                           this.highlightSecond();
                       } else if ( this.showMeridian ) {
                           this.highlightMeridian();
                       } else {
                           this.highlightHour();
                       }
                       break;
                   case 'second':
                       if ( this.showMeridian ) {
                           this.highlightMeridian();
                       } else {
                           this.highlightHour();
                       }
                       break;
                   case 'meridian':
                       this.highlightHour();
                       break;
               }
           },

           highlightPrevUnit: function() {
               switch ( this.highlightedUnit ) {
                   case 'hour':
                       if ( this.showMeridian ) {
                           this.highlightMeridian();
                       } else if ( this.showSeconds ) {
                           this.highlightSecond();
                       } else {
                           this.highlightMinute();
                       }
                       break;
                   case 'minute':
                       this.highlightHour();
                       break;
                   case 'second':
                       this.highlightMinute();
                       break;
                   case 'meridian':
                       if ( this.showSeconds ) {
                           this.highlightSecond();
                       } else {
                           this.highlightMinute();
                       }
                       break;
               }
           },

           highlightHour: function() {
               var $element = this.$element.get( 0 ),
                   self = this;

               this.highlightedUnit = 'hour';

               if ( $element.setSelectionRange ) {
                   setTimeout( function() {
                       if ( self.hour < 10 ) {
                           $element.setSelectionRange( 0, 1 );
                       } else {
                           $element.setSelectionRange( 0, 2 );
                       }
                   }, 0 );
               }
           },

           highlightMinute: function() {
               var $element = this.$element.get( 0 ),
                   self = this;

               this.highlightedUnit = 'minute';

               if ( $element.setSelectionRange ) {
                   setTimeout( function() {
                       if ( self.hour < 10 ) {
                           $element.setSelectionRange( 2, 4 );
                       } else {
                           $element.setSelectionRange( 3, 5 );
                       }
                   }, 0 );
               }
           },

           highlightSecond: function() {
               var $element = this.$element.get( 0 ),
                   self = this;

               this.highlightedUnit = 'second';

               if ( $element.setSelectionRange ) {
                   setTimeout( function() {
                       if ( self.hour < 10 ) {
                           $element.setSelectionRange( 5, 7 );
                       } else {
                           $element.setSelectionRange( 6, 8 );
                       }
                   }, 0 );
               }
           },

           highlightMeridian: function() {
               var $element = this.$element.get( 0 ),
                   self = this;

               this.highlightedUnit = 'meridian';

               if ( $element.setSelectionRange ) {
                   if ( this.showSeconds ) {
                       setTimeout( function() {
                           if ( self.hour < 10 ) {
                               $element.setSelectionRange( 8, 10 );
                           } else {
                               $element.setSelectionRange( 9, 11 );
                           }
                       }, 0 );
                   } else {
                       setTimeout( function() {
                           if ( self.hour < 10 ) {
                               $element.setSelectionRange( 5, 7 );
                           } else {
                               $element.setSelectionRange( 6, 8 );
                           }
                       }, 0 );
                   }
               }
           },

           getCurrentHour: function() {
               var h24 = new Date().getHours();
               return ( this.showMeridian ) ? h24 % 12 : h24;
           },

           getCurrentMinute: function() {
               return new Date().getMinutes();
           },

           incrementHour: function() {
               // If value is empty, make sure that first shown value is current hour.
               if ( this.hour === '' ) {
                   this.hour = this.getCurrentHour();
                   this.decrementHour();
               }

               // if this.hour is empty string
               if ( this.showMeridian ) {
                   if ( this.hour === 11 ) {
                       this.hour++;
                       return this.toggleMeridian();
                   } else if ( this.hour === 12 ) {
                       this.hour = 0;
                   }
               }
               if ( this.hour === this.maxHours - 1 ) {
                   this.hour = 0;

                   return;
               }
               this.hour++;
           },

           incrementMinute: function( step ) {
               var newVal;

               // If value is empty, make sure that first shown value is current minutes.
               if ( this.minute === '' ) {
                   this.minute = this.getCurrentMinute();
                   this.decrementMinute();
               }

               if ( step ) {
                   newVal = this.minute + step;
               } else {
                   newVal = this.minute + this.minuteStep - ( this.minute % this.minuteStep );
               }

               if ( newVal > 59 ) {
                   this.incrementHour();
                   this.minute = newVal - 60;
               } else {
                   this.minute = newVal;
               }
           },

           incrementSecond: function() {
               var newVal = this.second + this.secondStep - ( this.second % this.secondStep );

               if ( newVal > 59 ) {
                   this.incrementMinute( true );
                   this.second = newVal - 60;
               } else {
                   this.second = newVal;
               }
           },

           mousewheel: function( e ) {
               if ( this.disableMousewheel ) {
                   return;
               }

               e.preventDefault();
               e.stopPropagation();

               var delta = e.originalEvent.wheelDelta || -e.originalEvent.detail,
                   scrollTo = null;

               if ( e.type === 'mousewheel' ) {
                   scrollTo = ( e.originalEvent.wheelDelta * -1 );
               } else if ( e.type === 'DOMMouseScroll' ) {
                   scrollTo = 40 * e.originalEvent.detail;
               }

               if ( scrollTo ) {
                   e.preventDefault();
                   $( this ).scrollTop( scrollTo + $( this ).scrollTop() );
               }

               switch ( this.highlightedUnit ) {
                   case 'minute':
                       if ( delta > 0 ) {
                           this.incrementMinute();
                       } else {
                           this.decrementMinute();
                       }
                       this.highlightMinute();
                       break;
                   case 'second':
                       if ( delta > 0 ) {
                           this.incrementSecond();
                       } else {
                           this.decrementSecond();
                       }
                       this.highlightSecond();
                       break;
                   case 'meridian':
                       this.toggleMeridian();
                       this.highlightMeridian();
                       break;
                   default:
                       if ( delta > 0 ) {
                           this.incrementHour();
                       } else {
                           this.decrementHour();
                       }
                       this.highlightHour();
                       break;
               }

               return false;
           },

           /**
            * Given a segment value like 43, will round and snap the segment
            * to the nearest "step", like 45 if step is 15. Segment will
            * "overflow" to 0 if it's larger than 59 or would otherwise
            * round up to 60.
            */
           changeToNearestStep: function( segment, step ) {
               if ( segment % step === 0 ) {
                   return segment;
               }
               if ( Math.round( ( segment % step ) / step ) ) {
                   return ( segment + ( step - segment % step ) ) % 60;
               } else {
                   return segment - segment % step;
               }
           },

           // This method was adapted from datepicker.
           place: function() {
               if ( this.isInline ) {
                   return;
               }
               var widgetWidth = this.$widget.outerWidth(),
                   widgetHeight = this.$widget.outerHeight(),
                   visualPadding = 10,
                   windowWidth =
                   $( window ).width(),
                   windowHeight = $( window ).height(),
                   scrollTop = $( window ).scrollTop();

               var zIndex = parseInt( this.$element.parents().filter( function() {
                   return $( this ).css( 'z-index' ) !== 'auto';
               } ).first().css( 'z-index' ), 10 ) + 10;
               var offset = this.component ? this.component.parent().offset() : this.$element.offset();
               var height = this.component ? this.component.outerHeight( true ) : this.$element.outerHeight( false );
               var width = this.component ? this.component.outerWidth( true ) : this.$element.outerWidth( false );
               var left = offset.left,
                   top = offset.top;

               this.$widget.removeClass( 'timepicker-orient-top timepicker-orient-bottom timepicker-orient-right timepicker-orient-left' );

               if ( this.orientation.x !== 'auto' ) {
                   this.$widget.addClass( 'timepicker-orient-' + this.orientation.x );
                   if ( this.orientation.x === 'right' ) {
                       left -= widgetWidth - width;
                   }
               } else {
                   // auto x orientation is best-placement: if it crosses a window edge, fudge it sideways
                   // Default to left
                   this.$widget.addClass( 'timepicker-orient-left' );
                   if ( offset.left < 0 ) {
                       left -= offset.left - visualPadding;
                   } else if ( offset.left + widgetWidth > windowWidth ) {
                       left = windowWidth - widgetWidth - visualPadding;
                   }
               }
               // auto y orientation is best-situation: top or bottom, no fudging, decision based on which shows more of the widget
               var yorient = this.orientation.y,
                   topOverflow, bottomOverflow;
               if ( yorient === 'auto' ) {
                   topOverflow = -scrollTop + offset.top - widgetHeight;
                   bottomOverflow = scrollTop + windowHeight - ( offset.top + height + widgetHeight );
                   if ( Math.max( topOverflow, bottomOverflow ) === bottomOverflow ) {
                       yorient = 'top';
                   } else {
                       yorient = 'bottom';
                   }
               }
               this.$widget.addClass( 'timepicker-orient-' + yorient );
               if ( yorient === 'top' ) {
                   top += height;
               } else {
                   top -= widgetHeight + parseInt( this.$widget.css( 'padding-top' ), 10 );
               }

               this.$widget.css( {
                   top: top,
                   left: left,
                   zIndex: zIndex
               } );
           },

           remove: function() {
               $( 'document' ).off( '.timepicker' );
               if ( this.$widget ) {
                   this.$widget.remove();
               }
               delete this.$element.data().timepicker;
           },

           setDefaultTime: function( defaultTime ) {
               if ( !this.$element.val() ) {
                   if ( defaultTime === 'current' ) {
                       var dTime = new Date(),
                           hours = dTime.getHours(),
                           minutes = dTime.getMinutes(),
                           seconds = dTime.getSeconds(),
                           meridian = 'AM';

                       if ( seconds !== 0 ) {
                           seconds = Math.ceil( dTime.getSeconds() / this.secondStep ) * this.secondStep;
                           if ( seconds === 60 ) {
                               minutes += 1;
                               seconds = 0;
                           }
                       }

                       if ( minutes !== 0 ) {
                           minutes = Math.ceil( dTime.getMinutes() / this.minuteStep ) * this.minuteStep;
                           if ( minutes === 60 ) {
                               hours += 1;
                               minutes = 0;
                           }
                       }

                       if ( this.showMeridian ) {
                           if ( hours === 0 ) {
                               hours = 12;
                           } else if ( hours >= 12 ) {
                               if ( hours > 12 ) {
                                   hours = hours - 12;
                               }
                               meridian = 'PM';
                           } else {
                               meridian = 'AM';
                           }
                       }

                       this.hour = hours;
                       this.minute = minutes;
                       this.second = seconds;
                       this.meridian = meridian;

                       this.update();

                   } else if ( defaultTime === false ) {
                       this.hour = 0;
                       this.minute = 0;
                       this.second = 0;
                       this.meridian = 'AM';
                   } else {
                       this.setTime( defaultTime );
                   }
               } else {
                   this.updateFromElementVal();
               }
           },

           setTime: function( time, ignoreWidget ) {
               if ( !time ) {
                   this.clear();
                   return;
               }

               var timeMode,
                   timeArray,
                   hour,
                   minute,
                   second,
                   meridian;

               if ( typeof time === 'object' && time.getMonth ) {
                   // this is a date object
                   hour = time.getHours();
                   minute = time.getMinutes();
                   second = time.getSeconds();

                   if ( this.showMeridian ) {
                       meridian = 'AM';
                       if ( hour > 12 ) {
                           meridian = 'PM';
                           hour = hour % 12;
                       }

                       if ( hour === 12 ) {
                           meridian = 'PM';
                       }
                   }
               } else {
                   timeMode = ( ( /a/i ).test( time ) ? 1 : 0 ) + ( ( /p/i ).test( time ) ? 2 : 0 ); // 0 = none, 1 = AM, 2 = PM, 3 = BOTH.
                   if ( timeMode > 2 ) { // If both are present, fail.
                       this.clear();
                       return;
                   }

                   timeArray = time.replace( /[^0-9\:]/g, '' ).split( ':' );

                   hour = timeArray[ 0 ] ? timeArray[ 0 ].toString() : timeArray.toString();

                   if ( this.explicitMode && hour.length > 2 && ( hour.length % 2 ) !== 0 ) {
                       this.clear();
                       return;
                   }

                   minute = timeArray[ 1 ] ? timeArray[ 1 ].toString() : '';
                   second = timeArray[ 2 ] ? timeArray[ 2 ].toString() : '';

                   // adaptive time parsing
                   if ( hour.length > 4 ) {
                       second = hour.slice( -2 );
                       hour = hour.slice( 0, -2 );
                   }

                   if ( hour.length > 2 ) {
                       minute = hour.slice( -2 );
                       hour = hour.slice( 0, -2 );
                   }

                   if ( minute.length > 2 ) {
                       second = minute.slice( -2 );
                       minute = minute.slice( 0, -2 );
                   }

                   hour = parseInt( hour, 10 );
                   minute = parseInt( minute, 10 );
                   second = parseInt( second, 10 );

                   if ( isNaN( hour ) ) {
                       hour = 0;
                   }
                   if ( isNaN( minute ) ) {
                       minute = 0;
                   }
                   if ( isNaN( second ) ) {
                       second = 0;
                   }

                   // Adjust the time based upon unit boundary.
                   // NOTE: Negatives will never occur due to time.replace() above.
                   if ( second > 59 ) {
                       second = 59;
                   }

                   if ( minute > 59 ) {
                       minute = 59;
                   }

                   if ( hour >= this.maxHours ) {
                       // No day/date handling.
                       hour = this.maxHours - 1;
                   }

                   if ( this.showMeridian ) {
                       if ( hour > 12 ) {
                           // Force PM.
                           timeMode = 2;
                           hour -= 12;
                       }
                       if ( !timeMode ) {
                           timeMode = 1;
                       }
                       if ( hour === 0 ) {
                           hour = 12; // AM or PM, reset to 12.  0 AM = 12 AM.  0 PM = 12 PM, etc.
                       }
                       meridian = timeMode === 1 ? 'AM' : 'PM';
                   } else if ( hour < 12 && timeMode === 2 ) {
                       hour += 12;
                   } else {
                       if ( hour >= this.maxHours ) {
                           hour = this.maxHours - 1;
                       } else if ( ( hour < 0 ) || ( hour === 12 && timeMode === 1 ) ) {
                           hour = 0;
                       }
                   }
               }

               this.hour = hour;
               if ( this.snapToStep ) {
                   this.minute = this.changeToNearestStep( minute, this.minuteStep );
                   this.second = this.changeToNearestStep( second, this.secondStep );
               } else {
                   this.minute = minute;
                   this.second = second;
               }
               this.meridian = meridian;

               this.update( ignoreWidget );
           },

           showWidget: function() {
               if ( this.isOpen ) {
                   return;
               }

               if ( this.$element.is( ':disabled' ) ) {
                   return;
               }

               // make sure the widget is in sync with input
               this.setTime( this.$element.val() );
               this.updateWidget();

               // show/hide approach taken by datepicker
               this.$widget.appendTo( this.appendWidgetTo );
               $( document ).on( 'mousedown.timepicker, touchend.timepicker', {
                   scope: this
               }, this.handleDocumentClick );

               this.$element.trigger( {
                   'type': 'show.timepicker',
                   'time': {
                       'value': this.getTime(),
                       'hours': this.hour,
                       'minutes': this.minute,
                       'seconds': this.second,
                       'meridian': this.meridian
                   }
               } );

               this.place();
               if ( this.disableFocus ) {
                   this.$element.blur();
               }

               if ( this.hour === '' ) {
                   if ( this.defaultTime ) {
                       this.setDefaultTime( this.defaultTime );
                   }
               }

               if ( this.isOpen === false ) {
                   this.$widget.addClass( 'open' );
               }

               this.isOpen = true;
           },

           toggleMeridian: function() {
               this.meridian = this.meridian === 'AM' ? 'PM' : 'AM';
           },

           update: function( ignoreWidget ) {
               this.updateElement();
               if ( !ignoreWidget ) {
                   this.updateWidget();
               }

               this.$element.trigger( {
                   'type': 'changeTime.timepicker',
                   'time': {
                       'value': this.getTime(),
                       'hours': this.hour,
                       'minutes': this.minute,
                       'seconds': this.second,
                       'meridian': this.meridian
                   }
               } );
           },

           updateElement: function() {
               this.$element.val( this.getTime() ).change();
           },

           updateFromElementVal: function() {
               this.setTime( this.$element.val() );
           },

           updateWidget: function() {
               if ( this.$widget === false ) {
                   return;
               }

               var hour = this.hour,
                   minute = this.minute.toString().length === 1 ? '0' + this.minute : this.minute,
                   second = this.second.toString().length === 1 ? '0' + this.second : this.second;

               if ( this.showInputs ) {
                   this.$widget.find( 'input.timepicker-hour' ).val( hour );
                   this.$widget.find( 'input.timepicker-minute' ).val( minute );

                   if ( this.showSeconds ) {
                       this.$widget.find( 'input.timepicker-second' ).val( second );
                   }
                   if ( this.showMeridian ) {
                       this.$widget.find( 'input.timepicker-meridian' ).val( this.meridian );
                   }
               } else {
                   this.$widget.find( 'span.timepicker-hour' ).text( hour );
                   this.$widget.find( 'span.timepicker-minute' ).text( minute );

                   if ( this.showSeconds ) {
                       this.$widget.find( 'span.timepicker-second' ).text( second );
                   }
                   if ( this.showMeridian ) {
                       this.$widget.find( 'span.timepicker-meridian' ).text( this.meridian );
                   }
               }
           },

           updateFromWidgetInputs: function() {
               if ( this.$widget === false ) {
                   return;
               }

               var t = this.$widget.find( 'input.timepicker-hour' ).val() + ':' +
                   this.$widget.find( 'input.timepicker-minute' ).val() +
                   ( this.showSeconds ? ':' + this.$widget.find( 'input.timepicker-second' ).val() : '' ) +
                   ( this.showMeridian ? this.$widget.find( 'input.timepicker-meridian' ).val() : '' );

               this.setTime( t, true );
           },

           widgetClick: function( e ) {
               e.stopPropagation();
               e.preventDefault();

               var $input = $( e.target ),
                   action = $input.closest( 'a' ).data( 'action' );

               if ( action ) {
                   this[ action ]();
               }
               this.update();

               if ( $input.is( 'input' ) ) {
                   $input.get( 0 ).setSelectionRange( 0, 2 );
               }
           },

           widgetKeydown: function( e ) {
               var $input = $( e.target ),
                   name = $input.attr( 'class' ).replace( 'timepicker-', '' );

               switch ( e.which ) {
                   case 9: //tab
                       if ( e.shiftKey ) {
                           if ( name === 'hour' ) {
                               return this.hideWidget();
                           }
                       } else if ( ( this.showMeridian && name === 'meridian' ) || ( this.showSeconds && name === 'second' ) || ( !this.showMeridian && !this.showSeconds && name === 'minute' ) ) {
                           return this.hideWidget();
                       }
                       break;
                   case 27: // escape
                       this.hideWidget();
                       break;
                   case 38: // up arrow
                       e.preventDefault();
                       switch ( name ) {
                           case 'hour':
                               this.incrementHour();
                               break;
                           case 'minute':
                               this.incrementMinute();
                               break;
                           case 'second':
                               this.incrementSecond();
                               break;
                           case 'meridian':
                               this.toggleMeridian();
                               break;
                       }
                       this.setTime( this.getTime() );
                       $input.get( 0 ).setSelectionRange( 0, 2 );
                       break;
                   case 40: // down arrow
                       e.preventDefault();
                       switch ( name ) {
                           case 'hour':
                               this.decrementHour();
                               break;
                           case 'minute':
                               this.decrementMinute();
                               break;
                           case 'second':
                               this.decrementSecond();
                               break;
                           case 'meridian':
                               this.toggleMeridian();
                               break;
                       }
                       this.setTime( this.getTime() );
                       $input.get( 0 ).setSelectionRange( 0, 2 );
                       break;
               }
           },

           widgetKeyup: function( e ) {
               if ( ( e.which === 65 ) || ( e.which === 77 ) || ( e.which === 80 ) || ( e.which === 46 ) || ( e.which === 8 ) || ( e.which >= 48 && e.which <= 57 ) || ( e.which >= 96 && e.which <= 105 ) ) {
                   this.updateFromWidgetInputs();
               }
           }
       };

       //TIMEPICKER PLUGIN DEFINITION
       $.fn.timepicker = function( option ) {
           var args = Array.apply( null, arguments );
           args.shift();
           return this.each( function() {
               var $this = $( this ),
                   data = $this.data( 'timepicker' ),
                   options = typeof option === 'object' && option;

               if ( !data ) {
                   $this.data( 'timepicker', ( data = new Timepicker( this, $.extend( {}, $.fn.timepicker.defaults, options, $( this ).data() ) ) ) );
               }

               if ( typeof option === 'string' ) {
                   data[ option ].apply( data, args );
               }
           } );
       };

       $.fn.timepicker.defaults = {
           defaultTime: 'current',
           disableFocus: false,
           disableMousewheel: false,
           isOpen: false,
           minuteStep: 15,
           orientation: {
               x: 'auto',
               y: 'auto'
           },
           secondStep: 15,
           snapToStep: false,
           showSeconds: false,
           showInputs: true,
           showMeridian: true,
           template: 'dropdown',
           appendWidgetTo: 'body',
           showWidgetOnAddonClick: true,
           icons: {
               up: 'glyphicon glyphicon-chevron-up',
               down: 'glyphicon glyphicon-chevron-down'
           },
           maxHours: 24,
           explicitMode: false
       };

       $.fn.timepicker.Constructor = Timepicker;

       $( document ).on(
           'focus.timepicker.data-api click.timepicker.data-api',
           '[data-provide="timepicker"]',
           function( e ) {
               var $this = $( this );
               if ( $this.data( 'timepicker' ) ) {
                   return;
               }
               e.preventDefault();
               // component click requires us to explicitly show it
               $this.timepicker();
           }
       );

   } )( jQuery, window, document );

   },{}],
   "timepicker-extended":[function(require,module,exports){
   'use strict';

   var Widget = require( '../../js/Widget' );
   var support = require( '../../js/support' );
   var $ = require( 'jquery' );
   var types = require( '../../js/types' );
   require( './timepicker' );
   require( '../../js/dropdown.jquery' );

   var pluginName = 'timepickerExtended';

   /**
    * @constructor
    * @param {Element}                       element   Element to apply widget to.
    * @param {(boolean|{touch: boolean})}    options   options
    * @param {*=}                            event     event
    */
   function TimepickerExtended( element, options ) {
       this.namespace = pluginName;
       //call the Super constructor
       Widget.call( this, element, options );
       this._init();
   }

   TimepickerExtended.prototype = Object.create( Widget.prototype );

   TimepickerExtended.prototype.constructor = TimepickerExtended;

   /**
    * Initialize timepicker widget
    */
   TimepickerExtended.prototype._init = function() {
       var $timeI = $( this.element );
       var timeVal = $( this.element ).val();
       var $fakeTime = $( '<div class="widget timepicker">' +
           '<input class="ignore timepicker-default" type="text" value="' + timeVal + '" placeholder="hh:mm" />' +
           '<button class="btn-icon-only btn-reset" type="button"><i class="icon icon-refresh"> </i></button></div>' );
       var $resetBtn = $fakeTime.find( '.btn-reset' );
       var $fakeTimeI = $fakeTime.find( 'input' );

       $timeI.hide().after( $fakeTime );

       $fakeTimeI.timepicker( {
               defaultTime: ( timeVal.length > 0 ) ? timeVal : false,
               showMeridian: false
           } ).val( timeVal )
           //the time picker itself has input elements
           .closest( '.widget' ).find( 'input' ).addClass( 'ignore' );

       $fakeTimeI.on( 'change', function() {
           $timeI.val( this.value ).trigger( 'change' );
           return false;
       } );

       // reset button
       $resetBtn.on( 'click', function() {
           $fakeTimeI.val( '' ).trigger( 'change' );
       } );

       // pass widget focus event
       $fakeTimeI.on( 'focus', function() {
           $timeI.trigger( 'fakefocus' );
       } );

       // handle original input focus
       $( this.element ).on( 'applyfocus', function() {
           $fakeTimeI.focus();
       } );

   };

   $.fn[ pluginName ] = function( options, event ) {

       options = options || {};

       return this.each( function() {
           var $this = $( this ),
               data = $this.data( pluginName );

           if ( !data && typeof options === 'object' && ( !options.touch || !support.inputtypes.time ) ) {
               $this.data( pluginName, new TimepickerExtended( this, options, event ) );
           }
           //only call method if widget was instantiated before
           else if ( data && typeof options === 'string' ) {
               //pass the element as a parameter as this is used in fix()
               data[ options ]( this );
           }
       } );
   };

   module.exports = {
       'name': pluginName,
       'selector': 'input[type="time"]:not([readonly])'
   };

   },{"../../js/Widget":"Widget","../../js/support":"support","jquery":"jquery","../../js/types":"types","./timepicker":"timepicker","../../js/dropdown.jquery":"dropdown.jquery"}],
   "text!enketo-config":[function(require,module,exports){
   module.exports={
    "maps": [ {
        "tiles": [ "http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png" ],
        "name": "streets",
        "attribution": "Map data  <a href=\"http://openstreetmap.org\">OpenStreetMap</a> contributors"
    }, {
        "tiles": "GOOGLE_SATELLITE",
        "name": "satellite"
    } ],
    "googleApiKey": ""
}
   },{}]},{},["apps"]);